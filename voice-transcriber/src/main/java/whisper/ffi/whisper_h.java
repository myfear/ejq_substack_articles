// Generated by jextract

package whisper.ffi;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class whisper_h extends whisper_h$shared {

    whisper_h() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();

    static final SymbolLookup SYMBOL_LOOKUP;

    static {
        // 1. HARDCODE your library path here.
        // This creates a direct handle to the file, bypassing ClassLoader issues.
        String libPath = "/Users/meisele/Projects/whisper.cpp/build/src/libwhisper.dylib";

        System.out.println("DEBUG: Loading library from " + libPath);

        try {
            // Load the library directly into this lookup
            SymbolLookup libLookup = SymbolLookup.libraryLookup(java.nio.file.Path.of(libPath), LIBRARY_ARENA);

            // 2. Define a lookup strategy that handles the macOS underscore automatically
            SYMBOL_LOOKUP = name -> {
                // Try exact name
                var result = libLookup.find(name);
                if (result.isPresent())
                    return result;

                // Try macOS underscore prefix
                result = libLookup.find("_" + name);
                if (result.isPresent())
                    return result;

                return java.util.Optional.empty();
            };

        } catch (Throwable t) {
            t.printStackTrace();
            throw new RuntimeException("Failed to load whisper library: " + t.getMessage(), t);
        }
    }

    private static class whisper_init_from_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                whisper_h.C_POINTER,
                whisper_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("whisper_init_from_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * struct whisper_context *whisper_init_from_file(const char *path_model)
     * }
     */
    public static FunctionDescriptor whisper_init_from_file$descriptor() {
        return whisper_init_from_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * struct whisper_context *whisper_init_from_file(const char *path_model)
     * }
     */
    public static MethodHandle whisper_init_from_file$handle() {
        return whisper_init_from_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * struct whisper_context *whisper_init_from_file(const char *path_model)
     * }
     */
    public static MemorySegment whisper_init_from_file$address() {
        return whisper_init_from_file.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * struct whisper_context *whisper_init_from_file(const char *path_model)
     * }
     */
    public static MemorySegment whisper_init_from_file(MemorySegment path_model) {
        var mh$ = whisper_init_from_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("whisper_init_from_file", path_model);
            }
            return (MemorySegment) mh$.invokeExact(path_model);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class whisper_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
                whisper_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("whisper_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c : * void whisper_free(struct whisper_context *ctx)
     * }
     */
    public static FunctionDescriptor whisper_free$descriptor() {
        return whisper_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c : * void whisper_free(struct whisper_context *ctx)
     * }
     */
    public static MethodHandle whisper_free$handle() {
        return whisper_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c : * void whisper_free(struct whisper_context *ctx)
     * }
     */
    public static MemorySegment whisper_free$address() {
        return whisper_free.ADDR;
    }

    /**
     * {@snippet lang = c : * void whisper_free(struct whisper_context *ctx)
     * }
     */
    public static void whisper_free(MemorySegment ctx) {
        var mh$ = whisper_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("whisper_free", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class whisper_full_default_params {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                whisper_full_params.layout(),
                whisper_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("whisper_full_default_params");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * struct whisper_full_params whisper_full_default_params(enum whisper_sampling_strategy strategy)
     * }
     */
    public static FunctionDescriptor whisper_full_default_params$descriptor() {
        return whisper_full_default_params.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * struct whisper_full_params whisper_full_default_params(enum whisper_sampling_strategy strategy)
     * }
     */
    public static MethodHandle whisper_full_default_params$handle() {
        return whisper_full_default_params.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * struct whisper_full_params whisper_full_default_params(enum whisper_sampling_strategy strategy)
     * }
     */
    public static MemorySegment whisper_full_default_params$address() {
        return whisper_full_default_params.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * struct whisper_full_params whisper_full_default_params(enum whisper_sampling_strategy strategy)
     * }
     */
    public static MemorySegment whisper_full_default_params(SegmentAllocator allocator, int strategy) {
        var mh$ = whisper_full_default_params.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("whisper_full_default_params", allocator, strategy);
            }
            return (MemorySegment) mh$.invokeExact(allocator, strategy);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class whisper_full {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                whisper_h.C_INT,
                whisper_h.C_POINTER,
                whisper_full_params.layout(),
                whisper_h.C_POINTER,
                whisper_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("whisper_full");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int whisper_full(struct whisper_context *ctx, struct whisper_full_params params, const float *samples, int n_samples)
     * }
     */
    public static FunctionDescriptor whisper_full$descriptor() {
        return whisper_full.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int whisper_full(struct whisper_context *ctx, struct whisper_full_params params, const float *samples, int n_samples)
     * }
     */
    public static MethodHandle whisper_full$handle() {
        return whisper_full.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int whisper_full(struct whisper_context *ctx, struct whisper_full_params params, const float *samples, int n_samples)
     * }
     */
    public static MemorySegment whisper_full$address() {
        return whisper_full.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int whisper_full(struct whisper_context *ctx, struct whisper_full_params params, const float *samples, int n_samples)
     * }
     */
    public static int whisper_full(MemorySegment ctx, MemorySegment params, MemorySegment samples, int n_samples) {
        var mh$ = whisper_full.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("whisper_full", ctx, params, samples, n_samples);
            }
            return (int) mh$.invokeExact(ctx, params, samples, n_samples);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class whisper_full_n_segments {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                whisper_h.C_INT,
                whisper_h.C_POINTER);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("whisper_full_n_segments");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * int whisper_full_n_segments(struct whisper_context *ctx)
     * }
     */
    public static FunctionDescriptor whisper_full_n_segments$descriptor() {
        return whisper_full_n_segments.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * int whisper_full_n_segments(struct whisper_context *ctx)
     * }
     */
    public static MethodHandle whisper_full_n_segments$handle() {
        return whisper_full_n_segments.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * int whisper_full_n_segments(struct whisper_context *ctx)
     * }
     */
    public static MemorySegment whisper_full_n_segments$address() {
        return whisper_full_n_segments.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * int whisper_full_n_segments(struct whisper_context *ctx)
     * }
     */
    public static int whisper_full_n_segments(MemorySegment ctx) {
        var mh$ = whisper_full_n_segments.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("whisper_full_n_segments", ctx);
            }
            return (int) mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class whisper_full_get_segment_text {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
                whisper_h.C_POINTER,
                whisper_h.C_POINTER,
                whisper_h.C_INT);

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("whisper_full_get_segment_text");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang = c
     * : * const char *whisper_full_get_segment_text(struct whisper_context *ctx, int i_segment)
     * }
     */
    public static FunctionDescriptor whisper_full_get_segment_text$descriptor() {
        return whisper_full_get_segment_text.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang = c
     * : * const char *whisper_full_get_segment_text(struct whisper_context *ctx, int i_segment)
     * }
     */
    public static MethodHandle whisper_full_get_segment_text$handle() {
        return whisper_full_get_segment_text.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang = c
     * : * const char *whisper_full_get_segment_text(struct whisper_context *ctx, int i_segment)
     * }
     */
    public static MemorySegment whisper_full_get_segment_text$address() {
        return whisper_full_get_segment_text.ADDR;
    }

    /**
     * {@snippet lang = c
     * : * const char *whisper_full_get_segment_text(struct whisper_context *ctx, int i_segment)
     * }
     */
    public static MemorySegment whisper_full_get_segment_text(MemorySegment ctx, int i_segment) {
        var mh$ = whisper_full_get_segment_text.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("whisper_full_get_segment_text", ctx, i_segment);
            }
            return (MemorySegment) mh$.invokeExact(ctx, i_segment);
        } catch (Error | RuntimeException ex) {
            throw ex;
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }
}
