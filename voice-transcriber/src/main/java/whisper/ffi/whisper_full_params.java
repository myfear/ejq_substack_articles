// Generated by jextract

package whisper.ffi;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct whisper_full_params {
 *     enum whisper_sampling_strategy strategy;
 *     int n_threads;
 *     int n_max_text_ctx;
 *     int offset_ms;
 *     int duration_ms;
 *     bool translate;
 *     bool no_context;
 *     bool no_timestamps;
 *     bool single_segment;
 *     bool print_special;
 *     bool print_progress;
 *     bool print_realtime;
 *     bool print_timestamps;
 *     bool token_timestamps;
 *     float thold_pt;
 *     float thold_ptsum;
 *     int max_len;
 *     bool split_on_word;
 *     int max_tokens;
 *     bool debug_mode;
 *     int audio_ctx;
 *     bool tdrz_enable;
 *     const char *suppress_regex;
 *     const char *initial_prompt;
 *     bool carry_initial_prompt;
 *     const whisper_token *prompt_tokens;
 *     int prompt_n_tokens;
 *     const char *language;
 *     bool detect_language;
 *     bool suppress_blank;
 *     bool suppress_nst;
 *     float temperature;
 *     float max_initial_ts;
 *     float length_penalty;
 *     float temperature_inc;
 *     float entropy_thold;
 *     float logprob_thold;
 *     float no_speech_thold;
 *     struct {
 *         int best_of;
 *     } greedy;
 *     struct {
 *         int beam_size;
 *         float patience;
 *     } beam_search;
 *     whisper_new_segment_callback new_segment_callback;
 *     void *new_segment_callback_user_data;
 *     whisper_progress_callback progress_callback;
 *     void *progress_callback_user_data;
 *     whisper_encoder_begin_callback encoder_begin_callback;
 *     void *encoder_begin_callback_user_data;
 *     ggml_abort_callback abort_callback;
 *     void *abort_callback_user_data;
 *     whisper_logits_filter_callback logits_filter_callback;
 *     void *logits_filter_callback_user_data;
 *     const whisper_grammar_element **grammar_rules;
 *     size_t n_grammar_rules;
 *     size_t i_start_rule;
 *     float grammar_penalty;
 *     bool vad;
 *     const char *vad_model_path;
 *     whisper_vad_params vad_params;
 * }
 * }
 */
public class whisper_full_params {

    whisper_full_params() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        whisper_h.C_INT.withName("strategy"),
        whisper_h.C_INT.withName("n_threads"),
        whisper_h.C_INT.withName("n_max_text_ctx"),
        whisper_h.C_INT.withName("offset_ms"),
        whisper_h.C_INT.withName("duration_ms"),
        whisper_h.C_BOOL.withName("translate"),
        whisper_h.C_BOOL.withName("no_context"),
        whisper_h.C_BOOL.withName("no_timestamps"),
        whisper_h.C_BOOL.withName("single_segment"),
        whisper_h.C_BOOL.withName("print_special"),
        whisper_h.C_BOOL.withName("print_progress"),
        whisper_h.C_BOOL.withName("print_realtime"),
        whisper_h.C_BOOL.withName("print_timestamps"),
        whisper_h.C_BOOL.withName("token_timestamps"),
        MemoryLayout.paddingLayout(3),
        whisper_h.C_FLOAT.withName("thold_pt"),
        whisper_h.C_FLOAT.withName("thold_ptsum"),
        whisper_h.C_INT.withName("max_len"),
        whisper_h.C_BOOL.withName("split_on_word"),
        MemoryLayout.paddingLayout(3),
        whisper_h.C_INT.withName("max_tokens"),
        whisper_h.C_BOOL.withName("debug_mode"),
        MemoryLayout.paddingLayout(3),
        whisper_h.C_INT.withName("audio_ctx"),
        whisper_h.C_BOOL.withName("tdrz_enable"),
        MemoryLayout.paddingLayout(3),
        whisper_h.C_POINTER.withName("suppress_regex"),
        whisper_h.C_POINTER.withName("initial_prompt"),
        whisper_h.C_BOOL.withName("carry_initial_prompt"),
        MemoryLayout.paddingLayout(7),
        whisper_h.C_POINTER.withName("prompt_tokens"),
        whisper_h.C_INT.withName("prompt_n_tokens"),
        MemoryLayout.paddingLayout(4),
        whisper_h.C_POINTER.withName("language"),
        whisper_h.C_BOOL.withName("detect_language"),
        whisper_h.C_BOOL.withName("suppress_blank"),
        whisper_h.C_BOOL.withName("suppress_nst"),
        MemoryLayout.paddingLayout(1),
        whisper_h.C_FLOAT.withName("temperature"),
        whisper_h.C_FLOAT.withName("max_initial_ts"),
        whisper_h.C_FLOAT.withName("length_penalty"),
        whisper_h.C_FLOAT.withName("temperature_inc"),
        whisper_h.C_FLOAT.withName("entropy_thold"),
        whisper_h.C_FLOAT.withName("logprob_thold"),
        whisper_h.C_FLOAT.withName("no_speech_thold"),
        whisper_full_params.greedy.layout().withName("greedy"),
        whisper_full_params.beam_search.layout().withName("beam_search"),
        MemoryLayout.paddingLayout(4),
        whisper_h.C_POINTER.withName("new_segment_callback"),
        whisper_h.C_POINTER.withName("new_segment_callback_user_data"),
        whisper_h.C_POINTER.withName("progress_callback"),
        whisper_h.C_POINTER.withName("progress_callback_user_data"),
        whisper_h.C_POINTER.withName("encoder_begin_callback"),
        whisper_h.C_POINTER.withName("encoder_begin_callback_user_data"),
        whisper_h.C_POINTER.withName("abort_callback"),
        whisper_h.C_POINTER.withName("abort_callback_user_data"),
        whisper_h.C_POINTER.withName("logits_filter_callback"),
        whisper_h.C_POINTER.withName("logits_filter_callback_user_data"),
        whisper_h.C_POINTER.withName("grammar_rules"),
        whisper_h.C_LONG.withName("n_grammar_rules"),
        whisper_h.C_LONG.withName("i_start_rule"),
        whisper_h.C_FLOAT.withName("grammar_penalty"),
        whisper_h.C_BOOL.withName("vad"),
        MemoryLayout.paddingLayout(3),
        whisper_h.C_POINTER.withName("vad_model_path"),
        whisper_vad_params.layout().withName("vad_params")
    ).withName("whisper_full_params");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final OfInt strategy$LAYOUT = (OfInt)$LAYOUT.select(groupElement("strategy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * enum whisper_sampling_strategy strategy
     * }
     */
    public static final OfInt strategy$layout() {
        return strategy$LAYOUT;
    }

    private static final long strategy$OFFSET = $LAYOUT.byteOffset(groupElement("strategy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * enum whisper_sampling_strategy strategy
     * }
     */
    public static final long strategy$offset() {
        return strategy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * enum whisper_sampling_strategy strategy
     * }
     */
    public static int strategy(MemorySegment struct) {
        return struct.get(strategy$LAYOUT, strategy$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * enum whisper_sampling_strategy strategy
     * }
     */
    public static void strategy(MemorySegment struct, int fieldValue) {
        struct.set(strategy$LAYOUT, strategy$OFFSET, fieldValue);
    }

    private static final OfInt n_threads$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_threads"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int n_threads
     * }
     */
    public static final OfInt n_threads$layout() {
        return n_threads$LAYOUT;
    }

    private static final long n_threads$OFFSET = $LAYOUT.byteOffset(groupElement("n_threads"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int n_threads
     * }
     */
    public static final long n_threads$offset() {
        return n_threads$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int n_threads
     * }
     */
    public static int n_threads(MemorySegment struct) {
        return struct.get(n_threads$LAYOUT, n_threads$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int n_threads
     * }
     */
    public static void n_threads(MemorySegment struct, int fieldValue) {
        struct.set(n_threads$LAYOUT, n_threads$OFFSET, fieldValue);
    }

    private static final OfInt n_max_text_ctx$LAYOUT = (OfInt)$LAYOUT.select(groupElement("n_max_text_ctx"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int n_max_text_ctx
     * }
     */
    public static final OfInt n_max_text_ctx$layout() {
        return n_max_text_ctx$LAYOUT;
    }

    private static final long n_max_text_ctx$OFFSET = $LAYOUT.byteOffset(groupElement("n_max_text_ctx"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int n_max_text_ctx
     * }
     */
    public static final long n_max_text_ctx$offset() {
        return n_max_text_ctx$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int n_max_text_ctx
     * }
     */
    public static int n_max_text_ctx(MemorySegment struct) {
        return struct.get(n_max_text_ctx$LAYOUT, n_max_text_ctx$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int n_max_text_ctx
     * }
     */
    public static void n_max_text_ctx(MemorySegment struct, int fieldValue) {
        struct.set(n_max_text_ctx$LAYOUT, n_max_text_ctx$OFFSET, fieldValue);
    }

    private static final OfInt offset_ms$LAYOUT = (OfInt)$LAYOUT.select(groupElement("offset_ms"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int offset_ms
     * }
     */
    public static final OfInt offset_ms$layout() {
        return offset_ms$LAYOUT;
    }

    private static final long offset_ms$OFFSET = $LAYOUT.byteOffset(groupElement("offset_ms"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int offset_ms
     * }
     */
    public static final long offset_ms$offset() {
        return offset_ms$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int offset_ms
     * }
     */
    public static int offset_ms(MemorySegment struct) {
        return struct.get(offset_ms$LAYOUT, offset_ms$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int offset_ms
     * }
     */
    public static void offset_ms(MemorySegment struct, int fieldValue) {
        struct.set(offset_ms$LAYOUT, offset_ms$OFFSET, fieldValue);
    }

    private static final OfInt duration_ms$LAYOUT = (OfInt)$LAYOUT.select(groupElement("duration_ms"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int duration_ms
     * }
     */
    public static final OfInt duration_ms$layout() {
        return duration_ms$LAYOUT;
    }

    private static final long duration_ms$OFFSET = $LAYOUT.byteOffset(groupElement("duration_ms"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int duration_ms
     * }
     */
    public static final long duration_ms$offset() {
        return duration_ms$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int duration_ms
     * }
     */
    public static int duration_ms(MemorySegment struct) {
        return struct.get(duration_ms$LAYOUT, duration_ms$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int duration_ms
     * }
     */
    public static void duration_ms(MemorySegment struct, int fieldValue) {
        struct.set(duration_ms$LAYOUT, duration_ms$OFFSET, fieldValue);
    }

    private static final OfBoolean translate$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("translate"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool translate
     * }
     */
    public static final OfBoolean translate$layout() {
        return translate$LAYOUT;
    }

    private static final long translate$OFFSET = $LAYOUT.byteOffset(groupElement("translate"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool translate
     * }
     */
    public static final long translate$offset() {
        return translate$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool translate
     * }
     */
    public static boolean translate(MemorySegment struct) {
        return struct.get(translate$LAYOUT, translate$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool translate
     * }
     */
    public static void translate(MemorySegment struct, boolean fieldValue) {
        struct.set(translate$LAYOUT, translate$OFFSET, fieldValue);
    }

    private static final OfBoolean no_context$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("no_context"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool no_context
     * }
     */
    public static final OfBoolean no_context$layout() {
        return no_context$LAYOUT;
    }

    private static final long no_context$OFFSET = $LAYOUT.byteOffset(groupElement("no_context"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool no_context
     * }
     */
    public static final long no_context$offset() {
        return no_context$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool no_context
     * }
     */
    public static boolean no_context(MemorySegment struct) {
        return struct.get(no_context$LAYOUT, no_context$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool no_context
     * }
     */
    public static void no_context(MemorySegment struct, boolean fieldValue) {
        struct.set(no_context$LAYOUT, no_context$OFFSET, fieldValue);
    }

    private static final OfBoolean no_timestamps$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("no_timestamps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool no_timestamps
     * }
     */
    public static final OfBoolean no_timestamps$layout() {
        return no_timestamps$LAYOUT;
    }

    private static final long no_timestamps$OFFSET = $LAYOUT.byteOffset(groupElement("no_timestamps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool no_timestamps
     * }
     */
    public static final long no_timestamps$offset() {
        return no_timestamps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool no_timestamps
     * }
     */
    public static boolean no_timestamps(MemorySegment struct) {
        return struct.get(no_timestamps$LAYOUT, no_timestamps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool no_timestamps
     * }
     */
    public static void no_timestamps(MemorySegment struct, boolean fieldValue) {
        struct.set(no_timestamps$LAYOUT, no_timestamps$OFFSET, fieldValue);
    }

    private static final OfBoolean single_segment$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("single_segment"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool single_segment
     * }
     */
    public static final OfBoolean single_segment$layout() {
        return single_segment$LAYOUT;
    }

    private static final long single_segment$OFFSET = $LAYOUT.byteOffset(groupElement("single_segment"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool single_segment
     * }
     */
    public static final long single_segment$offset() {
        return single_segment$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool single_segment
     * }
     */
    public static boolean single_segment(MemorySegment struct) {
        return struct.get(single_segment$LAYOUT, single_segment$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool single_segment
     * }
     */
    public static void single_segment(MemorySegment struct, boolean fieldValue) {
        struct.set(single_segment$LAYOUT, single_segment$OFFSET, fieldValue);
    }

    private static final OfBoolean print_special$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("print_special"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool print_special
     * }
     */
    public static final OfBoolean print_special$layout() {
        return print_special$LAYOUT;
    }

    private static final long print_special$OFFSET = $LAYOUT.byteOffset(groupElement("print_special"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool print_special
     * }
     */
    public static final long print_special$offset() {
        return print_special$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool print_special
     * }
     */
    public static boolean print_special(MemorySegment struct) {
        return struct.get(print_special$LAYOUT, print_special$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool print_special
     * }
     */
    public static void print_special(MemorySegment struct, boolean fieldValue) {
        struct.set(print_special$LAYOUT, print_special$OFFSET, fieldValue);
    }

    private static final OfBoolean print_progress$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("print_progress"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool print_progress
     * }
     */
    public static final OfBoolean print_progress$layout() {
        return print_progress$LAYOUT;
    }

    private static final long print_progress$OFFSET = $LAYOUT.byteOffset(groupElement("print_progress"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool print_progress
     * }
     */
    public static final long print_progress$offset() {
        return print_progress$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool print_progress
     * }
     */
    public static boolean print_progress(MemorySegment struct) {
        return struct.get(print_progress$LAYOUT, print_progress$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool print_progress
     * }
     */
    public static void print_progress(MemorySegment struct, boolean fieldValue) {
        struct.set(print_progress$LAYOUT, print_progress$OFFSET, fieldValue);
    }

    private static final OfBoolean print_realtime$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("print_realtime"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool print_realtime
     * }
     */
    public static final OfBoolean print_realtime$layout() {
        return print_realtime$LAYOUT;
    }

    private static final long print_realtime$OFFSET = $LAYOUT.byteOffset(groupElement("print_realtime"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool print_realtime
     * }
     */
    public static final long print_realtime$offset() {
        return print_realtime$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool print_realtime
     * }
     */
    public static boolean print_realtime(MemorySegment struct) {
        return struct.get(print_realtime$LAYOUT, print_realtime$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool print_realtime
     * }
     */
    public static void print_realtime(MemorySegment struct, boolean fieldValue) {
        struct.set(print_realtime$LAYOUT, print_realtime$OFFSET, fieldValue);
    }

    private static final OfBoolean print_timestamps$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("print_timestamps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool print_timestamps
     * }
     */
    public static final OfBoolean print_timestamps$layout() {
        return print_timestamps$LAYOUT;
    }

    private static final long print_timestamps$OFFSET = $LAYOUT.byteOffset(groupElement("print_timestamps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool print_timestamps
     * }
     */
    public static final long print_timestamps$offset() {
        return print_timestamps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool print_timestamps
     * }
     */
    public static boolean print_timestamps(MemorySegment struct) {
        return struct.get(print_timestamps$LAYOUT, print_timestamps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool print_timestamps
     * }
     */
    public static void print_timestamps(MemorySegment struct, boolean fieldValue) {
        struct.set(print_timestamps$LAYOUT, print_timestamps$OFFSET, fieldValue);
    }

    private static final OfBoolean token_timestamps$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("token_timestamps"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool token_timestamps
     * }
     */
    public static final OfBoolean token_timestamps$layout() {
        return token_timestamps$LAYOUT;
    }

    private static final long token_timestamps$OFFSET = $LAYOUT.byteOffset(groupElement("token_timestamps"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool token_timestamps
     * }
     */
    public static final long token_timestamps$offset() {
        return token_timestamps$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool token_timestamps
     * }
     */
    public static boolean token_timestamps(MemorySegment struct) {
        return struct.get(token_timestamps$LAYOUT, token_timestamps$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool token_timestamps
     * }
     */
    public static void token_timestamps(MemorySegment struct, boolean fieldValue) {
        struct.set(token_timestamps$LAYOUT, token_timestamps$OFFSET, fieldValue);
    }

    private static final OfFloat thold_pt$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("thold_pt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float thold_pt
     * }
     */
    public static final OfFloat thold_pt$layout() {
        return thold_pt$LAYOUT;
    }

    private static final long thold_pt$OFFSET = $LAYOUT.byteOffset(groupElement("thold_pt"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float thold_pt
     * }
     */
    public static final long thold_pt$offset() {
        return thold_pt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float thold_pt
     * }
     */
    public static float thold_pt(MemorySegment struct) {
        return struct.get(thold_pt$LAYOUT, thold_pt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float thold_pt
     * }
     */
    public static void thold_pt(MemorySegment struct, float fieldValue) {
        struct.set(thold_pt$LAYOUT, thold_pt$OFFSET, fieldValue);
    }

    private static final OfFloat thold_ptsum$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("thold_ptsum"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float thold_ptsum
     * }
     */
    public static final OfFloat thold_ptsum$layout() {
        return thold_ptsum$LAYOUT;
    }

    private static final long thold_ptsum$OFFSET = $LAYOUT.byteOffset(groupElement("thold_ptsum"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float thold_ptsum
     * }
     */
    public static final long thold_ptsum$offset() {
        return thold_ptsum$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float thold_ptsum
     * }
     */
    public static float thold_ptsum(MemorySegment struct) {
        return struct.get(thold_ptsum$LAYOUT, thold_ptsum$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float thold_ptsum
     * }
     */
    public static void thold_ptsum(MemorySegment struct, float fieldValue) {
        struct.set(thold_ptsum$LAYOUT, thold_ptsum$OFFSET, fieldValue);
    }

    private static final OfInt max_len$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_len"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_len
     * }
     */
    public static final OfInt max_len$layout() {
        return max_len$LAYOUT;
    }

    private static final long max_len$OFFSET = $LAYOUT.byteOffset(groupElement("max_len"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_len
     * }
     */
    public static final long max_len$offset() {
        return max_len$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_len
     * }
     */
    public static int max_len(MemorySegment struct) {
        return struct.get(max_len$LAYOUT, max_len$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_len
     * }
     */
    public static void max_len(MemorySegment struct, int fieldValue) {
        struct.set(max_len$LAYOUT, max_len$OFFSET, fieldValue);
    }

    private static final OfBoolean split_on_word$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("split_on_word"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool split_on_word
     * }
     */
    public static final OfBoolean split_on_word$layout() {
        return split_on_word$LAYOUT;
    }

    private static final long split_on_word$OFFSET = $LAYOUT.byteOffset(groupElement("split_on_word"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool split_on_word
     * }
     */
    public static final long split_on_word$offset() {
        return split_on_word$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool split_on_word
     * }
     */
    public static boolean split_on_word(MemorySegment struct) {
        return struct.get(split_on_word$LAYOUT, split_on_word$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool split_on_word
     * }
     */
    public static void split_on_word(MemorySegment struct, boolean fieldValue) {
        struct.set(split_on_word$LAYOUT, split_on_word$OFFSET, fieldValue);
    }

    private static final OfInt max_tokens$LAYOUT = (OfInt)$LAYOUT.select(groupElement("max_tokens"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int max_tokens
     * }
     */
    public static final OfInt max_tokens$layout() {
        return max_tokens$LAYOUT;
    }

    private static final long max_tokens$OFFSET = $LAYOUT.byteOffset(groupElement("max_tokens"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int max_tokens
     * }
     */
    public static final long max_tokens$offset() {
        return max_tokens$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int max_tokens
     * }
     */
    public static int max_tokens(MemorySegment struct) {
        return struct.get(max_tokens$LAYOUT, max_tokens$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int max_tokens
     * }
     */
    public static void max_tokens(MemorySegment struct, int fieldValue) {
        struct.set(max_tokens$LAYOUT, max_tokens$OFFSET, fieldValue);
    }

    private static final OfBoolean debug_mode$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("debug_mode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool debug_mode
     * }
     */
    public static final OfBoolean debug_mode$layout() {
        return debug_mode$LAYOUT;
    }

    private static final long debug_mode$OFFSET = $LAYOUT.byteOffset(groupElement("debug_mode"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool debug_mode
     * }
     */
    public static final long debug_mode$offset() {
        return debug_mode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool debug_mode
     * }
     */
    public static boolean debug_mode(MemorySegment struct) {
        return struct.get(debug_mode$LAYOUT, debug_mode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool debug_mode
     * }
     */
    public static void debug_mode(MemorySegment struct, boolean fieldValue) {
        struct.set(debug_mode$LAYOUT, debug_mode$OFFSET, fieldValue);
    }

    private static final OfInt audio_ctx$LAYOUT = (OfInt)$LAYOUT.select(groupElement("audio_ctx"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int audio_ctx
     * }
     */
    public static final OfInt audio_ctx$layout() {
        return audio_ctx$LAYOUT;
    }

    private static final long audio_ctx$OFFSET = $LAYOUT.byteOffset(groupElement("audio_ctx"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int audio_ctx
     * }
     */
    public static final long audio_ctx$offset() {
        return audio_ctx$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int audio_ctx
     * }
     */
    public static int audio_ctx(MemorySegment struct) {
        return struct.get(audio_ctx$LAYOUT, audio_ctx$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int audio_ctx
     * }
     */
    public static void audio_ctx(MemorySegment struct, int fieldValue) {
        struct.set(audio_ctx$LAYOUT, audio_ctx$OFFSET, fieldValue);
    }

    private static final OfBoolean tdrz_enable$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("tdrz_enable"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool tdrz_enable
     * }
     */
    public static final OfBoolean tdrz_enable$layout() {
        return tdrz_enable$LAYOUT;
    }

    private static final long tdrz_enable$OFFSET = $LAYOUT.byteOffset(groupElement("tdrz_enable"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool tdrz_enable
     * }
     */
    public static final long tdrz_enable$offset() {
        return tdrz_enable$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool tdrz_enable
     * }
     */
    public static boolean tdrz_enable(MemorySegment struct) {
        return struct.get(tdrz_enable$LAYOUT, tdrz_enable$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool tdrz_enable
     * }
     */
    public static void tdrz_enable(MemorySegment struct, boolean fieldValue) {
        struct.set(tdrz_enable$LAYOUT, tdrz_enable$OFFSET, fieldValue);
    }

    private static final AddressLayout suppress_regex$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("suppress_regex"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *suppress_regex
     * }
     */
    public static final AddressLayout suppress_regex$layout() {
        return suppress_regex$LAYOUT;
    }

    private static final long suppress_regex$OFFSET = $LAYOUT.byteOffset(groupElement("suppress_regex"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *suppress_regex
     * }
     */
    public static final long suppress_regex$offset() {
        return suppress_regex$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *suppress_regex
     * }
     */
    public static MemorySegment suppress_regex(MemorySegment struct) {
        return struct.get(suppress_regex$LAYOUT, suppress_regex$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *suppress_regex
     * }
     */
    public static void suppress_regex(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(suppress_regex$LAYOUT, suppress_regex$OFFSET, fieldValue);
    }

    private static final AddressLayout initial_prompt$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("initial_prompt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *initial_prompt
     * }
     */
    public static final AddressLayout initial_prompt$layout() {
        return initial_prompt$LAYOUT;
    }

    private static final long initial_prompt$OFFSET = $LAYOUT.byteOffset(groupElement("initial_prompt"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *initial_prompt
     * }
     */
    public static final long initial_prompt$offset() {
        return initial_prompt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *initial_prompt
     * }
     */
    public static MemorySegment initial_prompt(MemorySegment struct) {
        return struct.get(initial_prompt$LAYOUT, initial_prompt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *initial_prompt
     * }
     */
    public static void initial_prompt(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(initial_prompt$LAYOUT, initial_prompt$OFFSET, fieldValue);
    }

    private static final OfBoolean carry_initial_prompt$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("carry_initial_prompt"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool carry_initial_prompt
     * }
     */
    public static final OfBoolean carry_initial_prompt$layout() {
        return carry_initial_prompt$LAYOUT;
    }

    private static final long carry_initial_prompt$OFFSET = $LAYOUT.byteOffset(groupElement("carry_initial_prompt"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool carry_initial_prompt
     * }
     */
    public static final long carry_initial_prompt$offset() {
        return carry_initial_prompt$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool carry_initial_prompt
     * }
     */
    public static boolean carry_initial_prompt(MemorySegment struct) {
        return struct.get(carry_initial_prompt$LAYOUT, carry_initial_prompt$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool carry_initial_prompt
     * }
     */
    public static void carry_initial_prompt(MemorySegment struct, boolean fieldValue) {
        struct.set(carry_initial_prompt$LAYOUT, carry_initial_prompt$OFFSET, fieldValue);
    }

    private static final AddressLayout prompt_tokens$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("prompt_tokens"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const whisper_token *prompt_tokens
     * }
     */
    public static final AddressLayout prompt_tokens$layout() {
        return prompt_tokens$LAYOUT;
    }

    private static final long prompt_tokens$OFFSET = $LAYOUT.byteOffset(groupElement("prompt_tokens"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const whisper_token *prompt_tokens
     * }
     */
    public static final long prompt_tokens$offset() {
        return prompt_tokens$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const whisper_token *prompt_tokens
     * }
     */
    public static MemorySegment prompt_tokens(MemorySegment struct) {
        return struct.get(prompt_tokens$LAYOUT, prompt_tokens$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const whisper_token *prompt_tokens
     * }
     */
    public static void prompt_tokens(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(prompt_tokens$LAYOUT, prompt_tokens$OFFSET, fieldValue);
    }

    private static final OfInt prompt_n_tokens$LAYOUT = (OfInt)$LAYOUT.select(groupElement("prompt_n_tokens"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int prompt_n_tokens
     * }
     */
    public static final OfInt prompt_n_tokens$layout() {
        return prompt_n_tokens$LAYOUT;
    }

    private static final long prompt_n_tokens$OFFSET = $LAYOUT.byteOffset(groupElement("prompt_n_tokens"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int prompt_n_tokens
     * }
     */
    public static final long prompt_n_tokens$offset() {
        return prompt_n_tokens$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int prompt_n_tokens
     * }
     */
    public static int prompt_n_tokens(MemorySegment struct) {
        return struct.get(prompt_n_tokens$LAYOUT, prompt_n_tokens$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int prompt_n_tokens
     * }
     */
    public static void prompt_n_tokens(MemorySegment struct, int fieldValue) {
        struct.set(prompt_n_tokens$LAYOUT, prompt_n_tokens$OFFSET, fieldValue);
    }

    private static final AddressLayout language$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("language"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *language
     * }
     */
    public static final AddressLayout language$layout() {
        return language$LAYOUT;
    }

    private static final long language$OFFSET = $LAYOUT.byteOffset(groupElement("language"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *language
     * }
     */
    public static final long language$offset() {
        return language$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *language
     * }
     */
    public static MemorySegment language(MemorySegment struct) {
        return struct.get(language$LAYOUT, language$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *language
     * }
     */
    public static void language(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(language$LAYOUT, language$OFFSET, fieldValue);
    }

    private static final OfBoolean detect_language$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("detect_language"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool detect_language
     * }
     */
    public static final OfBoolean detect_language$layout() {
        return detect_language$LAYOUT;
    }

    private static final long detect_language$OFFSET = $LAYOUT.byteOffset(groupElement("detect_language"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool detect_language
     * }
     */
    public static final long detect_language$offset() {
        return detect_language$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool detect_language
     * }
     */
    public static boolean detect_language(MemorySegment struct) {
        return struct.get(detect_language$LAYOUT, detect_language$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool detect_language
     * }
     */
    public static void detect_language(MemorySegment struct, boolean fieldValue) {
        struct.set(detect_language$LAYOUT, detect_language$OFFSET, fieldValue);
    }

    private static final OfBoolean suppress_blank$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("suppress_blank"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool suppress_blank
     * }
     */
    public static final OfBoolean suppress_blank$layout() {
        return suppress_blank$LAYOUT;
    }

    private static final long suppress_blank$OFFSET = $LAYOUT.byteOffset(groupElement("suppress_blank"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool suppress_blank
     * }
     */
    public static final long suppress_blank$offset() {
        return suppress_blank$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool suppress_blank
     * }
     */
    public static boolean suppress_blank(MemorySegment struct) {
        return struct.get(suppress_blank$LAYOUT, suppress_blank$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool suppress_blank
     * }
     */
    public static void suppress_blank(MemorySegment struct, boolean fieldValue) {
        struct.set(suppress_blank$LAYOUT, suppress_blank$OFFSET, fieldValue);
    }

    private static final OfBoolean suppress_nst$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("suppress_nst"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool suppress_nst
     * }
     */
    public static final OfBoolean suppress_nst$layout() {
        return suppress_nst$LAYOUT;
    }

    private static final long suppress_nst$OFFSET = $LAYOUT.byteOffset(groupElement("suppress_nst"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool suppress_nst
     * }
     */
    public static final long suppress_nst$offset() {
        return suppress_nst$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool suppress_nst
     * }
     */
    public static boolean suppress_nst(MemorySegment struct) {
        return struct.get(suppress_nst$LAYOUT, suppress_nst$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool suppress_nst
     * }
     */
    public static void suppress_nst(MemorySegment struct, boolean fieldValue) {
        struct.set(suppress_nst$LAYOUT, suppress_nst$OFFSET, fieldValue);
    }

    private static final OfFloat temperature$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("temperature"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float temperature
     * }
     */
    public static final OfFloat temperature$layout() {
        return temperature$LAYOUT;
    }

    private static final long temperature$OFFSET = $LAYOUT.byteOffset(groupElement("temperature"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float temperature
     * }
     */
    public static final long temperature$offset() {
        return temperature$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float temperature
     * }
     */
    public static float temperature(MemorySegment struct) {
        return struct.get(temperature$LAYOUT, temperature$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float temperature
     * }
     */
    public static void temperature(MemorySegment struct, float fieldValue) {
        struct.set(temperature$LAYOUT, temperature$OFFSET, fieldValue);
    }

    private static final OfFloat max_initial_ts$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("max_initial_ts"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float max_initial_ts
     * }
     */
    public static final OfFloat max_initial_ts$layout() {
        return max_initial_ts$LAYOUT;
    }

    private static final long max_initial_ts$OFFSET = $LAYOUT.byteOffset(groupElement("max_initial_ts"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float max_initial_ts
     * }
     */
    public static final long max_initial_ts$offset() {
        return max_initial_ts$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float max_initial_ts
     * }
     */
    public static float max_initial_ts(MemorySegment struct) {
        return struct.get(max_initial_ts$LAYOUT, max_initial_ts$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float max_initial_ts
     * }
     */
    public static void max_initial_ts(MemorySegment struct, float fieldValue) {
        struct.set(max_initial_ts$LAYOUT, max_initial_ts$OFFSET, fieldValue);
    }

    private static final OfFloat length_penalty$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("length_penalty"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float length_penalty
     * }
     */
    public static final OfFloat length_penalty$layout() {
        return length_penalty$LAYOUT;
    }

    private static final long length_penalty$OFFSET = $LAYOUT.byteOffset(groupElement("length_penalty"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float length_penalty
     * }
     */
    public static final long length_penalty$offset() {
        return length_penalty$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float length_penalty
     * }
     */
    public static float length_penalty(MemorySegment struct) {
        return struct.get(length_penalty$LAYOUT, length_penalty$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float length_penalty
     * }
     */
    public static void length_penalty(MemorySegment struct, float fieldValue) {
        struct.set(length_penalty$LAYOUT, length_penalty$OFFSET, fieldValue);
    }

    private static final OfFloat temperature_inc$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("temperature_inc"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float temperature_inc
     * }
     */
    public static final OfFloat temperature_inc$layout() {
        return temperature_inc$LAYOUT;
    }

    private static final long temperature_inc$OFFSET = $LAYOUT.byteOffset(groupElement("temperature_inc"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float temperature_inc
     * }
     */
    public static final long temperature_inc$offset() {
        return temperature_inc$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float temperature_inc
     * }
     */
    public static float temperature_inc(MemorySegment struct) {
        return struct.get(temperature_inc$LAYOUT, temperature_inc$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float temperature_inc
     * }
     */
    public static void temperature_inc(MemorySegment struct, float fieldValue) {
        struct.set(temperature_inc$LAYOUT, temperature_inc$OFFSET, fieldValue);
    }

    private static final OfFloat entropy_thold$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("entropy_thold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float entropy_thold
     * }
     */
    public static final OfFloat entropy_thold$layout() {
        return entropy_thold$LAYOUT;
    }

    private static final long entropy_thold$OFFSET = $LAYOUT.byteOffset(groupElement("entropy_thold"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float entropy_thold
     * }
     */
    public static final long entropy_thold$offset() {
        return entropy_thold$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float entropy_thold
     * }
     */
    public static float entropy_thold(MemorySegment struct) {
        return struct.get(entropy_thold$LAYOUT, entropy_thold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float entropy_thold
     * }
     */
    public static void entropy_thold(MemorySegment struct, float fieldValue) {
        struct.set(entropy_thold$LAYOUT, entropy_thold$OFFSET, fieldValue);
    }

    private static final OfFloat logprob_thold$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("logprob_thold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float logprob_thold
     * }
     */
    public static final OfFloat logprob_thold$layout() {
        return logprob_thold$LAYOUT;
    }

    private static final long logprob_thold$OFFSET = $LAYOUT.byteOffset(groupElement("logprob_thold"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float logprob_thold
     * }
     */
    public static final long logprob_thold$offset() {
        return logprob_thold$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float logprob_thold
     * }
     */
    public static float logprob_thold(MemorySegment struct) {
        return struct.get(logprob_thold$LAYOUT, logprob_thold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float logprob_thold
     * }
     */
    public static void logprob_thold(MemorySegment struct, float fieldValue) {
        struct.set(logprob_thold$LAYOUT, logprob_thold$OFFSET, fieldValue);
    }

    private static final OfFloat no_speech_thold$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("no_speech_thold"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float no_speech_thold
     * }
     */
    public static final OfFloat no_speech_thold$layout() {
        return no_speech_thold$LAYOUT;
    }

    private static final long no_speech_thold$OFFSET = $LAYOUT.byteOffset(groupElement("no_speech_thold"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float no_speech_thold
     * }
     */
    public static final long no_speech_thold$offset() {
        return no_speech_thold$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float no_speech_thold
     * }
     */
    public static float no_speech_thold(MemorySegment struct) {
        return struct.get(no_speech_thold$LAYOUT, no_speech_thold$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float no_speech_thold
     * }
     */
    public static void no_speech_thold(MemorySegment struct, float fieldValue) {
        struct.set(no_speech_thold$LAYOUT, no_speech_thold$OFFSET, fieldValue);
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     int best_of;
     * }
     * }
     */
    public static class greedy {

        greedy() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            whisper_h.C_INT.withName("best_of")
        ).withName("$anon$551:9");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt best_of$LAYOUT = (OfInt)$LAYOUT.select(groupElement("best_of"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int best_of
         * }
         */
        public static final OfInt best_of$layout() {
            return best_of$LAYOUT;
        }

        private static final long best_of$OFFSET = $LAYOUT.byteOffset(groupElement("best_of"));

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int best_of
         * }
         */
        public static final long best_of$offset() {
            return best_of$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int best_of
         * }
         */
        public static int best_of(MemorySegment struct) {
            return struct.get(best_of$LAYOUT, best_of$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int best_of
         * }
         */
        public static void best_of(MemorySegment struct, int fieldValue) {
            struct.set(best_of$LAYOUT, best_of$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout greedy$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("greedy"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     int best_of;
     * } greedy
     * }
     */
    public static final GroupLayout greedy$layout() {
        return greedy$LAYOUT;
    }

    private static final long greedy$OFFSET = $LAYOUT.byteOffset(groupElement("greedy"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     int best_of;
     * } greedy
     * }
     */
    public static final long greedy$offset() {
        return greedy$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     int best_of;
     * } greedy
     * }
     */
    public static MemorySegment greedy(MemorySegment struct) {
        return struct.asSlice(greedy$OFFSET, greedy$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     int best_of;
     * } greedy
     * }
     */
    public static void greedy(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, greedy$OFFSET, greedy$LAYOUT.byteSize());
    }

    /**
     * {@snippet lang=c :
     * struct {
     *     int beam_size;
     *     float patience;
     * }
     * }
     */
    public static class beam_search {

        beam_search() {
            // Should not be called directly
        }

        private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
            whisper_h.C_INT.withName("beam_size"),
            whisper_h.C_FLOAT.withName("patience")
        ).withName("$anon$555:9");

        /**
         * The layout of this struct
         */
        public static final GroupLayout layout() {
            return $LAYOUT;
        }

        private static final OfInt beam_size$LAYOUT = (OfInt)$LAYOUT.select(groupElement("beam_size"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * int beam_size
         * }
         */
        public static final OfInt beam_size$layout() {
            return beam_size$LAYOUT;
        }

        private static final long beam_size$OFFSET = $LAYOUT.byteOffset(groupElement("beam_size"));

        /**
         * Offset for field:
         * {@snippet lang=c :
         * int beam_size
         * }
         */
        public static final long beam_size$offset() {
            return beam_size$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * int beam_size
         * }
         */
        public static int beam_size(MemorySegment struct) {
            return struct.get(beam_size$LAYOUT, beam_size$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * int beam_size
         * }
         */
        public static void beam_size(MemorySegment struct, int fieldValue) {
            struct.set(beam_size$LAYOUT, beam_size$OFFSET, fieldValue);
        }

        private static final OfFloat patience$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("patience"));

        /**
         * Layout for field:
         * {@snippet lang=c :
         * float patience
         * }
         */
        public static final OfFloat patience$layout() {
            return patience$LAYOUT;
        }

        private static final long patience$OFFSET = $LAYOUT.byteOffset(groupElement("patience"));

        /**
         * Offset for field:
         * {@snippet lang=c :
         * float patience
         * }
         */
        public static final long patience$offset() {
            return patience$OFFSET;
        }

        /**
         * Getter for field:
         * {@snippet lang=c :
         * float patience
         * }
         */
        public static float patience(MemorySegment struct) {
            return struct.get(patience$LAYOUT, patience$OFFSET);
        }

        /**
         * Setter for field:
         * {@snippet lang=c :
         * float patience
         * }
         */
        public static void patience(MemorySegment struct, float fieldValue) {
            struct.set(patience$LAYOUT, patience$OFFSET, fieldValue);
        }

        /**
         * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
         * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
         */
        public static MemorySegment asSlice(MemorySegment array, long index) {
            return array.asSlice(layout().byteSize() * index);
        }

        /**
         * The size (in bytes) of this struct
         */
        public static long sizeof() { return layout().byteSize(); }

        /**
         * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
         */
        public static MemorySegment allocate(SegmentAllocator allocator) {
            return allocator.allocate(layout());
        }

        /**
         * Allocate an array of size {@code elementCount} using {@code allocator}.
         * The returned segment has size {@code elementCount * layout().byteSize()}.
         */
        public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
            return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
            return reinterpret(addr, 1, arena, cleanup);
        }

        /**
         * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
         * The returned segment has size {@code elementCount * layout().byteSize()}
         */
        public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
            return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
        }
    }

    private static final GroupLayout beam_search$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("beam_search"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct {
     *     int beam_size;
     *     float patience;
     * } beam_search
     * }
     */
    public static final GroupLayout beam_search$layout() {
        return beam_search$LAYOUT;
    }

    private static final long beam_search$OFFSET = $LAYOUT.byteOffset(groupElement("beam_search"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct {
     *     int beam_size;
     *     float patience;
     * } beam_search
     * }
     */
    public static final long beam_search$offset() {
        return beam_search$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct {
     *     int beam_size;
     *     float patience;
     * } beam_search
     * }
     */
    public static MemorySegment beam_search(MemorySegment struct) {
        return struct.asSlice(beam_search$OFFSET, beam_search$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct {
     *     int beam_size;
     *     float patience;
     * } beam_search
     * }
     */
    public static void beam_search(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, beam_search$OFFSET, beam_search$LAYOUT.byteSize());
    }

    private static final AddressLayout new_segment_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("new_segment_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * whisper_new_segment_callback new_segment_callback
     * }
     */
    public static final AddressLayout new_segment_callback$layout() {
        return new_segment_callback$LAYOUT;
    }

    private static final long new_segment_callback$OFFSET = $LAYOUT.byteOffset(groupElement("new_segment_callback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * whisper_new_segment_callback new_segment_callback
     * }
     */
    public static final long new_segment_callback$offset() {
        return new_segment_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * whisper_new_segment_callback new_segment_callback
     * }
     */
    public static MemorySegment new_segment_callback(MemorySegment struct) {
        return struct.get(new_segment_callback$LAYOUT, new_segment_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * whisper_new_segment_callback new_segment_callback
     * }
     */
    public static void new_segment_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(new_segment_callback$LAYOUT, new_segment_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout new_segment_callback_user_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("new_segment_callback_user_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *new_segment_callback_user_data
     * }
     */
    public static final AddressLayout new_segment_callback_user_data$layout() {
        return new_segment_callback_user_data$LAYOUT;
    }

    private static final long new_segment_callback_user_data$OFFSET = $LAYOUT.byteOffset(groupElement("new_segment_callback_user_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *new_segment_callback_user_data
     * }
     */
    public static final long new_segment_callback_user_data$offset() {
        return new_segment_callback_user_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *new_segment_callback_user_data
     * }
     */
    public static MemorySegment new_segment_callback_user_data(MemorySegment struct) {
        return struct.get(new_segment_callback_user_data$LAYOUT, new_segment_callback_user_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *new_segment_callback_user_data
     * }
     */
    public static void new_segment_callback_user_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(new_segment_callback_user_data$LAYOUT, new_segment_callback_user_data$OFFSET, fieldValue);
    }

    private static final AddressLayout progress_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("progress_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * whisper_progress_callback progress_callback
     * }
     */
    public static final AddressLayout progress_callback$layout() {
        return progress_callback$LAYOUT;
    }

    private static final long progress_callback$OFFSET = $LAYOUT.byteOffset(groupElement("progress_callback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * whisper_progress_callback progress_callback
     * }
     */
    public static final long progress_callback$offset() {
        return progress_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * whisper_progress_callback progress_callback
     * }
     */
    public static MemorySegment progress_callback(MemorySegment struct) {
        return struct.get(progress_callback$LAYOUT, progress_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * whisper_progress_callback progress_callback
     * }
     */
    public static void progress_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(progress_callback$LAYOUT, progress_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout progress_callback_user_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("progress_callback_user_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *progress_callback_user_data
     * }
     */
    public static final AddressLayout progress_callback_user_data$layout() {
        return progress_callback_user_data$LAYOUT;
    }

    private static final long progress_callback_user_data$OFFSET = $LAYOUT.byteOffset(groupElement("progress_callback_user_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *progress_callback_user_data
     * }
     */
    public static final long progress_callback_user_data$offset() {
        return progress_callback_user_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *progress_callback_user_data
     * }
     */
    public static MemorySegment progress_callback_user_data(MemorySegment struct) {
        return struct.get(progress_callback_user_data$LAYOUT, progress_callback_user_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *progress_callback_user_data
     * }
     */
    public static void progress_callback_user_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(progress_callback_user_data$LAYOUT, progress_callback_user_data$OFFSET, fieldValue);
    }

    private static final AddressLayout encoder_begin_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("encoder_begin_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * whisper_encoder_begin_callback encoder_begin_callback
     * }
     */
    public static final AddressLayout encoder_begin_callback$layout() {
        return encoder_begin_callback$LAYOUT;
    }

    private static final long encoder_begin_callback$OFFSET = $LAYOUT.byteOffset(groupElement("encoder_begin_callback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * whisper_encoder_begin_callback encoder_begin_callback
     * }
     */
    public static final long encoder_begin_callback$offset() {
        return encoder_begin_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * whisper_encoder_begin_callback encoder_begin_callback
     * }
     */
    public static MemorySegment encoder_begin_callback(MemorySegment struct) {
        return struct.get(encoder_begin_callback$LAYOUT, encoder_begin_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * whisper_encoder_begin_callback encoder_begin_callback
     * }
     */
    public static void encoder_begin_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(encoder_begin_callback$LAYOUT, encoder_begin_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout encoder_begin_callback_user_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("encoder_begin_callback_user_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *encoder_begin_callback_user_data
     * }
     */
    public static final AddressLayout encoder_begin_callback_user_data$layout() {
        return encoder_begin_callback_user_data$LAYOUT;
    }

    private static final long encoder_begin_callback_user_data$OFFSET = $LAYOUT.byteOffset(groupElement("encoder_begin_callback_user_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *encoder_begin_callback_user_data
     * }
     */
    public static final long encoder_begin_callback_user_data$offset() {
        return encoder_begin_callback_user_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *encoder_begin_callback_user_data
     * }
     */
    public static MemorySegment encoder_begin_callback_user_data(MemorySegment struct) {
        return struct.get(encoder_begin_callback_user_data$LAYOUT, encoder_begin_callback_user_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *encoder_begin_callback_user_data
     * }
     */
    public static void encoder_begin_callback_user_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(encoder_begin_callback_user_data$LAYOUT, encoder_begin_callback_user_data$OFFSET, fieldValue);
    }

    private static final AddressLayout abort_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("abort_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static final AddressLayout abort_callback$layout() {
        return abort_callback$LAYOUT;
    }

    private static final long abort_callback$OFFSET = $LAYOUT.byteOffset(groupElement("abort_callback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static final long abort_callback$offset() {
        return abort_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static MemorySegment abort_callback(MemorySegment struct) {
        return struct.get(abort_callback$LAYOUT, abort_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ggml_abort_callback abort_callback
     * }
     */
    public static void abort_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(abort_callback$LAYOUT, abort_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout abort_callback_user_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("abort_callback_user_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *abort_callback_user_data
     * }
     */
    public static final AddressLayout abort_callback_user_data$layout() {
        return abort_callback_user_data$LAYOUT;
    }

    private static final long abort_callback_user_data$OFFSET = $LAYOUT.byteOffset(groupElement("abort_callback_user_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *abort_callback_user_data
     * }
     */
    public static final long abort_callback_user_data$offset() {
        return abort_callback_user_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *abort_callback_user_data
     * }
     */
    public static MemorySegment abort_callback_user_data(MemorySegment struct) {
        return struct.get(abort_callback_user_data$LAYOUT, abort_callback_user_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *abort_callback_user_data
     * }
     */
    public static void abort_callback_user_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(abort_callback_user_data$LAYOUT, abort_callback_user_data$OFFSET, fieldValue);
    }

    private static final AddressLayout logits_filter_callback$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("logits_filter_callback"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * whisper_logits_filter_callback logits_filter_callback
     * }
     */
    public static final AddressLayout logits_filter_callback$layout() {
        return logits_filter_callback$LAYOUT;
    }

    private static final long logits_filter_callback$OFFSET = $LAYOUT.byteOffset(groupElement("logits_filter_callback"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * whisper_logits_filter_callback logits_filter_callback
     * }
     */
    public static final long logits_filter_callback$offset() {
        return logits_filter_callback$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * whisper_logits_filter_callback logits_filter_callback
     * }
     */
    public static MemorySegment logits_filter_callback(MemorySegment struct) {
        return struct.get(logits_filter_callback$LAYOUT, logits_filter_callback$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * whisper_logits_filter_callback logits_filter_callback
     * }
     */
    public static void logits_filter_callback(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(logits_filter_callback$LAYOUT, logits_filter_callback$OFFSET, fieldValue);
    }

    private static final AddressLayout logits_filter_callback_user_data$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("logits_filter_callback_user_data"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * void *logits_filter_callback_user_data
     * }
     */
    public static final AddressLayout logits_filter_callback_user_data$layout() {
        return logits_filter_callback_user_data$LAYOUT;
    }

    private static final long logits_filter_callback_user_data$OFFSET = $LAYOUT.byteOffset(groupElement("logits_filter_callback_user_data"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * void *logits_filter_callback_user_data
     * }
     */
    public static final long logits_filter_callback_user_data$offset() {
        return logits_filter_callback_user_data$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * void *logits_filter_callback_user_data
     * }
     */
    public static MemorySegment logits_filter_callback_user_data(MemorySegment struct) {
        return struct.get(logits_filter_callback_user_data$LAYOUT, logits_filter_callback_user_data$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * void *logits_filter_callback_user_data
     * }
     */
    public static void logits_filter_callback_user_data(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(logits_filter_callback_user_data$LAYOUT, logits_filter_callback_user_data$OFFSET, fieldValue);
    }

    private static final AddressLayout grammar_rules$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("grammar_rules"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const whisper_grammar_element **grammar_rules
     * }
     */
    public static final AddressLayout grammar_rules$layout() {
        return grammar_rules$LAYOUT;
    }

    private static final long grammar_rules$OFFSET = $LAYOUT.byteOffset(groupElement("grammar_rules"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const whisper_grammar_element **grammar_rules
     * }
     */
    public static final long grammar_rules$offset() {
        return grammar_rules$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const whisper_grammar_element **grammar_rules
     * }
     */
    public static MemorySegment grammar_rules(MemorySegment struct) {
        return struct.get(grammar_rules$LAYOUT, grammar_rules$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const whisper_grammar_element **grammar_rules
     * }
     */
    public static void grammar_rules(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(grammar_rules$LAYOUT, grammar_rules$OFFSET, fieldValue);
    }

    private static final OfLong n_grammar_rules$LAYOUT = (OfLong)$LAYOUT.select(groupElement("n_grammar_rules"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t n_grammar_rules
     * }
     */
    public static final OfLong n_grammar_rules$layout() {
        return n_grammar_rules$LAYOUT;
    }

    private static final long n_grammar_rules$OFFSET = $LAYOUT.byteOffset(groupElement("n_grammar_rules"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t n_grammar_rules
     * }
     */
    public static final long n_grammar_rules$offset() {
        return n_grammar_rules$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t n_grammar_rules
     * }
     */
    public static long n_grammar_rules(MemorySegment struct) {
        return struct.get(n_grammar_rules$LAYOUT, n_grammar_rules$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t n_grammar_rules
     * }
     */
    public static void n_grammar_rules(MemorySegment struct, long fieldValue) {
        struct.set(n_grammar_rules$LAYOUT, n_grammar_rules$OFFSET, fieldValue);
    }

    private static final OfLong i_start_rule$LAYOUT = (OfLong)$LAYOUT.select(groupElement("i_start_rule"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * size_t i_start_rule
     * }
     */
    public static final OfLong i_start_rule$layout() {
        return i_start_rule$LAYOUT;
    }

    private static final long i_start_rule$OFFSET = $LAYOUT.byteOffset(groupElement("i_start_rule"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * size_t i_start_rule
     * }
     */
    public static final long i_start_rule$offset() {
        return i_start_rule$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * size_t i_start_rule
     * }
     */
    public static long i_start_rule(MemorySegment struct) {
        return struct.get(i_start_rule$LAYOUT, i_start_rule$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * size_t i_start_rule
     * }
     */
    public static void i_start_rule(MemorySegment struct, long fieldValue) {
        struct.set(i_start_rule$LAYOUT, i_start_rule$OFFSET, fieldValue);
    }

    private static final OfFloat grammar_penalty$LAYOUT = (OfFloat)$LAYOUT.select(groupElement("grammar_penalty"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * float grammar_penalty
     * }
     */
    public static final OfFloat grammar_penalty$layout() {
        return grammar_penalty$LAYOUT;
    }

    private static final long grammar_penalty$OFFSET = $LAYOUT.byteOffset(groupElement("grammar_penalty"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * float grammar_penalty
     * }
     */
    public static final long grammar_penalty$offset() {
        return grammar_penalty$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * float grammar_penalty
     * }
     */
    public static float grammar_penalty(MemorySegment struct) {
        return struct.get(grammar_penalty$LAYOUT, grammar_penalty$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * float grammar_penalty
     * }
     */
    public static void grammar_penalty(MemorySegment struct, float fieldValue) {
        struct.set(grammar_penalty$LAYOUT, grammar_penalty$OFFSET, fieldValue);
    }

    private static final OfBoolean vad$LAYOUT = (OfBoolean)$LAYOUT.select(groupElement("vad"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * bool vad
     * }
     */
    public static final OfBoolean vad$layout() {
        return vad$LAYOUT;
    }

    private static final long vad$OFFSET = $LAYOUT.byteOffset(groupElement("vad"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * bool vad
     * }
     */
    public static final long vad$offset() {
        return vad$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * bool vad
     * }
     */
    public static boolean vad(MemorySegment struct) {
        return struct.get(vad$LAYOUT, vad$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * bool vad
     * }
     */
    public static void vad(MemorySegment struct, boolean fieldValue) {
        struct.set(vad$LAYOUT, vad$OFFSET, fieldValue);
    }

    private static final AddressLayout vad_model_path$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("vad_model_path"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const char *vad_model_path
     * }
     */
    public static final AddressLayout vad_model_path$layout() {
        return vad_model_path$LAYOUT;
    }

    private static final long vad_model_path$OFFSET = $LAYOUT.byteOffset(groupElement("vad_model_path"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const char *vad_model_path
     * }
     */
    public static final long vad_model_path$offset() {
        return vad_model_path$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const char *vad_model_path
     * }
     */
    public static MemorySegment vad_model_path(MemorySegment struct) {
        return struct.get(vad_model_path$LAYOUT, vad_model_path$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const char *vad_model_path
     * }
     */
    public static void vad_model_path(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(vad_model_path$LAYOUT, vad_model_path$OFFSET, fieldValue);
    }

    private static final GroupLayout vad_params$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("vad_params"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * whisper_vad_params vad_params
     * }
     */
    public static final GroupLayout vad_params$layout() {
        return vad_params$LAYOUT;
    }

    private static final long vad_params$OFFSET = $LAYOUT.byteOffset(groupElement("vad_params"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * whisper_vad_params vad_params
     * }
     */
    public static final long vad_params$offset() {
        return vad_params$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * whisper_vad_params vad_params
     * }
     */
    public static MemorySegment vad_params(MemorySegment struct) {
        return struct.asSlice(vad_params$OFFSET, vad_params$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * whisper_vad_params vad_params
     * }
     */
    public static void vad_params(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, vad_params$OFFSET, vad_params$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

