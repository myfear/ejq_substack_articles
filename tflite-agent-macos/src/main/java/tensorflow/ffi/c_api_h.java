// Generated by jextract

package tensorflow.ffi;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class c_api_h extends c_api_h_1 {

    c_api_h() {
        // Should not be called directly
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = c_api_h.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int __datlen) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, __datlen);
            }
            mh$.invokeExact(x0, __datlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_INT,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_SHORT,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment x0, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, __nelem);
            }
            return (int)mh$.invokeExact(x0, __nelem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_LONG_LONG,
            c_api_h.C_LONG_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = c_api_h.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = c_api_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = c_api_h.C_INT;

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_INT,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = c_api_h.C_LONG;

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchrnul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul$address() {
        return strchrnul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long __len) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, __len);
            }
            mh$.invokeExact(x0, x1, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", x0, x1, __n);
            }
            return (int)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", x0, x1, __n);
            }
            mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static void bzero(MemorySegment x0, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", x0, __n);
            }
            mh$.invokeExact(x0, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index(MemorySegment x0, int x1) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex(MemorySegment x0, int x1) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static int ffs(int x0) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static int strcasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static int strncasecmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static int ffsl(long x0) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static int ffsll(long x0) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static FunctionDescriptor fls$descriptor() {
        return fls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MethodHandle fls$handle() {
        return fls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MemorySegment fls$address() {
        return fls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static int fls(int x0) {
        var mh$ = fls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static FunctionDescriptor flsl$descriptor() {
        return flsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MethodHandle flsl$handle() {
        return flsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MemorySegment flsl$address() {
        return flsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static int flsl(long x0) {
        var mh$ = flsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static FunctionDescriptor flsll$descriptor() {
        return flsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MethodHandle flsll$handle() {
        return flsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MemorySegment flsll$address() {
        return flsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static int flsll(long x0) {
        var mh$ = flsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int TF_TSTR_SMALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TF_TString_Type.TF_TSTR_SMALL = 0
     * }
     */
    public static int TF_TSTR_SMALL() {
        return TF_TSTR_SMALL;
    }
    private static final int TF_TSTR_LARGE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TF_TString_Type.TF_TSTR_LARGE = 1
     * }
     */
    public static int TF_TSTR_LARGE() {
        return TF_TSTR_LARGE;
    }
    private static final int TF_TSTR_OFFSET = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TF_TString_Type.TF_TSTR_OFFSET = 2
     * }
     */
    public static int TF_TSTR_OFFSET() {
        return TF_TSTR_OFFSET;
    }
    private static final int TF_TSTR_VIEW = (int)3L;
    /**
     * {@snippet lang=c :
     * enum TF_TString_Type.TF_TSTR_VIEW = 3
     * }
     */
    public static int TF_TSTR_VIEW() {
        return TF_TSTR_VIEW;
    }
    private static final int TF_TSTR_TYPE_MASK = (int)3L;
    /**
     * {@snippet lang=c :
     * enum TF_TString_Type.TF_TSTR_TYPE_MASK = 3
     * }
     */
    public static int TF_TSTR_TYPE_MASK() {
        return TF_TSTR_TYPE_MASK;
    }
    private static final int TF_TString_SmallCapacity = (int)22L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.TF_TString_SmallCapacity = 22
     * }
     */
    public static int TF_TString_SmallCapacity() {
        return TF_TString_SmallCapacity;
    }

    private static class TF_StringInit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringInit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_StringInit(TF_TString *t)
     * }
     */
    public static FunctionDescriptor TF_StringInit$descriptor() {
        return TF_StringInit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_StringInit(TF_TString *t)
     * }
     */
    public static MethodHandle TF_StringInit$handle() {
        return TF_StringInit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_StringInit(TF_TString *t)
     * }
     */
    public static MemorySegment TF_StringInit$address() {
        return TF_StringInit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_StringInit(TF_TString *t)
     * }
     */
    public static void TF_StringInit(MemorySegment t) {
        var mh$ = TF_StringInit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringInit", t);
            }
            mh$.invokeExact(t);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_StringCopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringCopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_StringCopy(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static FunctionDescriptor TF_StringCopy$descriptor() {
        return TF_StringCopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_StringCopy(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static MethodHandle TF_StringCopy$handle() {
        return TF_StringCopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_StringCopy(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static MemorySegment TF_StringCopy$address() {
        return TF_StringCopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_StringCopy(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static void TF_StringCopy(MemorySegment dst, MemorySegment src, long size) {
        var mh$ = TF_StringCopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringCopy", dst, src, size);
            }
            mh$.invokeExact(dst, src, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_StringAssignView {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringAssignView");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_StringAssignView(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static FunctionDescriptor TF_StringAssignView$descriptor() {
        return TF_StringAssignView.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_StringAssignView(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static MethodHandle TF_StringAssignView$handle() {
        return TF_StringAssignView.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_StringAssignView(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static MemorySegment TF_StringAssignView$address() {
        return TF_StringAssignView.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_StringAssignView(TF_TString *dst, const char *src, size_t size)
     * }
     */
    public static void TF_StringAssignView(MemorySegment dst, MemorySegment src, long size) {
        var mh$ = TF_StringAssignView.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringAssignView", dst, src, size);
            }
            mh$.invokeExact(dst, src, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_StringGetDataPointer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringGetDataPointer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_StringGetDataPointer(const TF_TString *tstr)
     * }
     */
    public static FunctionDescriptor TF_StringGetDataPointer$descriptor() {
        return TF_StringGetDataPointer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_StringGetDataPointer(const TF_TString *tstr)
     * }
     */
    public static MethodHandle TF_StringGetDataPointer$handle() {
        return TF_StringGetDataPointer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_StringGetDataPointer(const TF_TString *tstr)
     * }
     */
    public static MemorySegment TF_StringGetDataPointer$address() {
        return TF_StringGetDataPointer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_StringGetDataPointer(const TF_TString *tstr)
     * }
     */
    public static MemorySegment TF_StringGetDataPointer(MemorySegment tstr) {
        var mh$ = TF_StringGetDataPointer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringGetDataPointer", tstr);
            }
            return (MemorySegment)mh$.invokeExact(tstr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_StringGetType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringGetType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_TString_Type TF_StringGetType(const TF_TString *str)
     * }
     */
    public static FunctionDescriptor TF_StringGetType$descriptor() {
        return TF_StringGetType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_TString_Type TF_StringGetType(const TF_TString *str)
     * }
     */
    public static MethodHandle TF_StringGetType$handle() {
        return TF_StringGetType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_TString_Type TF_StringGetType(const TF_TString *str)
     * }
     */
    public static MemorySegment TF_StringGetType$address() {
        return TF_StringGetType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_TString_Type TF_StringGetType(const TF_TString *str)
     * }
     */
    public static int TF_StringGetType(MemorySegment str) {
        var mh$ = TF_StringGetType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringGetType", str);
            }
            return (int)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_StringGetSize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringGetSize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t TF_StringGetSize(const TF_TString *tstr)
     * }
     */
    public static FunctionDescriptor TF_StringGetSize$descriptor() {
        return TF_StringGetSize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t TF_StringGetSize(const TF_TString *tstr)
     * }
     */
    public static MethodHandle TF_StringGetSize$handle() {
        return TF_StringGetSize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t TF_StringGetSize(const TF_TString *tstr)
     * }
     */
    public static MemorySegment TF_StringGetSize$address() {
        return TF_StringGetSize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t TF_StringGetSize(const TF_TString *tstr)
     * }
     */
    public static long TF_StringGetSize(MemorySegment tstr) {
        var mh$ = TF_StringGetSize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringGetSize", tstr);
            }
            return (long)mh$.invokeExact(tstr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_StringGetCapacity {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringGetCapacity");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t TF_StringGetCapacity(const TF_TString *str)
     * }
     */
    public static FunctionDescriptor TF_StringGetCapacity$descriptor() {
        return TF_StringGetCapacity.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t TF_StringGetCapacity(const TF_TString *str)
     * }
     */
    public static MethodHandle TF_StringGetCapacity$handle() {
        return TF_StringGetCapacity.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t TF_StringGetCapacity(const TF_TString *str)
     * }
     */
    public static MemorySegment TF_StringGetCapacity$address() {
        return TF_StringGetCapacity.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t TF_StringGetCapacity(const TF_TString *str)
     * }
     */
    public static long TF_StringGetCapacity(MemorySegment str) {
        var mh$ = TF_StringGetCapacity.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringGetCapacity", str);
            }
            return (long)mh$.invokeExact(str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_StringDealloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_StringDealloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_StringDealloc(TF_TString *tstr)
     * }
     */
    public static FunctionDescriptor TF_StringDealloc$descriptor() {
        return TF_StringDealloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_StringDealloc(TF_TString *tstr)
     * }
     */
    public static MethodHandle TF_StringDealloc$handle() {
        return TF_StringDealloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_StringDealloc(TF_TString *tstr)
     * }
     */
    public static MemorySegment TF_StringDealloc$address() {
        return TF_StringDealloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_StringDealloc(TF_TString *tstr)
     * }
     */
    public static void TF_StringDealloc(MemorySegment tstr) {
        var mh$ = TF_StringDealloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_StringDealloc", tstr);
            }
            mh$.invokeExact(tstr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_Version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_Version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_Version()
     * }
     */
    public static FunctionDescriptor TF_Version$descriptor() {
        return TF_Version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_Version()
     * }
     */
    public static MethodHandle TF_Version$handle() {
        return TF_Version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_Version()
     * }
     */
    public static MemorySegment TF_Version$address() {
        return TF_Version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_Version()
     * }
     */
    public static MemorySegment TF_Version() {
        var mh$ = TF_Version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_Version");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_TensorFromProto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_TensorFromProto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_TensorFromProto(const TF_Buffer *from, TF_Tensor *to, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_TensorFromProto$descriptor() {
        return TF_TensorFromProto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_TensorFromProto(const TF_Buffer *from, TF_Tensor *to, TF_Status *status)
     * }
     */
    public static MethodHandle TF_TensorFromProto$handle() {
        return TF_TensorFromProto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_TensorFromProto(const TF_Buffer *from, TF_Tensor *to, TF_Status *status)
     * }
     */
    public static MemorySegment TF_TensorFromProto$address() {
        return TF_TensorFromProto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_TensorFromProto(const TF_Buffer *from, TF_Tensor *to, TF_Status *status)
     * }
     */
    public static void TF_TensorFromProto(MemorySegment from, MemorySegment to, MemorySegment status) {
        var mh$ = TF_TensorFromProto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_TensorFromProto", from, to, status);
            }
            mh$.invokeExact(from, to, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewSessionOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewSessionOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_SessionOptions *TF_NewSessionOptions()
     * }
     */
    public static FunctionDescriptor TF_NewSessionOptions$descriptor() {
        return TF_NewSessionOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_SessionOptions *TF_NewSessionOptions()
     * }
     */
    public static MethodHandle TF_NewSessionOptions$handle() {
        return TF_NewSessionOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_SessionOptions *TF_NewSessionOptions()
     * }
     */
    public static MemorySegment TF_NewSessionOptions$address() {
        return TF_NewSessionOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_SessionOptions *TF_NewSessionOptions()
     * }
     */
    public static MemorySegment TF_NewSessionOptions() {
        var mh$ = TF_NewSessionOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewSessionOptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetTarget(TF_SessionOptions *options, const char *target)
     * }
     */
    public static FunctionDescriptor TF_SetTarget$descriptor() {
        return TF_SetTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetTarget(TF_SessionOptions *options, const char *target)
     * }
     */
    public static MethodHandle TF_SetTarget$handle() {
        return TF_SetTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetTarget(TF_SessionOptions *options, const char *target)
     * }
     */
    public static MemorySegment TF_SetTarget$address() {
        return TF_SetTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetTarget(TF_SessionOptions *options, const char *target)
     * }
     */
    public static void TF_SetTarget(MemorySegment options, MemorySegment target) {
        var mh$ = TF_SetTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetTarget", options, target);
            }
            mh$.invokeExact(options, target);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetConfig {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetConfig");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetConfig(TF_SessionOptions *options, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_SetConfig$descriptor() {
        return TF_SetConfig.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetConfig(TF_SessionOptions *options, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_SetConfig$handle() {
        return TF_SetConfig.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetConfig(TF_SessionOptions *options, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SetConfig$address() {
        return TF_SetConfig.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetConfig(TF_SessionOptions *options, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static void TF_SetConfig(MemorySegment options, MemorySegment proto, long proto_len, MemorySegment status) {
        var mh$ = TF_SetConfig.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetConfig", options, proto, proto_len, status);
            }
            mh$.invokeExact(options, proto, proto_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteSessionOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteSessionOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteSessionOptions(TF_SessionOptions *)
     * }
     */
    public static FunctionDescriptor TF_DeleteSessionOptions$descriptor() {
        return TF_DeleteSessionOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteSessionOptions(TF_SessionOptions *)
     * }
     */
    public static MethodHandle TF_DeleteSessionOptions$handle() {
        return TF_DeleteSessionOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteSessionOptions(TF_SessionOptions *)
     * }
     */
    public static MemorySegment TF_DeleteSessionOptions$address() {
        return TF_DeleteSessionOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteSessionOptions(TF_SessionOptions *)
     * }
     */
    public static void TF_DeleteSessionOptions(MemorySegment x0) {
        var mh$ = TF_DeleteSessionOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteSessionOptions", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Graph *TF_NewGraph()
     * }
     */
    public static FunctionDescriptor TF_NewGraph$descriptor() {
        return TF_NewGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Graph *TF_NewGraph()
     * }
     */
    public static MethodHandle TF_NewGraph$handle() {
        return TF_NewGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Graph *TF_NewGraph()
     * }
     */
    public static MemorySegment TF_NewGraph$address() {
        return TF_NewGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Graph *TF_NewGraph()
     * }
     */
    public static MemorySegment TF_NewGraph() {
        var mh$ = TF_NewGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewGraph");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteGraph(TF_Graph *)
     * }
     */
    public static FunctionDescriptor TF_DeleteGraph$descriptor() {
        return TF_DeleteGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteGraph(TF_Graph *)
     * }
     */
    public static MethodHandle TF_DeleteGraph$handle() {
        return TF_DeleteGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteGraph(TF_Graph *)
     * }
     */
    public static MemorySegment TF_DeleteGraph$address() {
        return TF_DeleteGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteGraph(TF_Graph *)
     * }
     */
    public static void TF_DeleteGraph(MemorySegment x0) {
        var mh$ = TF_DeleteGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteGraph", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphSetTensorShape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            TF_Output.layout(),
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphSetTensorShape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphSetTensorShape(TF_Graph *graph, TF_Output output, const int64_t *dims, const int num_dims, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphSetTensorShape$descriptor() {
        return TF_GraphSetTensorShape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphSetTensorShape(TF_Graph *graph, TF_Output output, const int64_t *dims, const int num_dims, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphSetTensorShape$handle() {
        return TF_GraphSetTensorShape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphSetTensorShape(TF_Graph *graph, TF_Output output, const int64_t *dims, const int num_dims, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphSetTensorShape$address() {
        return TF_GraphSetTensorShape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphSetTensorShape(TF_Graph *graph, TF_Output output, const int64_t *dims, const int num_dims, TF_Status *status)
     * }
     */
    public static void TF_GraphSetTensorShape(MemorySegment graph, MemorySegment output, MemorySegment dims, int num_dims, MemorySegment status) {
        var mh$ = TF_GraphSetTensorShape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphSetTensorShape", graph, output, dims, num_dims, status);
            }
            mh$.invokeExact(graph, output, dims, num_dims, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphGetTensorNumDims {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            TF_Output.layout(),
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphGetTensorNumDims");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_GraphGetTensorNumDims(TF_Graph *graph, TF_Output output, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphGetTensorNumDims$descriptor() {
        return TF_GraphGetTensorNumDims.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_GraphGetTensorNumDims(TF_Graph *graph, TF_Output output, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphGetTensorNumDims$handle() {
        return TF_GraphGetTensorNumDims.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_GraphGetTensorNumDims(TF_Graph *graph, TF_Output output, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphGetTensorNumDims$address() {
        return TF_GraphGetTensorNumDims.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_GraphGetTensorNumDims(TF_Graph *graph, TF_Output output, TF_Status *status)
     * }
     */
    public static int TF_GraphGetTensorNumDims(MemorySegment graph, MemorySegment output, MemorySegment status) {
        var mh$ = TF_GraphGetTensorNumDims.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphGetTensorNumDims", graph, output, status);
            }
            return (int)mh$.invokeExact(graph, output, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphGetTensorShape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            TF_Output.layout(),
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphGetTensorShape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphGetTensorShape(TF_Graph *graph, TF_Output output, int64_t *dims, int num_dims, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphGetTensorShape$descriptor() {
        return TF_GraphGetTensorShape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphGetTensorShape(TF_Graph *graph, TF_Output output, int64_t *dims, int num_dims, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphGetTensorShape$handle() {
        return TF_GraphGetTensorShape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphGetTensorShape(TF_Graph *graph, TF_Output output, int64_t *dims, int num_dims, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphGetTensorShape$address() {
        return TF_GraphGetTensorShape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphGetTensorShape(TF_Graph *graph, TF_Output output, int64_t *dims, int num_dims, TF_Status *status)
     * }
     */
    public static void TF_GraphGetTensorShape(MemorySegment graph, MemorySegment output, MemorySegment dims, int num_dims, MemorySegment status) {
        var mh$ = TF_GraphGetTensorShape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphGetTensorShape", graph, output, dims, num_dims, status);
            }
            mh$.invokeExact(graph, output, dims, num_dims, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewOperationLocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewOperationLocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperationLocked(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static FunctionDescriptor TF_NewOperationLocked$descriptor() {
        return TF_NewOperationLocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperationLocked(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static MethodHandle TF_NewOperationLocked$handle() {
        return TF_NewOperationLocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperationLocked(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static MemorySegment TF_NewOperationLocked$address() {
        return TF_NewOperationLocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperationLocked(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static MemorySegment TF_NewOperationLocked(MemorySegment graph, MemorySegment op_type, MemorySegment oper_name) {
        var mh$ = TF_NewOperationLocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewOperationLocked", graph, op_type, oper_name);
            }
            return (MemorySegment)mh$.invokeExact(graph, op_type, oper_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewOperation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewOperation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperation(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static FunctionDescriptor TF_NewOperation$descriptor() {
        return TF_NewOperation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperation(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static MethodHandle TF_NewOperation$handle() {
        return TF_NewOperation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperation(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static MemorySegment TF_NewOperation$address() {
        return TF_NewOperation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_OperationDescription *TF_NewOperation(TF_Graph *graph, const char *op_type, const char *oper_name)
     * }
     */
    public static MemorySegment TF_NewOperation(MemorySegment graph, MemorySegment op_type, MemorySegment oper_name) {
        var mh$ = TF_NewOperation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewOperation", graph, op_type, oper_name);
            }
            return (MemorySegment)mh$.invokeExact(graph, op_type, oper_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetDevice(TF_OperationDescription *desc, const char *device)
     * }
     */
    public static FunctionDescriptor TF_SetDevice$descriptor() {
        return TF_SetDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetDevice(TF_OperationDescription *desc, const char *device)
     * }
     */
    public static MethodHandle TF_SetDevice$handle() {
        return TF_SetDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetDevice(TF_OperationDescription *desc, const char *device)
     * }
     */
    public static MemorySegment TF_SetDevice$address() {
        return TF_SetDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetDevice(TF_OperationDescription *desc, const char *device)
     * }
     */
    public static void TF_SetDevice(MemorySegment desc, MemorySegment device) {
        var mh$ = TF_SetDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetDevice", desc, device);
            }
            mh$.invokeExact(desc, device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_AddInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            TF_Output.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_AddInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_AddInput(TF_OperationDescription *desc, TF_Output input)
     * }
     */
    public static FunctionDescriptor TF_AddInput$descriptor() {
        return TF_AddInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_AddInput(TF_OperationDescription *desc, TF_Output input)
     * }
     */
    public static MethodHandle TF_AddInput$handle() {
        return TF_AddInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_AddInput(TF_OperationDescription *desc, TF_Output input)
     * }
     */
    public static MemorySegment TF_AddInput$address() {
        return TF_AddInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_AddInput(TF_OperationDescription *desc, TF_Output input)
     * }
     */
    public static void TF_AddInput(MemorySegment desc, MemorySegment input) {
        var mh$ = TF_AddInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_AddInput", desc, input);
            }
            mh$.invokeExact(desc, input);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_AddInputList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_AddInputList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_AddInputList(TF_OperationDescription *desc, const TF_Output *inputs, int num_inputs)
     * }
     */
    public static FunctionDescriptor TF_AddInputList$descriptor() {
        return TF_AddInputList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_AddInputList(TF_OperationDescription *desc, const TF_Output *inputs, int num_inputs)
     * }
     */
    public static MethodHandle TF_AddInputList$handle() {
        return TF_AddInputList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_AddInputList(TF_OperationDescription *desc, const TF_Output *inputs, int num_inputs)
     * }
     */
    public static MemorySegment TF_AddInputList$address() {
        return TF_AddInputList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_AddInputList(TF_OperationDescription *desc, const TF_Output *inputs, int num_inputs)
     * }
     */
    public static void TF_AddInputList(MemorySegment desc, MemorySegment inputs, int num_inputs) {
        var mh$ = TF_AddInputList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_AddInputList", desc, inputs, num_inputs);
            }
            mh$.invokeExact(desc, inputs, num_inputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_AddControlInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_AddControlInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_AddControlInput(TF_OperationDescription *desc, TF_Operation *input)
     * }
     */
    public static FunctionDescriptor TF_AddControlInput$descriptor() {
        return TF_AddControlInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_AddControlInput(TF_OperationDescription *desc, TF_Operation *input)
     * }
     */
    public static MethodHandle TF_AddControlInput$handle() {
        return TF_AddControlInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_AddControlInput(TF_OperationDescription *desc, TF_Operation *input)
     * }
     */
    public static MemorySegment TF_AddControlInput$address() {
        return TF_AddControlInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_AddControlInput(TF_OperationDescription *desc, TF_Operation *input)
     * }
     */
    public static void TF_AddControlInput(MemorySegment desc, MemorySegment input) {
        var mh$ = TF_AddControlInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_AddControlInput", desc, input);
            }
            mh$.invokeExact(desc, input);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ColocateWith {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ColocateWith");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ColocateWith(TF_OperationDescription *desc, TF_Operation *op)
     * }
     */
    public static FunctionDescriptor TF_ColocateWith$descriptor() {
        return TF_ColocateWith.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ColocateWith(TF_OperationDescription *desc, TF_Operation *op)
     * }
     */
    public static MethodHandle TF_ColocateWith$handle() {
        return TF_ColocateWith.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ColocateWith(TF_OperationDescription *desc, TF_Operation *op)
     * }
     */
    public static MemorySegment TF_ColocateWith$address() {
        return TF_ColocateWith.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ColocateWith(TF_OperationDescription *desc, TF_Operation *op)
     * }
     */
    public static void TF_ColocateWith(MemorySegment desc, MemorySegment op) {
        var mh$ = TF_ColocateWith.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ColocateWith", desc, op);
            }
            mh$.invokeExact(desc, op);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrString(TF_OperationDescription *desc, const char *attr_name, const void *value, size_t length)
     * }
     */
    public static FunctionDescriptor TF_SetAttrString$descriptor() {
        return TF_SetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrString(TF_OperationDescription *desc, const char *attr_name, const void *value, size_t length)
     * }
     */
    public static MethodHandle TF_SetAttrString$handle() {
        return TF_SetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrString(TF_OperationDescription *desc, const char *attr_name, const void *value, size_t length)
     * }
     */
    public static MemorySegment TF_SetAttrString$address() {
        return TF_SetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrString(TF_OperationDescription *desc, const char *attr_name, const void *value, size_t length)
     * }
     */
    public static void TF_SetAttrString(MemorySegment desc, MemorySegment attr_name, MemorySegment value, long length) {
        var mh$ = TF_SetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrString", desc, attr_name, value, length);
            }
            mh$.invokeExact(desc, attr_name, value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrStringList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrStringList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrStringList(TF_OperationDescription *desc, const char *attr_name, const void *const *values, const size_t *lengths, int num_values)
     * }
     */
    public static FunctionDescriptor TF_SetAttrStringList$descriptor() {
        return TF_SetAttrStringList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrStringList(TF_OperationDescription *desc, const char *attr_name, const void *const *values, const size_t *lengths, int num_values)
     * }
     */
    public static MethodHandle TF_SetAttrStringList$handle() {
        return TF_SetAttrStringList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrStringList(TF_OperationDescription *desc, const char *attr_name, const void *const *values, const size_t *lengths, int num_values)
     * }
     */
    public static MemorySegment TF_SetAttrStringList$address() {
        return TF_SetAttrStringList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrStringList(TF_OperationDescription *desc, const char *attr_name, const void *const *values, const size_t *lengths, int num_values)
     * }
     */
    public static void TF_SetAttrStringList(MemorySegment desc, MemorySegment attr_name, MemorySegment values, MemorySegment lengths, int num_values) {
        var mh$ = TF_SetAttrStringList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrStringList", desc, attr_name, values, lengths, num_values);
            }
            mh$.invokeExact(desc, attr_name, values, lengths, num_values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrInt(TF_OperationDescription *desc, const char *attr_name, int64_t value)
     * }
     */
    public static FunctionDescriptor TF_SetAttrInt$descriptor() {
        return TF_SetAttrInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrInt(TF_OperationDescription *desc, const char *attr_name, int64_t value)
     * }
     */
    public static MethodHandle TF_SetAttrInt$handle() {
        return TF_SetAttrInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrInt(TF_OperationDescription *desc, const char *attr_name, int64_t value)
     * }
     */
    public static MemorySegment TF_SetAttrInt$address() {
        return TF_SetAttrInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrInt(TF_OperationDescription *desc, const char *attr_name, int64_t value)
     * }
     */
    public static void TF_SetAttrInt(MemorySegment desc, MemorySegment attr_name, long value) {
        var mh$ = TF_SetAttrInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrInt", desc, attr_name, value);
            }
            mh$.invokeExact(desc, attr_name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrIntList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrIntList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrIntList(TF_OperationDescription *desc, const char *attr_name, const int64_t *values, int num_values)
     * }
     */
    public static FunctionDescriptor TF_SetAttrIntList$descriptor() {
        return TF_SetAttrIntList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrIntList(TF_OperationDescription *desc, const char *attr_name, const int64_t *values, int num_values)
     * }
     */
    public static MethodHandle TF_SetAttrIntList$handle() {
        return TF_SetAttrIntList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrIntList(TF_OperationDescription *desc, const char *attr_name, const int64_t *values, int num_values)
     * }
     */
    public static MemorySegment TF_SetAttrIntList$address() {
        return TF_SetAttrIntList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrIntList(TF_OperationDescription *desc, const char *attr_name, const int64_t *values, int num_values)
     * }
     */
    public static void TF_SetAttrIntList(MemorySegment desc, MemorySegment attr_name, MemorySegment values, int num_values) {
        var mh$ = TF_SetAttrIntList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrIntList", desc, attr_name, values, num_values);
            }
            mh$.invokeExact(desc, attr_name, values, num_values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFloat(TF_OperationDescription *desc, const char *attr_name, float value)
     * }
     */
    public static FunctionDescriptor TF_SetAttrFloat$descriptor() {
        return TF_SetAttrFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFloat(TF_OperationDescription *desc, const char *attr_name, float value)
     * }
     */
    public static MethodHandle TF_SetAttrFloat$handle() {
        return TF_SetAttrFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFloat(TF_OperationDescription *desc, const char *attr_name, float value)
     * }
     */
    public static MemorySegment TF_SetAttrFloat$address() {
        return TF_SetAttrFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrFloat(TF_OperationDescription *desc, const char *attr_name, float value)
     * }
     */
    public static void TF_SetAttrFloat(MemorySegment desc, MemorySegment attr_name, float value) {
        var mh$ = TF_SetAttrFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrFloat", desc, attr_name, value);
            }
            mh$.invokeExact(desc, attr_name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrFloatList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrFloatList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFloatList(TF_OperationDescription *desc, const char *attr_name, const float *values, int num_values)
     * }
     */
    public static FunctionDescriptor TF_SetAttrFloatList$descriptor() {
        return TF_SetAttrFloatList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFloatList(TF_OperationDescription *desc, const char *attr_name, const float *values, int num_values)
     * }
     */
    public static MethodHandle TF_SetAttrFloatList$handle() {
        return TF_SetAttrFloatList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFloatList(TF_OperationDescription *desc, const char *attr_name, const float *values, int num_values)
     * }
     */
    public static MemorySegment TF_SetAttrFloatList$address() {
        return TF_SetAttrFloatList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrFloatList(TF_OperationDescription *desc, const char *attr_name, const float *values, int num_values)
     * }
     */
    public static void TF_SetAttrFloatList(MemorySegment desc, MemorySegment attr_name, MemorySegment values, int num_values) {
        var mh$ = TF_SetAttrFloatList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrFloatList", desc, attr_name, values, num_values);
            }
            mh$.invokeExact(desc, attr_name, values, num_values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrBool(TF_OperationDescription *desc, const char *attr_name, unsigned char value)
     * }
     */
    public static FunctionDescriptor TF_SetAttrBool$descriptor() {
        return TF_SetAttrBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrBool(TF_OperationDescription *desc, const char *attr_name, unsigned char value)
     * }
     */
    public static MethodHandle TF_SetAttrBool$handle() {
        return TF_SetAttrBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrBool(TF_OperationDescription *desc, const char *attr_name, unsigned char value)
     * }
     */
    public static MemorySegment TF_SetAttrBool$address() {
        return TF_SetAttrBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrBool(TF_OperationDescription *desc, const char *attr_name, unsigned char value)
     * }
     */
    public static void TF_SetAttrBool(MemorySegment desc, MemorySegment attr_name, byte value) {
        var mh$ = TF_SetAttrBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrBool", desc, attr_name, value);
            }
            mh$.invokeExact(desc, attr_name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrBoolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrBoolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrBoolList(TF_OperationDescription *desc, const char *attr_name, const unsigned char *values, int num_values)
     * }
     */
    public static FunctionDescriptor TF_SetAttrBoolList$descriptor() {
        return TF_SetAttrBoolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrBoolList(TF_OperationDescription *desc, const char *attr_name, const unsigned char *values, int num_values)
     * }
     */
    public static MethodHandle TF_SetAttrBoolList$handle() {
        return TF_SetAttrBoolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrBoolList(TF_OperationDescription *desc, const char *attr_name, const unsigned char *values, int num_values)
     * }
     */
    public static MemorySegment TF_SetAttrBoolList$address() {
        return TF_SetAttrBoolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrBoolList(TF_OperationDescription *desc, const char *attr_name, const unsigned char *values, int num_values)
     * }
     */
    public static void TF_SetAttrBoolList(MemorySegment desc, MemorySegment attr_name, MemorySegment values, int num_values) {
        var mh$ = TF_SetAttrBoolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrBoolList", desc, attr_name, values, num_values);
            }
            mh$.invokeExact(desc, attr_name, values, num_values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrType(TF_OperationDescription *desc, const char *attr_name, TF_DataType value)
     * }
     */
    public static FunctionDescriptor TF_SetAttrType$descriptor() {
        return TF_SetAttrType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrType(TF_OperationDescription *desc, const char *attr_name, TF_DataType value)
     * }
     */
    public static MethodHandle TF_SetAttrType$handle() {
        return TF_SetAttrType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrType(TF_OperationDescription *desc, const char *attr_name, TF_DataType value)
     * }
     */
    public static MemorySegment TF_SetAttrType$address() {
        return TF_SetAttrType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrType(TF_OperationDescription *desc, const char *attr_name, TF_DataType value)
     * }
     */
    public static void TF_SetAttrType(MemorySegment desc, MemorySegment attr_name, int value) {
        var mh$ = TF_SetAttrType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrType", desc, attr_name, value);
            }
            mh$.invokeExact(desc, attr_name, value);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrTypeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrTypeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTypeList(TF_OperationDescription *desc, const char *attr_name, const TF_DataType *values, int num_values)
     * }
     */
    public static FunctionDescriptor TF_SetAttrTypeList$descriptor() {
        return TF_SetAttrTypeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTypeList(TF_OperationDescription *desc, const char *attr_name, const TF_DataType *values, int num_values)
     * }
     */
    public static MethodHandle TF_SetAttrTypeList$handle() {
        return TF_SetAttrTypeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTypeList(TF_OperationDescription *desc, const char *attr_name, const TF_DataType *values, int num_values)
     * }
     */
    public static MemorySegment TF_SetAttrTypeList$address() {
        return TF_SetAttrTypeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrTypeList(TF_OperationDescription *desc, const char *attr_name, const TF_DataType *values, int num_values)
     * }
     */
    public static void TF_SetAttrTypeList(MemorySegment desc, MemorySegment attr_name, MemorySegment values, int num_values) {
        var mh$ = TF_SetAttrTypeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrTypeList", desc, attr_name, values, num_values);
            }
            mh$.invokeExact(desc, attr_name, values, num_values);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrPlaceholder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrPlaceholder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrPlaceholder(TF_OperationDescription *desc, const char *attr_name, const char *placeholder)
     * }
     */
    public static FunctionDescriptor TF_SetAttrPlaceholder$descriptor() {
        return TF_SetAttrPlaceholder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrPlaceholder(TF_OperationDescription *desc, const char *attr_name, const char *placeholder)
     * }
     */
    public static MethodHandle TF_SetAttrPlaceholder$handle() {
        return TF_SetAttrPlaceholder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrPlaceholder(TF_OperationDescription *desc, const char *attr_name, const char *placeholder)
     * }
     */
    public static MemorySegment TF_SetAttrPlaceholder$address() {
        return TF_SetAttrPlaceholder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrPlaceholder(TF_OperationDescription *desc, const char *attr_name, const char *placeholder)
     * }
     */
    public static void TF_SetAttrPlaceholder(MemorySegment desc, MemorySegment attr_name, MemorySegment placeholder) {
        var mh$ = TF_SetAttrPlaceholder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrPlaceholder", desc, attr_name, placeholder);
            }
            mh$.invokeExact(desc, attr_name, placeholder);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrFuncName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrFuncName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFuncName(TF_OperationDescription *desc, const char *attr_name, const char *value, size_t length)
     * }
     */
    public static FunctionDescriptor TF_SetAttrFuncName$descriptor() {
        return TF_SetAttrFuncName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFuncName(TF_OperationDescription *desc, const char *attr_name, const char *value, size_t length)
     * }
     */
    public static MethodHandle TF_SetAttrFuncName$handle() {
        return TF_SetAttrFuncName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrFuncName(TF_OperationDescription *desc, const char *attr_name, const char *value, size_t length)
     * }
     */
    public static MemorySegment TF_SetAttrFuncName$address() {
        return TF_SetAttrFuncName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrFuncName(TF_OperationDescription *desc, const char *attr_name, const char *value, size_t length)
     * }
     */
    public static void TF_SetAttrFuncName(MemorySegment desc, MemorySegment attr_name, MemorySegment value, long length) {
        var mh$ = TF_SetAttrFuncName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrFuncName", desc, attr_name, value, length);
            }
            mh$.invokeExact(desc, attr_name, value, length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrShape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrShape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrShape(TF_OperationDescription *desc, const char *attr_name, const int64_t *dims, int num_dims)
     * }
     */
    public static FunctionDescriptor TF_SetAttrShape$descriptor() {
        return TF_SetAttrShape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrShape(TF_OperationDescription *desc, const char *attr_name, const int64_t *dims, int num_dims)
     * }
     */
    public static MethodHandle TF_SetAttrShape$handle() {
        return TF_SetAttrShape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrShape(TF_OperationDescription *desc, const char *attr_name, const int64_t *dims, int num_dims)
     * }
     */
    public static MemorySegment TF_SetAttrShape$address() {
        return TF_SetAttrShape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrShape(TF_OperationDescription *desc, const char *attr_name, const int64_t *dims, int num_dims)
     * }
     */
    public static void TF_SetAttrShape(MemorySegment desc, MemorySegment attr_name, MemorySegment dims, int num_dims) {
        var mh$ = TF_SetAttrShape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrShape", desc, attr_name, dims, num_dims);
            }
            mh$.invokeExact(desc, attr_name, dims, num_dims);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrShapeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrShapeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrShapeList(TF_OperationDescription *desc, const char *attr_name, const int64_t *const *dims, const int *num_dims, int num_shapes)
     * }
     */
    public static FunctionDescriptor TF_SetAttrShapeList$descriptor() {
        return TF_SetAttrShapeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrShapeList(TF_OperationDescription *desc, const char *attr_name, const int64_t *const *dims, const int *num_dims, int num_shapes)
     * }
     */
    public static MethodHandle TF_SetAttrShapeList$handle() {
        return TF_SetAttrShapeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrShapeList(TF_OperationDescription *desc, const char *attr_name, const int64_t *const *dims, const int *num_dims, int num_shapes)
     * }
     */
    public static MemorySegment TF_SetAttrShapeList$address() {
        return TF_SetAttrShapeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrShapeList(TF_OperationDescription *desc, const char *attr_name, const int64_t *const *dims, const int *num_dims, int num_shapes)
     * }
     */
    public static void TF_SetAttrShapeList(MemorySegment desc, MemorySegment attr_name, MemorySegment dims, MemorySegment num_dims, int num_shapes) {
        var mh$ = TF_SetAttrShapeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrShapeList", desc, attr_name, dims, num_dims, num_shapes);
            }
            mh$.invokeExact(desc, attr_name, dims, num_dims, num_shapes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrTensorShapeProto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrTensorShapeProto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_SetAttrTensorShapeProto$descriptor() {
        return TF_SetAttrTensorShapeProto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_SetAttrTensorShapeProto$handle() {
        return TF_SetAttrTensorShapeProto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SetAttrTensorShapeProto$address() {
        return TF_SetAttrTensorShapeProto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static void TF_SetAttrTensorShapeProto(MemorySegment desc, MemorySegment attr_name, MemorySegment proto, long proto_len, MemorySegment status) {
        var mh$ = TF_SetAttrTensorShapeProto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrTensorShapeProto", desc, attr_name, proto, proto_len, status);
            }
            mh$.invokeExact(desc, attr_name, proto, proto_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrTensorShapeProtoList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrTensorShapeProtoList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProtoList(TF_OperationDescription *desc, const char *attr_name, const void *const *protos, const size_t *proto_lens, int num_shapes, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_SetAttrTensorShapeProtoList$descriptor() {
        return TF_SetAttrTensorShapeProtoList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProtoList(TF_OperationDescription *desc, const char *attr_name, const void *const *protos, const size_t *proto_lens, int num_shapes, TF_Status *status)
     * }
     */
    public static MethodHandle TF_SetAttrTensorShapeProtoList$handle() {
        return TF_SetAttrTensorShapeProtoList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProtoList(TF_OperationDescription *desc, const char *attr_name, const void *const *protos, const size_t *proto_lens, int num_shapes, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SetAttrTensorShapeProtoList$address() {
        return TF_SetAttrTensorShapeProtoList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorShapeProtoList(TF_OperationDescription *desc, const char *attr_name, const void *const *protos, const size_t *proto_lens, int num_shapes, TF_Status *status)
     * }
     */
    public static void TF_SetAttrTensorShapeProtoList(MemorySegment desc, MemorySegment attr_name, MemorySegment protos, MemorySegment proto_lens, int num_shapes, MemorySegment status) {
        var mh$ = TF_SetAttrTensorShapeProtoList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrTensorShapeProtoList", desc, attr_name, protos, proto_lens, num_shapes, status);
            }
            mh$.invokeExact(desc, attr_name, protos, proto_lens, num_shapes, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrTensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrTensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensor(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_SetAttrTensor$descriptor() {
        return TF_SetAttrTensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensor(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_SetAttrTensor$handle() {
        return TF_SetAttrTensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensor(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SetAttrTensor$address() {
        return TF_SetAttrTensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrTensor(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *value, TF_Status *status)
     * }
     */
    public static void TF_SetAttrTensor(MemorySegment desc, MemorySegment attr_name, MemorySegment value, MemorySegment status) {
        var mh$ = TF_SetAttrTensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrTensor", desc, attr_name, value, status);
            }
            mh$.invokeExact(desc, attr_name, value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrTensorList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrTensorList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorList(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *const *values, int num_values, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_SetAttrTensorList$descriptor() {
        return TF_SetAttrTensorList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorList(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *const *values, int num_values, TF_Status *status)
     * }
     */
    public static MethodHandle TF_SetAttrTensorList$handle() {
        return TF_SetAttrTensorList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorList(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *const *values, int num_values, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SetAttrTensorList$address() {
        return TF_SetAttrTensorList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrTensorList(TF_OperationDescription *desc, const char *attr_name, TF_Tensor *const *values, int num_values, TF_Status *status)
     * }
     */
    public static void TF_SetAttrTensorList(MemorySegment desc, MemorySegment attr_name, MemorySegment values, int num_values, MemorySegment status) {
        var mh$ = TF_SetAttrTensorList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrTensorList", desc, attr_name, values, num_values, status);
            }
            mh$.invokeExact(desc, attr_name, values, num_values, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SetAttrValueProto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SetAttrValueProto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SetAttrValueProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_SetAttrValueProto$descriptor() {
        return TF_SetAttrValueProto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SetAttrValueProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_SetAttrValueProto$handle() {
        return TF_SetAttrValueProto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SetAttrValueProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SetAttrValueProto$address() {
        return TF_SetAttrValueProto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SetAttrValueProto(TF_OperationDescription *desc, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static void TF_SetAttrValueProto(MemorySegment desc, MemorySegment attr_name, MemorySegment proto, long proto_len, MemorySegment status) {
        var mh$ = TF_SetAttrValueProto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SetAttrValueProto", desc, attr_name, proto, proto_len, status);
            }
            mh$.invokeExact(desc, attr_name, proto, proto_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FinishOperationLocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FinishOperationLocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperationLocked(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_FinishOperationLocked$descriptor() {
        return TF_FinishOperationLocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperationLocked(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static MethodHandle TF_FinishOperationLocked$handle() {
        return TF_FinishOperationLocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperationLocked(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FinishOperationLocked$address() {
        return TF_FinishOperationLocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperationLocked(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FinishOperationLocked(MemorySegment desc, MemorySegment status) {
        var mh$ = TF_FinishOperationLocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FinishOperationLocked", desc, status);
            }
            return (MemorySegment)mh$.invokeExact(desc, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FinishOperation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FinishOperation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperation(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_FinishOperation$descriptor() {
        return TF_FinishOperation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperation(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static MethodHandle TF_FinishOperation$handle() {
        return TF_FinishOperation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperation(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FinishOperation$address() {
        return TF_FinishOperation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Operation *TF_FinishOperation(TF_OperationDescription *desc, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FinishOperation(MemorySegment desc, MemorySegment status) {
        var mh$ = TF_FinishOperation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FinishOperation", desc, status);
            }
            return (MemorySegment)mh$.invokeExact(desc, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_OperationName(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationName$descriptor() {
        return TF_OperationName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_OperationName(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationName$handle() {
        return TF_OperationName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_OperationName(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationName$address() {
        return TF_OperationName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_OperationName(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationName(MemorySegment oper) {
        var mh$ = TF_OperationName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationName", oper);
            }
            return (MemorySegment)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationOpType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationOpType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_OperationOpType(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationOpType$descriptor() {
        return TF_OperationOpType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_OperationOpType(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationOpType$handle() {
        return TF_OperationOpType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_OperationOpType(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationOpType$address() {
        return TF_OperationOpType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_OperationOpType(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationOpType(MemorySegment oper) {
        var mh$ = TF_OperationOpType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationOpType", oper);
            }
            return (MemorySegment)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_OperationDevice(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationDevice$descriptor() {
        return TF_OperationDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_OperationDevice(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationDevice$handle() {
        return TF_OperationDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_OperationDevice(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationDevice$address() {
        return TF_OperationDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_OperationDevice(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationDevice(MemorySegment oper) {
        var mh$ = TF_OperationDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationDevice", oper);
            }
            return (MemorySegment)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationNumOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationNumOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationNumOutputs(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationNumOutputs$descriptor() {
        return TF_OperationNumOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationNumOutputs(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationNumOutputs$handle() {
        return TF_OperationNumOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationNumOutputs(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationNumOutputs$address() {
        return TF_OperationNumOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationNumOutputs(TF_Operation *oper)
     * }
     */
    public static int TF_OperationNumOutputs(MemorySegment oper) {
        var mh$ = TF_OperationNumOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationNumOutputs", oper);
            }
            return (int)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationOutputType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            TF_Output.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationOutputType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationOutputType(TF_Output oper_out)
     * }
     */
    public static FunctionDescriptor TF_OperationOutputType$descriptor() {
        return TF_OperationOutputType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationOutputType(TF_Output oper_out)
     * }
     */
    public static MethodHandle TF_OperationOutputType$handle() {
        return TF_OperationOutputType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationOutputType(TF_Output oper_out)
     * }
     */
    public static MemorySegment TF_OperationOutputType$address() {
        return TF_OperationOutputType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationOutputType(TF_Output oper_out)
     * }
     */
    public static int TF_OperationOutputType(MemorySegment oper_out) {
        var mh$ = TF_OperationOutputType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationOutputType", oper_out);
            }
            return (int)mh$.invokeExact(oper_out);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationOutputListLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationOutputListLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationOutputListLength$descriptor() {
        return TF_OperationOutputListLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationOutputListLength$handle() {
        return TF_OperationOutputListLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationOutputListLength$address() {
        return TF_OperationOutputListLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationOutputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static int TF_OperationOutputListLength(MemorySegment oper, MemorySegment arg_name, MemorySegment status) {
        var mh$ = TF_OperationOutputListLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationOutputListLength", oper, arg_name, status);
            }
            return (int)mh$.invokeExact(oper, arg_name, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationNumInputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationNumInputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationNumInputs(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationNumInputs$descriptor() {
        return TF_OperationNumInputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationNumInputs(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationNumInputs$handle() {
        return TF_OperationNumInputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationNumInputs(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationNumInputs$address() {
        return TF_OperationNumInputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationNumInputs(TF_Operation *oper)
     * }
     */
    public static int TF_OperationNumInputs(MemorySegment oper) {
        var mh$ = TF_OperationNumInputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationNumInputs", oper);
            }
            return (int)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationInputType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            TF_Input.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationInputType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationInputType(TF_Input oper_in)
     * }
     */
    public static FunctionDescriptor TF_OperationInputType$descriptor() {
        return TF_OperationInputType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationInputType(TF_Input oper_in)
     * }
     */
    public static MethodHandle TF_OperationInputType$handle() {
        return TF_OperationInputType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationInputType(TF_Input oper_in)
     * }
     */
    public static MemorySegment TF_OperationInputType$address() {
        return TF_OperationInputType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_DataType TF_OperationInputType(TF_Input oper_in)
     * }
     */
    public static int TF_OperationInputType(MemorySegment oper_in) {
        var mh$ = TF_OperationInputType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationInputType", oper_in);
            }
            return (int)mh$.invokeExact(oper_in);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationInputListLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationInputListLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationInputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationInputListLength$descriptor() {
        return TF_OperationInputListLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationInputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationInputListLength$handle() {
        return TF_OperationInputListLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationInputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationInputListLength$address() {
        return TF_OperationInputListLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationInputListLength(TF_Operation *oper, const char *arg_name, TF_Status *status)
     * }
     */
    public static int TF_OperationInputListLength(MemorySegment oper, MemorySegment arg_name, MemorySegment status) {
        var mh$ = TF_OperationInputListLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationInputListLength", oper, arg_name, status);
            }
            return (int)mh$.invokeExact(oper, arg_name, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TF_Output.layout(),
            TF_Input.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Output TF_OperationInput(TF_Input oper_in)
     * }
     */
    public static FunctionDescriptor TF_OperationInput$descriptor() {
        return TF_OperationInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Output TF_OperationInput(TF_Input oper_in)
     * }
     */
    public static MethodHandle TF_OperationInput$handle() {
        return TF_OperationInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Output TF_OperationInput(TF_Input oper_in)
     * }
     */
    public static MemorySegment TF_OperationInput$address() {
        return TF_OperationInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Output TF_OperationInput(TF_Input oper_in)
     * }
     */
    public static MemorySegment TF_OperationInput(SegmentAllocator allocator, MemorySegment oper_in) {
        var mh$ = TF_OperationInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationInput", allocator, oper_in);
            }
            return (MemorySegment)mh$.invokeExact(allocator, oper_in);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationAllInputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationAllInputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationAllInputs(TF_Operation *oper, TF_Output *inputs, int max_inputs)
     * }
     */
    public static FunctionDescriptor TF_OperationAllInputs$descriptor() {
        return TF_OperationAllInputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationAllInputs(TF_Operation *oper, TF_Output *inputs, int max_inputs)
     * }
     */
    public static MethodHandle TF_OperationAllInputs$handle() {
        return TF_OperationAllInputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationAllInputs(TF_Operation *oper, TF_Output *inputs, int max_inputs)
     * }
     */
    public static MemorySegment TF_OperationAllInputs$address() {
        return TF_OperationAllInputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationAllInputs(TF_Operation *oper, TF_Output *inputs, int max_inputs)
     * }
     */
    public static void TF_OperationAllInputs(MemorySegment oper, MemorySegment inputs, int max_inputs) {
        var mh$ = TF_OperationAllInputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationAllInputs", oper, inputs, max_inputs);
            }
            mh$.invokeExact(oper, inputs, max_inputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationOutputNumConsumers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            TF_Output.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationOutputNumConsumers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputNumConsumers(TF_Output oper_out)
     * }
     */
    public static FunctionDescriptor TF_OperationOutputNumConsumers$descriptor() {
        return TF_OperationOutputNumConsumers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputNumConsumers(TF_Output oper_out)
     * }
     */
    public static MethodHandle TF_OperationOutputNumConsumers$handle() {
        return TF_OperationOutputNumConsumers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputNumConsumers(TF_Output oper_out)
     * }
     */
    public static MemorySegment TF_OperationOutputNumConsumers$address() {
        return TF_OperationOutputNumConsumers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationOutputNumConsumers(TF_Output oper_out)
     * }
     */
    public static int TF_OperationOutputNumConsumers(MemorySegment oper_out) {
        var mh$ = TF_OperationOutputNumConsumers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationOutputNumConsumers", oper_out);
            }
            return (int)mh$.invokeExact(oper_out);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationOutputConsumers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            TF_Output.layout(),
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationOutputConsumers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputConsumers(TF_Output oper_out, TF_Input *consumers, int max_consumers)
     * }
     */
    public static FunctionDescriptor TF_OperationOutputConsumers$descriptor() {
        return TF_OperationOutputConsumers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputConsumers(TF_Output oper_out, TF_Input *consumers, int max_consumers)
     * }
     */
    public static MethodHandle TF_OperationOutputConsumers$handle() {
        return TF_OperationOutputConsumers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationOutputConsumers(TF_Output oper_out, TF_Input *consumers, int max_consumers)
     * }
     */
    public static MemorySegment TF_OperationOutputConsumers$address() {
        return TF_OperationOutputConsumers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationOutputConsumers(TF_Output oper_out, TF_Input *consumers, int max_consumers)
     * }
     */
    public static int TF_OperationOutputConsumers(MemorySegment oper_out, MemorySegment consumers, int max_consumers) {
        var mh$ = TF_OperationOutputConsumers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationOutputConsumers", oper_out, consumers, max_consumers);
            }
            return (int)mh$.invokeExact(oper_out, consumers, max_consumers);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationNumControlInputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationNumControlInputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationNumControlInputs(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationNumControlInputs$descriptor() {
        return TF_OperationNumControlInputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationNumControlInputs(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationNumControlInputs$handle() {
        return TF_OperationNumControlInputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationNumControlInputs(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationNumControlInputs$address() {
        return TF_OperationNumControlInputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationNumControlInputs(TF_Operation *oper)
     * }
     */
    public static int TF_OperationNumControlInputs(MemorySegment oper) {
        var mh$ = TF_OperationNumControlInputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationNumControlInputs", oper);
            }
            return (int)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetControlInputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetControlInputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationGetControlInputs(TF_Operation *oper, TF_Operation **control_inputs, int max_control_inputs)
     * }
     */
    public static FunctionDescriptor TF_OperationGetControlInputs$descriptor() {
        return TF_OperationGetControlInputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationGetControlInputs(TF_Operation *oper, TF_Operation **control_inputs, int max_control_inputs)
     * }
     */
    public static MethodHandle TF_OperationGetControlInputs$handle() {
        return TF_OperationGetControlInputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationGetControlInputs(TF_Operation *oper, TF_Operation **control_inputs, int max_control_inputs)
     * }
     */
    public static MemorySegment TF_OperationGetControlInputs$address() {
        return TF_OperationGetControlInputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationGetControlInputs(TF_Operation *oper, TF_Operation **control_inputs, int max_control_inputs)
     * }
     */
    public static int TF_OperationGetControlInputs(MemorySegment oper, MemorySegment control_inputs, int max_control_inputs) {
        var mh$ = TF_OperationGetControlInputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetControlInputs", oper, control_inputs, max_control_inputs);
            }
            return (int)mh$.invokeExact(oper, control_inputs, max_control_inputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationNumControlOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationNumControlOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationNumControlOutputs(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationNumControlOutputs$descriptor() {
        return TF_OperationNumControlOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationNumControlOutputs(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationNumControlOutputs$handle() {
        return TF_OperationNumControlOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationNumControlOutputs(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationNumControlOutputs$address() {
        return TF_OperationNumControlOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationNumControlOutputs(TF_Operation *oper)
     * }
     */
    public static int TF_OperationNumControlOutputs(MemorySegment oper) {
        var mh$ = TF_OperationNumControlOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationNumControlOutputs", oper);
            }
            return (int)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetControlOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetControlOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationGetControlOutputs(TF_Operation *oper, TF_Operation **control_outputs, int max_control_outputs)
     * }
     */
    public static FunctionDescriptor TF_OperationGetControlOutputs$descriptor() {
        return TF_OperationGetControlOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationGetControlOutputs(TF_Operation *oper, TF_Operation **control_outputs, int max_control_outputs)
     * }
     */
    public static MethodHandle TF_OperationGetControlOutputs$handle() {
        return TF_OperationGetControlOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationGetControlOutputs(TF_Operation *oper, TF_Operation **control_outputs, int max_control_outputs)
     * }
     */
    public static MemorySegment TF_OperationGetControlOutputs$address() {
        return TF_OperationGetControlOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationGetControlOutputs(TF_Operation *oper, TF_Operation **control_outputs, int max_control_outputs)
     * }
     */
    public static int TF_OperationGetControlOutputs(MemorySegment oper, MemorySegment control_outputs, int max_control_outputs) {
        var mh$ = TF_OperationGetControlOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetControlOutputs", oper, control_outputs, max_control_outputs);
            }
            return (int)mh$.invokeExact(oper, control_outputs, max_control_outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrMetadata {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TF_AttrMetadata.layout(),
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrMetadata");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_AttrMetadata TF_OperationGetAttrMetadata(TF_Operation *oper, const char *attr_name, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrMetadata$descriptor() {
        return TF_OperationGetAttrMetadata.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_AttrMetadata TF_OperationGetAttrMetadata(TF_Operation *oper, const char *attr_name, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrMetadata$handle() {
        return TF_OperationGetAttrMetadata.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_AttrMetadata TF_OperationGetAttrMetadata(TF_Operation *oper, const char *attr_name, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrMetadata$address() {
        return TF_OperationGetAttrMetadata.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_AttrMetadata TF_OperationGetAttrMetadata(TF_Operation *oper, const char *attr_name, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrMetadata(SegmentAllocator allocator, MemorySegment oper, MemorySegment attr_name, MemorySegment status) {
        var mh$ = TF_OperationGetAttrMetadata.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrMetadata", allocator, oper, attr_name, status);
            }
            return (MemorySegment)mh$.invokeExact(allocator, oper, attr_name, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrString {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrString");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrString(TF_Operation *oper, const char *attr_name, void *value, size_t max_length, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrString$descriptor() {
        return TF_OperationGetAttrString.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrString(TF_Operation *oper, const char *attr_name, void *value, size_t max_length, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrString$handle() {
        return TF_OperationGetAttrString.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrString(TF_Operation *oper, const char *attr_name, void *value, size_t max_length, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrString$address() {
        return TF_OperationGetAttrString.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrString(TF_Operation *oper, const char *attr_name, void *value, size_t max_length, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrString(MemorySegment oper, MemorySegment attr_name, MemorySegment value, long max_length, MemorySegment status) {
        var mh$ = TF_OperationGetAttrString.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrString", oper, attr_name, value, max_length, status);
            }
            mh$.invokeExact(oper, attr_name, value, max_length, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrStringList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrStringList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrStringList(TF_Operation *oper, const char *attr_name, void **values, size_t *lengths, int max_values, void *storage, size_t storage_size, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrStringList$descriptor() {
        return TF_OperationGetAttrStringList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrStringList(TF_Operation *oper, const char *attr_name, void **values, size_t *lengths, int max_values, void *storage, size_t storage_size, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrStringList$handle() {
        return TF_OperationGetAttrStringList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrStringList(TF_Operation *oper, const char *attr_name, void **values, size_t *lengths, int max_values, void *storage, size_t storage_size, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrStringList$address() {
        return TF_OperationGetAttrStringList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrStringList(TF_Operation *oper, const char *attr_name, void **values, size_t *lengths, int max_values, void *storage, size_t storage_size, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrStringList(MemorySegment oper, MemorySegment attr_name, MemorySegment values, MemorySegment lengths, int max_values, MemorySegment storage, long storage_size, MemorySegment status) {
        var mh$ = TF_OperationGetAttrStringList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrStringList", oper, attr_name, values, lengths, max_values, storage, storage_size, status);
            }
            mh$.invokeExact(oper, attr_name, values, lengths, max_values, storage, storage_size, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrInt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrInt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrInt(TF_Operation *oper, const char *attr_name, int64_t *value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrInt$descriptor() {
        return TF_OperationGetAttrInt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrInt(TF_Operation *oper, const char *attr_name, int64_t *value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrInt$handle() {
        return TF_OperationGetAttrInt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrInt(TF_Operation *oper, const char *attr_name, int64_t *value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrInt$address() {
        return TF_OperationGetAttrInt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrInt(TF_Operation *oper, const char *attr_name, int64_t *value, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrInt(MemorySegment oper, MemorySegment attr_name, MemorySegment value, MemorySegment status) {
        var mh$ = TF_OperationGetAttrInt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrInt", oper, attr_name, value, status);
            }
            mh$.invokeExact(oper, attr_name, value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrIntList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrIntList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrIntList(TF_Operation *oper, const char *attr_name, int64_t *values, int max_values, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrIntList$descriptor() {
        return TF_OperationGetAttrIntList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrIntList(TF_Operation *oper, const char *attr_name, int64_t *values, int max_values, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrIntList$handle() {
        return TF_OperationGetAttrIntList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrIntList(TF_Operation *oper, const char *attr_name, int64_t *values, int max_values, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrIntList$address() {
        return TF_OperationGetAttrIntList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrIntList(TF_Operation *oper, const char *attr_name, int64_t *values, int max_values, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrIntList(MemorySegment oper, MemorySegment attr_name, MemorySegment values, int max_values, MemorySegment status) {
        var mh$ = TF_OperationGetAttrIntList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrIntList", oper, attr_name, values, max_values, status);
            }
            mh$.invokeExact(oper, attr_name, values, max_values, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrFloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrFloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloat(TF_Operation *oper, const char *attr_name, float *value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrFloat$descriptor() {
        return TF_OperationGetAttrFloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloat(TF_Operation *oper, const char *attr_name, float *value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrFloat$handle() {
        return TF_OperationGetAttrFloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloat(TF_Operation *oper, const char *attr_name, float *value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrFloat$address() {
        return TF_OperationGetAttrFloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloat(TF_Operation *oper, const char *attr_name, float *value, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrFloat(MemorySegment oper, MemorySegment attr_name, MemorySegment value, MemorySegment status) {
        var mh$ = TF_OperationGetAttrFloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrFloat", oper, attr_name, value, status);
            }
            mh$.invokeExact(oper, attr_name, value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrFloatList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrFloatList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloatList(TF_Operation *oper, const char *attr_name, float *values, int max_values, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrFloatList$descriptor() {
        return TF_OperationGetAttrFloatList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloatList(TF_Operation *oper, const char *attr_name, float *values, int max_values, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrFloatList$handle() {
        return TF_OperationGetAttrFloatList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloatList(TF_Operation *oper, const char *attr_name, float *values, int max_values, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrFloatList$address() {
        return TF_OperationGetAttrFloatList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrFloatList(TF_Operation *oper, const char *attr_name, float *values, int max_values, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrFloatList(MemorySegment oper, MemorySegment attr_name, MemorySegment values, int max_values, MemorySegment status) {
        var mh$ = TF_OperationGetAttrFloatList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrFloatList", oper, attr_name, values, max_values, status);
            }
            mh$.invokeExact(oper, attr_name, values, max_values, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrBool {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrBool");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBool(TF_Operation *oper, const char *attr_name, unsigned char *value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrBool$descriptor() {
        return TF_OperationGetAttrBool.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBool(TF_Operation *oper, const char *attr_name, unsigned char *value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrBool$handle() {
        return TF_OperationGetAttrBool.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBool(TF_Operation *oper, const char *attr_name, unsigned char *value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrBool$address() {
        return TF_OperationGetAttrBool.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBool(TF_Operation *oper, const char *attr_name, unsigned char *value, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrBool(MemorySegment oper, MemorySegment attr_name, MemorySegment value, MemorySegment status) {
        var mh$ = TF_OperationGetAttrBool.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrBool", oper, attr_name, value, status);
            }
            mh$.invokeExact(oper, attr_name, value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrBoolList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrBoolList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBoolList(TF_Operation *oper, const char *attr_name, unsigned char *values, int max_values, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrBoolList$descriptor() {
        return TF_OperationGetAttrBoolList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBoolList(TF_Operation *oper, const char *attr_name, unsigned char *values, int max_values, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrBoolList$handle() {
        return TF_OperationGetAttrBoolList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBoolList(TF_Operation *oper, const char *attr_name, unsigned char *values, int max_values, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrBoolList$address() {
        return TF_OperationGetAttrBoolList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrBoolList(TF_Operation *oper, const char *attr_name, unsigned char *values, int max_values, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrBoolList(MemorySegment oper, MemorySegment attr_name, MemorySegment values, int max_values, MemorySegment status) {
        var mh$ = TF_OperationGetAttrBoolList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrBoolList", oper, attr_name, values, max_values, status);
            }
            mh$.invokeExact(oper, attr_name, values, max_values, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrType(TF_Operation *oper, const char *attr_name, TF_DataType *value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrType$descriptor() {
        return TF_OperationGetAttrType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrType(TF_Operation *oper, const char *attr_name, TF_DataType *value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrType$handle() {
        return TF_OperationGetAttrType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrType(TF_Operation *oper, const char *attr_name, TF_DataType *value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrType$address() {
        return TF_OperationGetAttrType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrType(TF_Operation *oper, const char *attr_name, TF_DataType *value, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrType(MemorySegment oper, MemorySegment attr_name, MemorySegment value, MemorySegment status) {
        var mh$ = TF_OperationGetAttrType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrType", oper, attr_name, value, status);
            }
            mh$.invokeExact(oper, attr_name, value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrTypeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrTypeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTypeList(TF_Operation *oper, const char *attr_name, TF_DataType *values, int max_values, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrTypeList$descriptor() {
        return TF_OperationGetAttrTypeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTypeList(TF_Operation *oper, const char *attr_name, TF_DataType *values, int max_values, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrTypeList$handle() {
        return TF_OperationGetAttrTypeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTypeList(TF_Operation *oper, const char *attr_name, TF_DataType *values, int max_values, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrTypeList$address() {
        return TF_OperationGetAttrTypeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTypeList(TF_Operation *oper, const char *attr_name, TF_DataType *values, int max_values, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrTypeList(MemorySegment oper, MemorySegment attr_name, MemorySegment values, int max_values, MemorySegment status) {
        var mh$ = TF_OperationGetAttrTypeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrTypeList", oper, attr_name, values, max_values, status);
            }
            mh$.invokeExact(oper, attr_name, values, max_values, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrShape {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrShape");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShape(TF_Operation *oper, const char *attr_name, int64_t *value, int num_dims, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrShape$descriptor() {
        return TF_OperationGetAttrShape.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShape(TF_Operation *oper, const char *attr_name, int64_t *value, int num_dims, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrShape$handle() {
        return TF_OperationGetAttrShape.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShape(TF_Operation *oper, const char *attr_name, int64_t *value, int num_dims, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrShape$address() {
        return TF_OperationGetAttrShape.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShape(TF_Operation *oper, const char *attr_name, int64_t *value, int num_dims, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrShape(MemorySegment oper, MemorySegment attr_name, MemorySegment value, int num_dims, MemorySegment status) {
        var mh$ = TF_OperationGetAttrShape.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrShape", oper, attr_name, value, num_dims, status);
            }
            mh$.invokeExact(oper, attr_name, value, num_dims, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrShapeList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrShapeList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShapeList(TF_Operation *oper, const char *attr_name, int64_t **dims, int *num_dims, int num_shapes, int64_t *storage, int storage_size, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrShapeList$descriptor() {
        return TF_OperationGetAttrShapeList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShapeList(TF_Operation *oper, const char *attr_name, int64_t **dims, int *num_dims, int num_shapes, int64_t *storage, int storage_size, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrShapeList$handle() {
        return TF_OperationGetAttrShapeList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShapeList(TF_Operation *oper, const char *attr_name, int64_t **dims, int *num_dims, int num_shapes, int64_t *storage, int storage_size, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrShapeList$address() {
        return TF_OperationGetAttrShapeList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrShapeList(TF_Operation *oper, const char *attr_name, int64_t **dims, int *num_dims, int num_shapes, int64_t *storage, int storage_size, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrShapeList(MemorySegment oper, MemorySegment attr_name, MemorySegment dims, MemorySegment num_dims, int num_shapes, MemorySegment storage, int storage_size, MemorySegment status) {
        var mh$ = TF_OperationGetAttrShapeList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrShapeList", oper, attr_name, dims, num_dims, num_shapes, storage, storage_size, status);
            }
            mh$.invokeExact(oper, attr_name, dims, num_dims, num_shapes, storage, storage_size, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrTensorShapeProto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrTensorShapeProto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProto(TF_Operation *oper, const char *attr_name, TF_Buffer *value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrTensorShapeProto$descriptor() {
        return TF_OperationGetAttrTensorShapeProto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProto(TF_Operation *oper, const char *attr_name, TF_Buffer *value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrTensorShapeProto$handle() {
        return TF_OperationGetAttrTensorShapeProto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProto(TF_Operation *oper, const char *attr_name, TF_Buffer *value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrTensorShapeProto$address() {
        return TF_OperationGetAttrTensorShapeProto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProto(TF_Operation *oper, const char *attr_name, TF_Buffer *value, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrTensorShapeProto(MemorySegment oper, MemorySegment attr_name, MemorySegment value, MemorySegment status) {
        var mh$ = TF_OperationGetAttrTensorShapeProto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrTensorShapeProto", oper, attr_name, value, status);
            }
            mh$.invokeExact(oper, attr_name, value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrTensorShapeProtoList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrTensorShapeProtoList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProtoList(TF_Operation *oper, const char *attr_name, TF_Buffer **values, int max_values, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrTensorShapeProtoList$descriptor() {
        return TF_OperationGetAttrTensorShapeProtoList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProtoList(TF_Operation *oper, const char *attr_name, TF_Buffer **values, int max_values, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrTensorShapeProtoList$handle() {
        return TF_OperationGetAttrTensorShapeProtoList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProtoList(TF_Operation *oper, const char *attr_name, TF_Buffer **values, int max_values, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrTensorShapeProtoList$address() {
        return TF_OperationGetAttrTensorShapeProtoList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorShapeProtoList(TF_Operation *oper, const char *attr_name, TF_Buffer **values, int max_values, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrTensorShapeProtoList(MemorySegment oper, MemorySegment attr_name, MemorySegment values, int max_values, MemorySegment status) {
        var mh$ = TF_OperationGetAttrTensorShapeProtoList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrTensorShapeProtoList", oper, attr_name, values, max_values, status);
            }
            mh$.invokeExact(oper, attr_name, values, max_values, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrTensor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrTensor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensor(TF_Operation *oper, const char *attr_name, TF_Tensor **value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrTensor$descriptor() {
        return TF_OperationGetAttrTensor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensor(TF_Operation *oper, const char *attr_name, TF_Tensor **value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrTensor$handle() {
        return TF_OperationGetAttrTensor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensor(TF_Operation *oper, const char *attr_name, TF_Tensor **value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrTensor$address() {
        return TF_OperationGetAttrTensor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensor(TF_Operation *oper, const char *attr_name, TF_Tensor **value, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrTensor(MemorySegment oper, MemorySegment attr_name, MemorySegment value, MemorySegment status) {
        var mh$ = TF_OperationGetAttrTensor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrTensor", oper, attr_name, value, status);
            }
            mh$.invokeExact(oper, attr_name, value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrTensorList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrTensorList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorList(TF_Operation *oper, const char *attr_name, TF_Tensor **values, int max_values, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrTensorList$descriptor() {
        return TF_OperationGetAttrTensorList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorList(TF_Operation *oper, const char *attr_name, TF_Tensor **values, int max_values, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrTensorList$handle() {
        return TF_OperationGetAttrTensorList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorList(TF_Operation *oper, const char *attr_name, TF_Tensor **values, int max_values, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrTensorList$address() {
        return TF_OperationGetAttrTensorList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrTensorList(TF_Operation *oper, const char *attr_name, TF_Tensor **values, int max_values, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrTensorList(MemorySegment oper, MemorySegment attr_name, MemorySegment values, int max_values, MemorySegment status) {
        var mh$ = TF_OperationGetAttrTensorList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrTensorList", oper, attr_name, values, max_values, status);
            }
            mh$.invokeExact(oper, attr_name, values, max_values, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrValueProto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrValueProto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrValueProto(TF_Operation *oper, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrValueProto$descriptor() {
        return TF_OperationGetAttrValueProto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrValueProto(TF_Operation *oper, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrValueProto$handle() {
        return TF_OperationGetAttrValueProto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrValueProto(TF_Operation *oper, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrValueProto$address() {
        return TF_OperationGetAttrValueProto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrValueProto(TF_Operation *oper, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrValueProto(MemorySegment oper, MemorySegment attr_name, MemorySegment output_attr_value, MemorySegment status) {
        var mh$ = TF_OperationGetAttrValueProto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrValueProto", oper, attr_name, output_attr_value, status);
            }
            mh$.invokeExact(oper, attr_name, output_attr_value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetNumAttrs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetNumAttrs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationGetNumAttrs(TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_OperationGetNumAttrs$descriptor() {
        return TF_OperationGetNumAttrs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationGetNumAttrs(TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_OperationGetNumAttrs$handle() {
        return TF_OperationGetNumAttrs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationGetNumAttrs(TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_OperationGetNumAttrs$address() {
        return TF_OperationGetNumAttrs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationGetNumAttrs(TF_Operation *oper)
     * }
     */
    public static int TF_OperationGetNumAttrs(MemorySegment oper) {
        var mh$ = TF_OperationGetNumAttrs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetNumAttrs", oper);
            }
            return (int)mh$.invokeExact(oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrNameLength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrNameLength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_OperationGetAttrNameLength(TF_Operation *oper, int i)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrNameLength$descriptor() {
        return TF_OperationGetAttrNameLength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_OperationGetAttrNameLength(TF_Operation *oper, int i)
     * }
     */
    public static MethodHandle TF_OperationGetAttrNameLength$handle() {
        return TF_OperationGetAttrNameLength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_OperationGetAttrNameLength(TF_Operation *oper, int i)
     * }
     */
    public static MemorySegment TF_OperationGetAttrNameLength$address() {
        return TF_OperationGetAttrNameLength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_OperationGetAttrNameLength(TF_Operation *oper, int i)
     * }
     */
    public static int TF_OperationGetAttrNameLength(MemorySegment oper, int i) {
        var mh$ = TF_OperationGetAttrNameLength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrNameLength", oper, i);
            }
            return (int)mh$.invokeExact(oper, i);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationGetAttrName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationGetAttrName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrName(TF_Operation *oper, int i, char *output, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationGetAttrName$descriptor() {
        return TF_OperationGetAttrName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrName(TF_Operation *oper, int i, char *output, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationGetAttrName$handle() {
        return TF_OperationGetAttrName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrName(TF_Operation *oper, int i, char *output, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationGetAttrName$address() {
        return TF_OperationGetAttrName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationGetAttrName(TF_Operation *oper, int i, char *output, TF_Status *status)
     * }
     */
    public static void TF_OperationGetAttrName(MemorySegment oper, int i, MemorySegment output, MemorySegment status) {
        var mh$ = TF_OperationGetAttrName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationGetAttrName", oper, i, output, status);
            }
            mh$.invokeExact(oper, i, output, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphOperationByName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphOperationByName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphOperationByName(TF_Graph *graph, const char *oper_name)
     * }
     */
    public static FunctionDescriptor TF_GraphOperationByName$descriptor() {
        return TF_GraphOperationByName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphOperationByName(TF_Graph *graph, const char *oper_name)
     * }
     */
    public static MethodHandle TF_GraphOperationByName$handle() {
        return TF_GraphOperationByName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphOperationByName(TF_Graph *graph, const char *oper_name)
     * }
     */
    public static MemorySegment TF_GraphOperationByName$address() {
        return TF_GraphOperationByName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphOperationByName(TF_Graph *graph, const char *oper_name)
     * }
     */
    public static MemorySegment TF_GraphOperationByName(MemorySegment graph, MemorySegment oper_name) {
        var mh$ = TF_GraphOperationByName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphOperationByName", graph, oper_name);
            }
            return (MemorySegment)mh$.invokeExact(graph, oper_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphNextOperation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphNextOperation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphNextOperation(TF_Graph *graph, size_t *pos)
     * }
     */
    public static FunctionDescriptor TF_GraphNextOperation$descriptor() {
        return TF_GraphNextOperation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphNextOperation(TF_Graph *graph, size_t *pos)
     * }
     */
    public static MethodHandle TF_GraphNextOperation$handle() {
        return TF_GraphNextOperation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphNextOperation(TF_Graph *graph, size_t *pos)
     * }
     */
    public static MemorySegment TF_GraphNextOperation$address() {
        return TF_GraphNextOperation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Operation *TF_GraphNextOperation(TF_Graph *graph, size_t *pos)
     * }
     */
    public static MemorySegment TF_GraphNextOperation(MemorySegment graph, MemorySegment pos) {
        var mh$ = TF_GraphNextOperation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphNextOperation", graph, pos);
            }
            return (MemorySegment)mh$.invokeExact(graph, pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphToGraphDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphToGraphDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphToGraphDef(TF_Graph *graph, TF_Buffer *output_graph_def, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphToGraphDef$descriptor() {
        return TF_GraphToGraphDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphToGraphDef(TF_Graph *graph, TF_Buffer *output_graph_def, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphToGraphDef$handle() {
        return TF_GraphToGraphDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphToGraphDef(TF_Graph *graph, TF_Buffer *output_graph_def, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphToGraphDef$address() {
        return TF_GraphToGraphDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphToGraphDef(TF_Graph *graph, TF_Buffer *output_graph_def, TF_Status *status)
     * }
     */
    public static void TF_GraphToGraphDef(MemorySegment graph, MemorySegment output_graph_def, MemorySegment status) {
        var mh$ = TF_GraphToGraphDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphToGraphDef", graph, output_graph_def, status);
            }
            mh$.invokeExact(graph, output_graph_def, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphGetOpDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphGetOpDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphGetOpDef(TF_Graph *graph, const char *op_name, TF_Buffer *output_op_def, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphGetOpDef$descriptor() {
        return TF_GraphGetOpDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphGetOpDef(TF_Graph *graph, const char *op_name, TF_Buffer *output_op_def, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphGetOpDef$handle() {
        return TF_GraphGetOpDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphGetOpDef(TF_Graph *graph, const char *op_name, TF_Buffer *output_op_def, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphGetOpDef$address() {
        return TF_GraphGetOpDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphGetOpDef(TF_Graph *graph, const char *op_name, TF_Buffer *output_op_def, TF_Status *status)
     * }
     */
    public static void TF_GraphGetOpDef(MemorySegment graph, MemorySegment op_name, MemorySegment output_op_def, MemorySegment status) {
        var mh$ = TF_GraphGetOpDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphGetOpDef", graph, op_name, output_op_def, status);
            }
            mh$.invokeExact(graph, op_name, output_op_def, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphVersions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphVersions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphVersions(TF_Graph *graph, TF_Buffer *output_version_def, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphVersions$descriptor() {
        return TF_GraphVersions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphVersions(TF_Graph *graph, TF_Buffer *output_version_def, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphVersions$handle() {
        return TF_GraphVersions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphVersions(TF_Graph *graph, TF_Buffer *output_version_def, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphVersions$address() {
        return TF_GraphVersions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphVersions(TF_Graph *graph, TF_Buffer *output_version_def, TF_Status *status)
     * }
     */
    public static void TF_GraphVersions(MemorySegment graph, MemorySegment output_version_def, MemorySegment status) {
        var mh$ = TF_GraphVersions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphVersions", graph, output_version_def, status);
            }
            mh$.invokeExact(graph, output_version_def, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewImportGraphDefOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewImportGraphDefOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_ImportGraphDefOptions *TF_NewImportGraphDefOptions()
     * }
     */
    public static FunctionDescriptor TF_NewImportGraphDefOptions$descriptor() {
        return TF_NewImportGraphDefOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_ImportGraphDefOptions *TF_NewImportGraphDefOptions()
     * }
     */
    public static MethodHandle TF_NewImportGraphDefOptions$handle() {
        return TF_NewImportGraphDefOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_ImportGraphDefOptions *TF_NewImportGraphDefOptions()
     * }
     */
    public static MemorySegment TF_NewImportGraphDefOptions$address() {
        return TF_NewImportGraphDefOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_ImportGraphDefOptions *TF_NewImportGraphDefOptions()
     * }
     */
    public static MemorySegment TF_NewImportGraphDefOptions() {
        var mh$ = TF_NewImportGraphDefOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewImportGraphDefOptions");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteImportGraphDefOptions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteImportGraphDefOptions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefOptions(TF_ImportGraphDefOptions *opts)
     * }
     */
    public static FunctionDescriptor TF_DeleteImportGraphDefOptions$descriptor() {
        return TF_DeleteImportGraphDefOptions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefOptions(TF_ImportGraphDefOptions *opts)
     * }
     */
    public static MethodHandle TF_DeleteImportGraphDefOptions$handle() {
        return TF_DeleteImportGraphDefOptions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefOptions(TF_ImportGraphDefOptions *opts)
     * }
     */
    public static MemorySegment TF_DeleteImportGraphDefOptions$address() {
        return TF_DeleteImportGraphDefOptions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefOptions(TF_ImportGraphDefOptions *opts)
     * }
     */
    public static void TF_DeleteImportGraphDefOptions(MemorySegment opts) {
        var mh$ = TF_DeleteImportGraphDefOptions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteImportGraphDefOptions", opts);
            }
            mh$.invokeExact(opts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsSetPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsSetPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetPrefix(TF_ImportGraphDefOptions *opts, const char *prefix)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsSetPrefix$descriptor() {
        return TF_ImportGraphDefOptionsSetPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetPrefix(TF_ImportGraphDefOptions *opts, const char *prefix)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsSetPrefix$handle() {
        return TF_ImportGraphDefOptionsSetPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetPrefix(TF_ImportGraphDefOptions *opts, const char *prefix)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsSetPrefix$address() {
        return TF_ImportGraphDefOptionsSetPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetPrefix(TF_ImportGraphDefOptions *opts, const char *prefix)
     * }
     */
    public static void TF_ImportGraphDefOptionsSetPrefix(MemorySegment opts, MemorySegment prefix) {
        var mh$ = TF_ImportGraphDefOptionsSetPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsSetPrefix", opts, prefix);
            }
            mh$.invokeExact(opts, prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsSetDefaultDevice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsSetDefaultDevice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetDefaultDevice(TF_ImportGraphDefOptions *opts, const char *device)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsSetDefaultDevice$descriptor() {
        return TF_ImportGraphDefOptionsSetDefaultDevice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetDefaultDevice(TF_ImportGraphDefOptions *opts, const char *device)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsSetDefaultDevice$handle() {
        return TF_ImportGraphDefOptionsSetDefaultDevice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetDefaultDevice(TF_ImportGraphDefOptions *opts, const char *device)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsSetDefaultDevice$address() {
        return TF_ImportGraphDefOptionsSetDefaultDevice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetDefaultDevice(TF_ImportGraphDefOptions *opts, const char *device)
     * }
     */
    public static void TF_ImportGraphDefOptionsSetDefaultDevice(MemorySegment opts, MemorySegment device) {
        var mh$ = TF_ImportGraphDefOptionsSetDefaultDevice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsSetDefaultDevice", opts, device);
            }
            mh$.invokeExact(opts, device);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsSetUniquifyNames {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsSetUniquifyNames");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyNames(TF_ImportGraphDefOptions *opts, unsigned char uniquify_names)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsSetUniquifyNames$descriptor() {
        return TF_ImportGraphDefOptionsSetUniquifyNames.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyNames(TF_ImportGraphDefOptions *opts, unsigned char uniquify_names)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsSetUniquifyNames$handle() {
        return TF_ImportGraphDefOptionsSetUniquifyNames.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyNames(TF_ImportGraphDefOptions *opts, unsigned char uniquify_names)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsSetUniquifyNames$address() {
        return TF_ImportGraphDefOptionsSetUniquifyNames.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyNames(TF_ImportGraphDefOptions *opts, unsigned char uniquify_names)
     * }
     */
    public static void TF_ImportGraphDefOptionsSetUniquifyNames(MemorySegment opts, byte uniquify_names) {
        var mh$ = TF_ImportGraphDefOptionsSetUniquifyNames.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsSetUniquifyNames", opts, uniquify_names);
            }
            mh$.invokeExact(opts, uniquify_names);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsSetUniquifyPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_CHAR
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsSetUniquifyPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyPrefix(TF_ImportGraphDefOptions *opts, unsigned char uniquify_prefix)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsSetUniquifyPrefix$descriptor() {
        return TF_ImportGraphDefOptionsSetUniquifyPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyPrefix(TF_ImportGraphDefOptions *opts, unsigned char uniquify_prefix)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsSetUniquifyPrefix$handle() {
        return TF_ImportGraphDefOptionsSetUniquifyPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyPrefix(TF_ImportGraphDefOptions *opts, unsigned char uniquify_prefix)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsSetUniquifyPrefix$address() {
        return TF_ImportGraphDefOptionsSetUniquifyPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsSetUniquifyPrefix(TF_ImportGraphDefOptions *opts, unsigned char uniquify_prefix)
     * }
     */
    public static void TF_ImportGraphDefOptionsSetUniquifyPrefix(MemorySegment opts, byte uniquify_prefix) {
        var mh$ = TF_ImportGraphDefOptionsSetUniquifyPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsSetUniquifyPrefix", opts, uniquify_prefix);
            }
            mh$.invokeExact(opts, uniquify_prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsAddInputMapping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            TF_Output.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsAddInputMapping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddInputMapping(TF_ImportGraphDefOptions *opts, const char *src_name, int src_index, TF_Output dst)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsAddInputMapping$descriptor() {
        return TF_ImportGraphDefOptionsAddInputMapping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddInputMapping(TF_ImportGraphDefOptions *opts, const char *src_name, int src_index, TF_Output dst)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsAddInputMapping$handle() {
        return TF_ImportGraphDefOptionsAddInputMapping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddInputMapping(TF_ImportGraphDefOptions *opts, const char *src_name, int src_index, TF_Output dst)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsAddInputMapping$address() {
        return TF_ImportGraphDefOptionsAddInputMapping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddInputMapping(TF_ImportGraphDefOptions *opts, const char *src_name, int src_index, TF_Output dst)
     * }
     */
    public static void TF_ImportGraphDefOptionsAddInputMapping(MemorySegment opts, MemorySegment src_name, int src_index, MemorySegment dst) {
        var mh$ = TF_ImportGraphDefOptionsAddInputMapping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsAddInputMapping", opts, src_name, src_index, dst);
            }
            mh$.invokeExact(opts, src_name, src_index, dst);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsRemapControlDependency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsRemapControlDependency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsRemapControlDependency(TF_ImportGraphDefOptions *opts, const char *src_name, TF_Operation *dst)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsRemapControlDependency$descriptor() {
        return TF_ImportGraphDefOptionsRemapControlDependency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsRemapControlDependency(TF_ImportGraphDefOptions *opts, const char *src_name, TF_Operation *dst)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsRemapControlDependency$handle() {
        return TF_ImportGraphDefOptionsRemapControlDependency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsRemapControlDependency(TF_ImportGraphDefOptions *opts, const char *src_name, TF_Operation *dst)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsRemapControlDependency$address() {
        return TF_ImportGraphDefOptionsRemapControlDependency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsRemapControlDependency(TF_ImportGraphDefOptions *opts, const char *src_name, TF_Operation *dst)
     * }
     */
    public static void TF_ImportGraphDefOptionsRemapControlDependency(MemorySegment opts, MemorySegment src_name, MemorySegment dst) {
        var mh$ = TF_ImportGraphDefOptionsRemapControlDependency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsRemapControlDependency", opts, src_name, dst);
            }
            mh$.invokeExact(opts, src_name, dst);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsAddControlDependency {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsAddControlDependency");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddControlDependency(TF_ImportGraphDefOptions *opts, TF_Operation *oper)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsAddControlDependency$descriptor() {
        return TF_ImportGraphDefOptionsAddControlDependency.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddControlDependency(TF_ImportGraphDefOptions *opts, TF_Operation *oper)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsAddControlDependency$handle() {
        return TF_ImportGraphDefOptionsAddControlDependency.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddControlDependency(TF_ImportGraphDefOptions *opts, TF_Operation *oper)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsAddControlDependency$address() {
        return TF_ImportGraphDefOptionsAddControlDependency.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddControlDependency(TF_ImportGraphDefOptions *opts, TF_Operation *oper)
     * }
     */
    public static void TF_ImportGraphDefOptionsAddControlDependency(MemorySegment opts, MemorySegment oper) {
        var mh$ = TF_ImportGraphDefOptionsAddControlDependency.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsAddControlDependency", opts, oper);
            }
            mh$.invokeExact(opts, oper);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsAddReturnOutput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsAddReturnOutput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOutput(TF_ImportGraphDefOptions *opts, const char *oper_name, int index)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsAddReturnOutput$descriptor() {
        return TF_ImportGraphDefOptionsAddReturnOutput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOutput(TF_ImportGraphDefOptions *opts, const char *oper_name, int index)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsAddReturnOutput$handle() {
        return TF_ImportGraphDefOptionsAddReturnOutput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOutput(TF_ImportGraphDefOptions *opts, const char *oper_name, int index)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsAddReturnOutput$address() {
        return TF_ImportGraphDefOptionsAddReturnOutput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOutput(TF_ImportGraphDefOptions *opts, const char *oper_name, int index)
     * }
     */
    public static void TF_ImportGraphDefOptionsAddReturnOutput(MemorySegment opts, MemorySegment oper_name, int index) {
        var mh$ = TF_ImportGraphDefOptionsAddReturnOutput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsAddReturnOutput", opts, oper_name, index);
            }
            mh$.invokeExact(opts, oper_name, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsNumReturnOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsNumReturnOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOutputs(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsNumReturnOutputs$descriptor() {
        return TF_ImportGraphDefOptionsNumReturnOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOutputs(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsNumReturnOutputs$handle() {
        return TF_ImportGraphDefOptionsNumReturnOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOutputs(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsNumReturnOutputs$address() {
        return TF_ImportGraphDefOptionsNumReturnOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOutputs(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static int TF_ImportGraphDefOptionsNumReturnOutputs(MemorySegment opts) {
        var mh$ = TF_ImportGraphDefOptionsNumReturnOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsNumReturnOutputs", opts);
            }
            return (int)mh$.invokeExact(opts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsAddReturnOperation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsAddReturnOperation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOperation(TF_ImportGraphDefOptions *opts, const char *oper_name)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsAddReturnOperation$descriptor() {
        return TF_ImportGraphDefOptionsAddReturnOperation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOperation(TF_ImportGraphDefOptions *opts, const char *oper_name)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsAddReturnOperation$handle() {
        return TF_ImportGraphDefOptionsAddReturnOperation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOperation(TF_ImportGraphDefOptions *opts, const char *oper_name)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsAddReturnOperation$address() {
        return TF_ImportGraphDefOptionsAddReturnOperation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefOptionsAddReturnOperation(TF_ImportGraphDefOptions *opts, const char *oper_name)
     * }
     */
    public static void TF_ImportGraphDefOptionsAddReturnOperation(MemorySegment opts, MemorySegment oper_name) {
        var mh$ = TF_ImportGraphDefOptionsAddReturnOperation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsAddReturnOperation", opts, oper_name);
            }
            mh$.invokeExact(opts, oper_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefOptionsNumReturnOperations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefOptionsNumReturnOperations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOperations(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefOptionsNumReturnOperations$descriptor() {
        return TF_ImportGraphDefOptionsNumReturnOperations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOperations(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static MethodHandle TF_ImportGraphDefOptionsNumReturnOperations$handle() {
        return TF_ImportGraphDefOptionsNumReturnOperations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOperations(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static MemorySegment TF_ImportGraphDefOptionsNumReturnOperations$address() {
        return TF_ImportGraphDefOptionsNumReturnOperations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_ImportGraphDefOptionsNumReturnOperations(const TF_ImportGraphDefOptions *opts)
     * }
     */
    public static int TF_ImportGraphDefOptionsNumReturnOperations(MemorySegment opts) {
        var mh$ = TF_ImportGraphDefOptionsNumReturnOperations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefOptionsNumReturnOperations", opts);
            }
            return (int)mh$.invokeExact(opts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefResultsReturnOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefResultsReturnOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOutputs(TF_ImportGraphDefResults *results, int *num_outputs, TF_Output **outputs)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefResultsReturnOutputs$descriptor() {
        return TF_ImportGraphDefResultsReturnOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOutputs(TF_ImportGraphDefResults *results, int *num_outputs, TF_Output **outputs)
     * }
     */
    public static MethodHandle TF_ImportGraphDefResultsReturnOutputs$handle() {
        return TF_ImportGraphDefResultsReturnOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOutputs(TF_ImportGraphDefResults *results, int *num_outputs, TF_Output **outputs)
     * }
     */
    public static MemorySegment TF_ImportGraphDefResultsReturnOutputs$address() {
        return TF_ImportGraphDefResultsReturnOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOutputs(TF_ImportGraphDefResults *results, int *num_outputs, TF_Output **outputs)
     * }
     */
    public static void TF_ImportGraphDefResultsReturnOutputs(MemorySegment results, MemorySegment num_outputs, MemorySegment outputs) {
        var mh$ = TF_ImportGraphDefResultsReturnOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefResultsReturnOutputs", results, num_outputs, outputs);
            }
            mh$.invokeExact(results, num_outputs, outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefResultsReturnOperations {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefResultsReturnOperations");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOperations(TF_ImportGraphDefResults *results, int *num_opers, TF_Operation ***opers)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefResultsReturnOperations$descriptor() {
        return TF_ImportGraphDefResultsReturnOperations.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOperations(TF_ImportGraphDefResults *results, int *num_opers, TF_Operation ***opers)
     * }
     */
    public static MethodHandle TF_ImportGraphDefResultsReturnOperations$handle() {
        return TF_ImportGraphDefResultsReturnOperations.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOperations(TF_ImportGraphDefResults *results, int *num_opers, TF_Operation ***opers)
     * }
     */
    public static MemorySegment TF_ImportGraphDefResultsReturnOperations$address() {
        return TF_ImportGraphDefResultsReturnOperations.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsReturnOperations(TF_ImportGraphDefResults *results, int *num_opers, TF_Operation ***opers)
     * }
     */
    public static void TF_ImportGraphDefResultsReturnOperations(MemorySegment results, MemorySegment num_opers, MemorySegment opers) {
        var mh$ = TF_ImportGraphDefResultsReturnOperations.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefResultsReturnOperations", results, num_opers, opers);
            }
            mh$.invokeExact(results, num_opers, opers);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ImportGraphDefResultsMissingUnusedInputMappings {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ImportGraphDefResultsMissingUnusedInputMappings");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsMissingUnusedInputMappings(TF_ImportGraphDefResults *results, int *num_missing_unused_input_mappings, const char ***src_names, int **src_indexes)
     * }
     */
    public static FunctionDescriptor TF_ImportGraphDefResultsMissingUnusedInputMappings$descriptor() {
        return TF_ImportGraphDefResultsMissingUnusedInputMappings.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsMissingUnusedInputMappings(TF_ImportGraphDefResults *results, int *num_missing_unused_input_mappings, const char ***src_names, int **src_indexes)
     * }
     */
    public static MethodHandle TF_ImportGraphDefResultsMissingUnusedInputMappings$handle() {
        return TF_ImportGraphDefResultsMissingUnusedInputMappings.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsMissingUnusedInputMappings(TF_ImportGraphDefResults *results, int *num_missing_unused_input_mappings, const char ***src_names, int **src_indexes)
     * }
     */
    public static MemorySegment TF_ImportGraphDefResultsMissingUnusedInputMappings$address() {
        return TF_ImportGraphDefResultsMissingUnusedInputMappings.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ImportGraphDefResultsMissingUnusedInputMappings(TF_ImportGraphDefResults *results, int *num_missing_unused_input_mappings, const char ***src_names, int **src_indexes)
     * }
     */
    public static void TF_ImportGraphDefResultsMissingUnusedInputMappings(MemorySegment results, MemorySegment num_missing_unused_input_mappings, MemorySegment src_names, MemorySegment src_indexes) {
        var mh$ = TF_ImportGraphDefResultsMissingUnusedInputMappings.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ImportGraphDefResultsMissingUnusedInputMappings", results, num_missing_unused_input_mappings, src_names, src_indexes);
            }
            mh$.invokeExact(results, num_missing_unused_input_mappings, src_names, src_indexes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteImportGraphDefResults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteImportGraphDefResults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefResults(TF_ImportGraphDefResults *results)
     * }
     */
    public static FunctionDescriptor TF_DeleteImportGraphDefResults$descriptor() {
        return TF_DeleteImportGraphDefResults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefResults(TF_ImportGraphDefResults *results)
     * }
     */
    public static MethodHandle TF_DeleteImportGraphDefResults$handle() {
        return TF_DeleteImportGraphDefResults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefResults(TF_ImportGraphDefResults *results)
     * }
     */
    public static MemorySegment TF_DeleteImportGraphDefResults$address() {
        return TF_DeleteImportGraphDefResults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteImportGraphDefResults(TF_ImportGraphDefResults *results)
     * }
     */
    public static void TF_DeleteImportGraphDefResults(MemorySegment results) {
        var mh$ = TF_DeleteImportGraphDefResults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteImportGraphDefResults", results);
            }
            mh$.invokeExact(results);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphImportGraphDefWithResults {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphImportGraphDefWithResults");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_ImportGraphDefResults *TF_GraphImportGraphDefWithResults(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphImportGraphDefWithResults$descriptor() {
        return TF_GraphImportGraphDefWithResults.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_ImportGraphDefResults *TF_GraphImportGraphDefWithResults(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphImportGraphDefWithResults$handle() {
        return TF_GraphImportGraphDefWithResults.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_ImportGraphDefResults *TF_GraphImportGraphDefWithResults(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphImportGraphDefWithResults$address() {
        return TF_GraphImportGraphDefWithResults.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_ImportGraphDefResults *TF_GraphImportGraphDefWithResults(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphImportGraphDefWithResults(MemorySegment graph, MemorySegment graph_def, MemorySegment options, MemorySegment status) {
        var mh$ = TF_GraphImportGraphDefWithResults.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphImportGraphDefWithResults", graph, graph_def, options, status);
            }
            return (MemorySegment)mh$.invokeExact(graph, graph_def, options, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphImportGraphDefWithReturnOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphImportGraphDefWithReturnOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDefWithReturnOutputs(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Output *return_outputs, int num_return_outputs, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphImportGraphDefWithReturnOutputs$descriptor() {
        return TF_GraphImportGraphDefWithReturnOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDefWithReturnOutputs(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Output *return_outputs, int num_return_outputs, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphImportGraphDefWithReturnOutputs$handle() {
        return TF_GraphImportGraphDefWithReturnOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDefWithReturnOutputs(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Output *return_outputs, int num_return_outputs, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphImportGraphDefWithReturnOutputs$address() {
        return TF_GraphImportGraphDefWithReturnOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDefWithReturnOutputs(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Output *return_outputs, int num_return_outputs, TF_Status *status)
     * }
     */
    public static void TF_GraphImportGraphDefWithReturnOutputs(MemorySegment graph, MemorySegment graph_def, MemorySegment options, MemorySegment return_outputs, int num_return_outputs, MemorySegment status) {
        var mh$ = TF_GraphImportGraphDefWithReturnOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphImportGraphDefWithReturnOutputs", graph, graph_def, options, return_outputs, num_return_outputs, status);
            }
            mh$.invokeExact(graph, graph_def, options, return_outputs, num_return_outputs, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphImportGraphDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphImportGraphDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDef(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphImportGraphDef$descriptor() {
        return TF_GraphImportGraphDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDef(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphImportGraphDef$handle() {
        return TF_GraphImportGraphDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDef(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphImportGraphDef$address() {
        return TF_GraphImportGraphDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphImportGraphDef(TF_Graph *graph, const TF_Buffer *graph_def, const TF_ImportGraphDefOptions *options, TF_Status *status)
     * }
     */
    public static void TF_GraphImportGraphDef(MemorySegment graph, MemorySegment graph_def, MemorySegment options, MemorySegment status) {
        var mh$ = TF_GraphImportGraphDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphImportGraphDef", graph, graph_def, options, status);
            }
            mh$.invokeExact(graph, graph_def, options, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphCopyFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphCopyFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_GraphCopyFunction(TF_Graph *g, const TF_Function *func, const TF_Function *grad, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphCopyFunction$descriptor() {
        return TF_GraphCopyFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_GraphCopyFunction(TF_Graph *g, const TF_Function *func, const TF_Function *grad, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphCopyFunction$handle() {
        return TF_GraphCopyFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_GraphCopyFunction(TF_Graph *g, const TF_Function *func, const TF_Function *grad, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphCopyFunction$address() {
        return TF_GraphCopyFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_GraphCopyFunction(TF_Graph *g, const TF_Function *func, const TF_Function *grad, TF_Status *status)
     * }
     */
    public static void TF_GraphCopyFunction(MemorySegment g, MemorySegment func, MemorySegment grad, MemorySegment status) {
        var mh$ = TF_GraphCopyFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphCopyFunction", g, func, grad, status);
            }
            mh$.invokeExact(g, func, grad, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphNumFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphNumFunctions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_GraphNumFunctions(TF_Graph *g)
     * }
     */
    public static FunctionDescriptor TF_GraphNumFunctions$descriptor() {
        return TF_GraphNumFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_GraphNumFunctions(TF_Graph *g)
     * }
     */
    public static MethodHandle TF_GraphNumFunctions$handle() {
        return TF_GraphNumFunctions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_GraphNumFunctions(TF_Graph *g)
     * }
     */
    public static MemorySegment TF_GraphNumFunctions$address() {
        return TF_GraphNumFunctions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_GraphNumFunctions(TF_Graph *g)
     * }
     */
    public static int TF_GraphNumFunctions(MemorySegment g) {
        var mh$ = TF_GraphNumFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphNumFunctions", g);
            }
            return (int)mh$.invokeExact(g);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphGetFunctions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphGetFunctions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_GraphGetFunctions(TF_Graph *g, TF_Function **funcs, int max_func, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphGetFunctions$descriptor() {
        return TF_GraphGetFunctions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_GraphGetFunctions(TF_Graph *g, TF_Function **funcs, int max_func, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphGetFunctions$handle() {
        return TF_GraphGetFunctions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_GraphGetFunctions(TF_Graph *g, TF_Function **funcs, int max_func, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphGetFunctions$address() {
        return TF_GraphGetFunctions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_GraphGetFunctions(TF_Graph *g, TF_Function **funcs, int max_func, TF_Status *status)
     * }
     */
    public static int TF_GraphGetFunctions(MemorySegment g, MemorySegment funcs, int max_func, MemorySegment status) {
        var mh$ = TF_GraphGetFunctions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphGetFunctions", g, funcs, max_func, status);
            }
            return (int)mh$.invokeExact(g, funcs, max_func, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_OperationToNodeDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_OperationToNodeDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_OperationToNodeDef(TF_Operation *oper, TF_Buffer *output_node_def, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_OperationToNodeDef$descriptor() {
        return TF_OperationToNodeDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_OperationToNodeDef(TF_Operation *oper, TF_Buffer *output_node_def, TF_Status *status)
     * }
     */
    public static MethodHandle TF_OperationToNodeDef$handle() {
        return TF_OperationToNodeDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_OperationToNodeDef(TF_Operation *oper, TF_Buffer *output_node_def, TF_Status *status)
     * }
     */
    public static MemorySegment TF_OperationToNodeDef$address() {
        return TF_OperationToNodeDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_OperationToNodeDef(TF_Operation *oper, TF_Buffer *output_node_def, TF_Status *status)
     * }
     */
    public static void TF_OperationToNodeDef(MemorySegment oper, MemorySegment output_node_def, MemorySegment status) {
        var mh$ = TF_OperationToNodeDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_OperationToNodeDef", oper, output_node_def, status);
            }
            mh$.invokeExact(oper, output_node_def, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewWhile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TF_WhileParams.layout(),
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewWhile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_WhileParams TF_NewWhile(TF_Graph *g, TF_Output *inputs, int ninputs, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_NewWhile$descriptor() {
        return TF_NewWhile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_WhileParams TF_NewWhile(TF_Graph *g, TF_Output *inputs, int ninputs, TF_Status *status)
     * }
     */
    public static MethodHandle TF_NewWhile$handle() {
        return TF_NewWhile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_WhileParams TF_NewWhile(TF_Graph *g, TF_Output *inputs, int ninputs, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewWhile$address() {
        return TF_NewWhile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_WhileParams TF_NewWhile(TF_Graph *g, TF_Output *inputs, int ninputs, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewWhile(SegmentAllocator allocator, MemorySegment g, MemorySegment inputs, int ninputs, MemorySegment status) {
        var mh$ = TF_NewWhile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewWhile", allocator, g, inputs, ninputs, status);
            }
            return (MemorySegment)mh$.invokeExact(allocator, g, inputs, ninputs, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FinishWhile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FinishWhile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_FinishWhile(const TF_WhileParams *params, TF_Status *status, TF_Output *outputs)
     * }
     */
    public static FunctionDescriptor TF_FinishWhile$descriptor() {
        return TF_FinishWhile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_FinishWhile(const TF_WhileParams *params, TF_Status *status, TF_Output *outputs)
     * }
     */
    public static MethodHandle TF_FinishWhile$handle() {
        return TF_FinishWhile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_FinishWhile(const TF_WhileParams *params, TF_Status *status, TF_Output *outputs)
     * }
     */
    public static MemorySegment TF_FinishWhile$address() {
        return TF_FinishWhile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_FinishWhile(const TF_WhileParams *params, TF_Status *status, TF_Output *outputs)
     * }
     */
    public static void TF_FinishWhile(MemorySegment params, MemorySegment status, MemorySegment outputs) {
        var mh$ = TF_FinishWhile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FinishWhile", params, status, outputs);
            }
            mh$.invokeExact(params, status, outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_AbortWhile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_AbortWhile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_AbortWhile(const TF_WhileParams *params)
     * }
     */
    public static FunctionDescriptor TF_AbortWhile$descriptor() {
        return TF_AbortWhile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_AbortWhile(const TF_WhileParams *params)
     * }
     */
    public static MethodHandle TF_AbortWhile$handle() {
        return TF_AbortWhile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_AbortWhile(const TF_WhileParams *params)
     * }
     */
    public static MemorySegment TF_AbortWhile$address() {
        return TF_AbortWhile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_AbortWhile(const TF_WhileParams *params)
     * }
     */
    public static void TF_AbortWhile(MemorySegment params) {
        var mh$ = TF_AbortWhile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_AbortWhile", params);
            }
            mh$.invokeExact(params);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_AddGradients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_AddGradients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TF_AddGradients(TF_Graph *g, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static FunctionDescriptor TF_AddGradients$descriptor() {
        return TF_AddGradients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TF_AddGradients(TF_Graph *g, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static MethodHandle TF_AddGradients$handle() {
        return TF_AddGradients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TF_AddGradients(TF_Graph *g, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static MemorySegment TF_AddGradients$address() {
        return TF_AddGradients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TF_AddGradients(TF_Graph *g, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static void TF_AddGradients(MemorySegment g, MemorySegment y, int ny, MemorySegment x, int nx, MemorySegment dx, MemorySegment status, MemorySegment dy) {
        var mh$ = TF_AddGradients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_AddGradients", g, y, ny, x, nx, dx, status, dy);
            }
            mh$.invokeExact(g, y, ny, x, nx, dx, status, dy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_AddGradientsWithPrefix {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_AddGradientsWithPrefix");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TF_AddGradientsWithPrefix(TF_Graph *g, const char *prefix, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static FunctionDescriptor TF_AddGradientsWithPrefix$descriptor() {
        return TF_AddGradientsWithPrefix.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TF_AddGradientsWithPrefix(TF_Graph *g, const char *prefix, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static MethodHandle TF_AddGradientsWithPrefix$handle() {
        return TF_AddGradientsWithPrefix.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TF_AddGradientsWithPrefix(TF_Graph *g, const char *prefix, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static MemorySegment TF_AddGradientsWithPrefix$address() {
        return TF_AddGradientsWithPrefix.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TF_AddGradientsWithPrefix(TF_Graph *g, const char *prefix, TF_Output *y, int ny, TF_Output *x, int nx, TF_Output *dx, TF_Status *status, TF_Output *dy)
     * }
     */
    public static void TF_AddGradientsWithPrefix(MemorySegment g, MemorySegment prefix, MemorySegment y, int ny, MemorySegment x, int nx, MemorySegment dx, MemorySegment status, MemorySegment dy) {
        var mh$ = TF_AddGradientsWithPrefix.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_AddGradientsWithPrefix", g, prefix, y, ny, x, nx, dx, status, dy);
            }
            mh$.invokeExact(g, prefix, y, ny, x, nx, dx, status, dy);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphToFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_CHAR,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphToFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunction(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphToFunction$descriptor() {
        return TF_GraphToFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunction(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphToFunction$handle() {
        return TF_GraphToFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunction(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphToFunction$address() {
        return TF_GraphToFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunction(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphToFunction(MemorySegment fn_body, MemorySegment fn_name, byte append_hash_to_fn_name, int num_opers, MemorySegment opers, int ninputs, MemorySegment inputs, int noutputs, MemorySegment outputs, MemorySegment output_names, MemorySegment opts, MemorySegment description, MemorySegment status) {
        var mh$ = TF_GraphToFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphToFunction", fn_body, fn_name, append_hash_to_fn_name, num_opers, opers, ninputs, inputs, noutputs, outputs, output_names, opts, description, status);
            }
            return (MemorySegment)mh$.invokeExact(fn_body, fn_name, append_hash_to_fn_name, num_opers, opers, ninputs, inputs, noutputs, outputs, output_names, opts, description, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GraphToFunctionWithControlOutputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_CHAR,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GraphToFunctionWithControlOutputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunctionWithControlOutputs(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, int ncontrol_outputs, const TF_Operation *const *control_outputs, const char *const *control_output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GraphToFunctionWithControlOutputs$descriptor() {
        return TF_GraphToFunctionWithControlOutputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunctionWithControlOutputs(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, int ncontrol_outputs, const TF_Operation *const *control_outputs, const char *const *control_output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GraphToFunctionWithControlOutputs$handle() {
        return TF_GraphToFunctionWithControlOutputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunctionWithControlOutputs(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, int ncontrol_outputs, const TF_Operation *const *control_outputs, const char *const *control_output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphToFunctionWithControlOutputs$address() {
        return TF_GraphToFunctionWithControlOutputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Function *TF_GraphToFunctionWithControlOutputs(const TF_Graph *fn_body, const char *fn_name, unsigned char append_hash_to_fn_name, int num_opers, const TF_Operation *const *opers, int ninputs, const TF_Output *inputs, int noutputs, const TF_Output *outputs, const char *const *output_names, int ncontrol_outputs, const TF_Operation *const *control_outputs, const char *const *control_output_names, const TF_FunctionOptions *opts, const char *description, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GraphToFunctionWithControlOutputs(MemorySegment fn_body, MemorySegment fn_name, byte append_hash_to_fn_name, int num_opers, MemorySegment opers, int ninputs, MemorySegment inputs, int noutputs, MemorySegment outputs, MemorySegment output_names, int ncontrol_outputs, MemorySegment control_outputs, MemorySegment control_output_names, MemorySegment opts, MemorySegment description, MemorySegment status) {
        var mh$ = TF_GraphToFunctionWithControlOutputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GraphToFunctionWithControlOutputs", fn_body, fn_name, append_hash_to_fn_name, num_opers, opers, ninputs, inputs, noutputs, outputs, output_names, ncontrol_outputs, control_outputs, control_output_names, opts, description, status);
            }
            return (MemorySegment)mh$.invokeExact(fn_body, fn_name, append_hash_to_fn_name, num_opers, opers, ninputs, inputs, noutputs, outputs, output_names, ncontrol_outputs, control_outputs, control_output_names, opts, description, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FunctionName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FunctionName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_FunctionName(TF_Function *func)
     * }
     */
    public static FunctionDescriptor TF_FunctionName$descriptor() {
        return TF_FunctionName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_FunctionName(TF_Function *func)
     * }
     */
    public static MethodHandle TF_FunctionName$handle() {
        return TF_FunctionName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_FunctionName(TF_Function *func)
     * }
     */
    public static MemorySegment TF_FunctionName$address() {
        return TF_FunctionName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_FunctionName(TF_Function *func)
     * }
     */
    public static MemorySegment TF_FunctionName(MemorySegment func) {
        var mh$ = TF_FunctionName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FunctionName", func);
            }
            return (MemorySegment)mh$.invokeExact(func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FunctionToFunctionDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FunctionToFunctionDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_FunctionToFunctionDef(TF_Function *func, TF_Buffer *output_func_def, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_FunctionToFunctionDef$descriptor() {
        return TF_FunctionToFunctionDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_FunctionToFunctionDef(TF_Function *func, TF_Buffer *output_func_def, TF_Status *status)
     * }
     */
    public static MethodHandle TF_FunctionToFunctionDef$handle() {
        return TF_FunctionToFunctionDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_FunctionToFunctionDef(TF_Function *func, TF_Buffer *output_func_def, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FunctionToFunctionDef$address() {
        return TF_FunctionToFunctionDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_FunctionToFunctionDef(TF_Function *func, TF_Buffer *output_func_def, TF_Status *status)
     * }
     */
    public static void TF_FunctionToFunctionDef(MemorySegment func, MemorySegment output_func_def, MemorySegment status) {
        var mh$ = TF_FunctionToFunctionDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FunctionToFunctionDef", func, output_func_def, status);
            }
            mh$.invokeExact(func, output_func_def, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FunctionImportFunctionDef {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FunctionImportFunctionDef");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Function *TF_FunctionImportFunctionDef(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_FunctionImportFunctionDef$descriptor() {
        return TF_FunctionImportFunctionDef.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Function *TF_FunctionImportFunctionDef(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_FunctionImportFunctionDef$handle() {
        return TF_FunctionImportFunctionDef.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Function *TF_FunctionImportFunctionDef(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FunctionImportFunctionDef$address() {
        return TF_FunctionImportFunctionDef.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Function *TF_FunctionImportFunctionDef(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FunctionImportFunctionDef(MemorySegment proto, long proto_len, MemorySegment status) {
        var mh$ = TF_FunctionImportFunctionDef.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FunctionImportFunctionDef", proto, proto_len, status);
            }
            return (MemorySegment)mh$.invokeExact(proto, proto_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FunctionSetAttrValueProto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FunctionSetAttrValueProto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_FunctionSetAttrValueProto(TF_Function *func, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_FunctionSetAttrValueProto$descriptor() {
        return TF_FunctionSetAttrValueProto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_FunctionSetAttrValueProto(TF_Function *func, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_FunctionSetAttrValueProto$handle() {
        return TF_FunctionSetAttrValueProto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_FunctionSetAttrValueProto(TF_Function *func, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FunctionSetAttrValueProto$address() {
        return TF_FunctionSetAttrValueProto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_FunctionSetAttrValueProto(TF_Function *func, const char *attr_name, const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static void TF_FunctionSetAttrValueProto(MemorySegment func, MemorySegment attr_name, MemorySegment proto, long proto_len, MemorySegment status) {
        var mh$ = TF_FunctionSetAttrValueProto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FunctionSetAttrValueProto", func, attr_name, proto, proto_len, status);
            }
            mh$.invokeExact(func, attr_name, proto, proto_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_FunctionGetAttrValueProto {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_FunctionGetAttrValueProto");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_FunctionGetAttrValueProto(TF_Function *func, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_FunctionGetAttrValueProto$descriptor() {
        return TF_FunctionGetAttrValueProto.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_FunctionGetAttrValueProto(TF_Function *func, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static MethodHandle TF_FunctionGetAttrValueProto$handle() {
        return TF_FunctionGetAttrValueProto.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_FunctionGetAttrValueProto(TF_Function *func, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static MemorySegment TF_FunctionGetAttrValueProto$address() {
        return TF_FunctionGetAttrValueProto.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_FunctionGetAttrValueProto(TF_Function *func, const char *attr_name, TF_Buffer *output_attr_value, TF_Status *status)
     * }
     */
    public static void TF_FunctionGetAttrValueProto(MemorySegment func, MemorySegment attr_name, MemorySegment output_attr_value, MemorySegment status) {
        var mh$ = TF_FunctionGetAttrValueProto.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_FunctionGetAttrValueProto", func, attr_name, output_attr_value, status);
            }
            mh$.invokeExact(func, attr_name, output_attr_value, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteFunction {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteFunction");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteFunction(TF_Function *func)
     * }
     */
    public static FunctionDescriptor TF_DeleteFunction$descriptor() {
        return TF_DeleteFunction.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteFunction(TF_Function *func)
     * }
     */
    public static MethodHandle TF_DeleteFunction$handle() {
        return TF_DeleteFunction.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteFunction(TF_Function *func)
     * }
     */
    public static MemorySegment TF_DeleteFunction$address() {
        return TF_DeleteFunction.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteFunction(TF_Function *func)
     * }
     */
    public static void TF_DeleteFunction(MemorySegment func) {
        var mh$ = TF_DeleteFunction.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteFunction", func);
            }
            mh$.invokeExact(func);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_TryEvaluateConstant {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_CHAR,
            c_api_h.C_POINTER,
            TF_Output.layout(),
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_TryEvaluateConstant");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned char TF_TryEvaluateConstant(TF_Graph *graph, TF_Output output, TF_Tensor **result, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_TryEvaluateConstant$descriptor() {
        return TF_TryEvaluateConstant.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned char TF_TryEvaluateConstant(TF_Graph *graph, TF_Output output, TF_Tensor **result, TF_Status *status)
     * }
     */
    public static MethodHandle TF_TryEvaluateConstant$handle() {
        return TF_TryEvaluateConstant.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned char TF_TryEvaluateConstant(TF_Graph *graph, TF_Output output, TF_Tensor **result, TF_Status *status)
     * }
     */
    public static MemorySegment TF_TryEvaluateConstant$address() {
        return TF_TryEvaluateConstant.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned char TF_TryEvaluateConstant(TF_Graph *graph, TF_Output output, TF_Tensor **result, TF_Status *status)
     * }
     */
    public static byte TF_TryEvaluateConstant(MemorySegment graph, MemorySegment output, MemorySegment result, MemorySegment status) {
        var mh$ = TF_TryEvaluateConstant.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_TryEvaluateConstant", graph, output, result, status);
            }
            return (byte)mh$.invokeExact(graph, output, result, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewSession {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewSession");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Session *TF_NewSession(TF_Graph *graph, const TF_SessionOptions *opts, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_NewSession$descriptor() {
        return TF_NewSession.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Session *TF_NewSession(TF_Graph *graph, const TF_SessionOptions *opts, TF_Status *status)
     * }
     */
    public static MethodHandle TF_NewSession$handle() {
        return TF_NewSession.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Session *TF_NewSession(TF_Graph *graph, const TF_SessionOptions *opts, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewSession$address() {
        return TF_NewSession.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Session *TF_NewSession(TF_Graph *graph, const TF_SessionOptions *opts, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewSession(MemorySegment graph, MemorySegment opts, MemorySegment status) {
        var mh$ = TF_NewSession.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewSession", graph, opts, status);
            }
            return (MemorySegment)mh$.invokeExact(graph, opts, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_LoadSessionFromSavedModel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_LoadSessionFromSavedModel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Session *TF_LoadSessionFromSavedModel(const TF_SessionOptions *session_options, const TF_Buffer *run_options, const char *export_dir, const char *const *tags, int tags_len, TF_Graph *graph, TF_Buffer *meta_graph_def, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_LoadSessionFromSavedModel$descriptor() {
        return TF_LoadSessionFromSavedModel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Session *TF_LoadSessionFromSavedModel(const TF_SessionOptions *session_options, const TF_Buffer *run_options, const char *export_dir, const char *const *tags, int tags_len, TF_Graph *graph, TF_Buffer *meta_graph_def, TF_Status *status)
     * }
     */
    public static MethodHandle TF_LoadSessionFromSavedModel$handle() {
        return TF_LoadSessionFromSavedModel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Session *TF_LoadSessionFromSavedModel(const TF_SessionOptions *session_options, const TF_Buffer *run_options, const char *export_dir, const char *const *tags, int tags_len, TF_Graph *graph, TF_Buffer *meta_graph_def, TF_Status *status)
     * }
     */
    public static MemorySegment TF_LoadSessionFromSavedModel$address() {
        return TF_LoadSessionFromSavedModel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Session *TF_LoadSessionFromSavedModel(const TF_SessionOptions *session_options, const TF_Buffer *run_options, const char *export_dir, const char *const *tags, int tags_len, TF_Graph *graph, TF_Buffer *meta_graph_def, TF_Status *status)
     * }
     */
    public static MemorySegment TF_LoadSessionFromSavedModel(MemorySegment session_options, MemorySegment run_options, MemorySegment export_dir, MemorySegment tags, int tags_len, MemorySegment graph, MemorySegment meta_graph_def, MemorySegment status) {
        var mh$ = TF_LoadSessionFromSavedModel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_LoadSessionFromSavedModel", session_options, run_options, export_dir, tags, tags_len, graph, meta_graph_def, status);
            }
            return (MemorySegment)mh$.invokeExact(session_options, run_options, export_dir, tags, tags_len, graph, meta_graph_def, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_CloseSession {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_CloseSession");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_CloseSession(TF_Session *, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_CloseSession$descriptor() {
        return TF_CloseSession.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_CloseSession(TF_Session *, TF_Status *status)
     * }
     */
    public static MethodHandle TF_CloseSession$handle() {
        return TF_CloseSession.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_CloseSession(TF_Session *, TF_Status *status)
     * }
     */
    public static MemorySegment TF_CloseSession$address() {
        return TF_CloseSession.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_CloseSession(TF_Session *, TF_Status *status)
     * }
     */
    public static void TF_CloseSession(MemorySegment x0, MemorySegment status) {
        var mh$ = TF_CloseSession.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_CloseSession", x0, status);
            }
            mh$.invokeExact(x0, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteSession {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteSession");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteSession(TF_Session *, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_DeleteSession$descriptor() {
        return TF_DeleteSession.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteSession(TF_Session *, TF_Status *status)
     * }
     */
    public static MethodHandle TF_DeleteSession$handle() {
        return TF_DeleteSession.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteSession(TF_Session *, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeleteSession$address() {
        return TF_DeleteSession.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteSession(TF_Session *, TF_Status *status)
     * }
     */
    public static void TF_DeleteSession(MemorySegment x0, MemorySegment status) {
        var mh$ = TF_DeleteSession.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteSession", x0, status);
            }
            mh$.invokeExact(x0, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SessionRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SessionRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SessionRun(TF_Session *session, const TF_Buffer *run_options, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static FunctionDescriptor TF_SessionRun$descriptor() {
        return TF_SessionRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SessionRun(TF_Session *session, const TF_Buffer *run_options, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static MethodHandle TF_SessionRun$handle() {
        return TF_SessionRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SessionRun(TF_Session *session, const TF_Buffer *run_options, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static MemorySegment TF_SessionRun$address() {
        return TF_SessionRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SessionRun(TF_Session *session, const TF_Buffer *run_options, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static void TF_SessionRun(MemorySegment session, MemorySegment run_options, MemorySegment inputs, MemorySegment input_values, int ninputs, MemorySegment outputs, MemorySegment output_values, int noutputs, MemorySegment target_opers, int ntargets, MemorySegment run_metadata, MemorySegment x11) {
        var mh$ = TF_SessionRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SessionRun", session, run_options, inputs, input_values, ninputs, outputs, output_values, noutputs, target_opers, ntargets, run_metadata, x11);
            }
            mh$.invokeExact(session, run_options, inputs, input_values, ninputs, outputs, output_values, noutputs, target_opers, ntargets, run_metadata, x11);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SessionPRunSetup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SessionPRunSetup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SessionPRunSetup(TF_Session *, const TF_Output *inputs, int ninputs, const TF_Output *outputs, int noutputs, const TF_Operation *const *target_opers, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static FunctionDescriptor TF_SessionPRunSetup$descriptor() {
        return TF_SessionPRunSetup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SessionPRunSetup(TF_Session *, const TF_Output *inputs, int ninputs, const TF_Output *outputs, int noutputs, const TF_Operation *const *target_opers, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static MethodHandle TF_SessionPRunSetup$handle() {
        return TF_SessionPRunSetup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SessionPRunSetup(TF_Session *, const TF_Output *inputs, int ninputs, const TF_Output *outputs, int noutputs, const TF_Operation *const *target_opers, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static MemorySegment TF_SessionPRunSetup$address() {
        return TF_SessionPRunSetup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SessionPRunSetup(TF_Session *, const TF_Output *inputs, int ninputs, const TF_Output *outputs, int noutputs, const TF_Operation *const *target_opers, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static void TF_SessionPRunSetup(MemorySegment x0, MemorySegment inputs, int ninputs, MemorySegment outputs, int noutputs, MemorySegment target_opers, int ntargets, MemorySegment handle, MemorySegment x8) {
        var mh$ = TF_SessionPRunSetup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SessionPRunSetup", x0, inputs, ninputs, outputs, noutputs, target_opers, ntargets, handle, x8);
            }
            mh$.invokeExact(x0, inputs, ninputs, outputs, noutputs, target_opers, ntargets, handle, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SessionPRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SessionPRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_SessionPRun(TF_Session *, const char *handle, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Status *)
     * }
     */
    public static FunctionDescriptor TF_SessionPRun$descriptor() {
        return TF_SessionPRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_SessionPRun(TF_Session *, const char *handle, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Status *)
     * }
     */
    public static MethodHandle TF_SessionPRun$handle() {
        return TF_SessionPRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_SessionPRun(TF_Session *, const char *handle, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Status *)
     * }
     */
    public static MemorySegment TF_SessionPRun$address() {
        return TF_SessionPRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_SessionPRun(TF_Session *, const char *handle, const TF_Output *inputs, TF_Tensor *const *input_values, int ninputs, const TF_Output *outputs, TF_Tensor **output_values, int noutputs, const TF_Operation *const *target_opers, int ntargets, TF_Status *)
     * }
     */
    public static void TF_SessionPRun(MemorySegment x0, MemorySegment handle, MemorySegment inputs, MemorySegment input_values, int ninputs, MemorySegment outputs, MemorySegment output_values, int noutputs, MemorySegment target_opers, int ntargets, MemorySegment x10) {
        var mh$ = TF_SessionPRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SessionPRun", x0, handle, inputs, input_values, ninputs, outputs, output_values, noutputs, target_opers, ntargets, x10);
            }
            mh$.invokeExact(x0, handle, inputs, input_values, ninputs, outputs, output_values, noutputs, target_opers, ntargets, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeletePRunHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeletePRunHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeletePRunHandle(const char *handle)
     * }
     */
    public static FunctionDescriptor TF_DeletePRunHandle$descriptor() {
        return TF_DeletePRunHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeletePRunHandle(const char *handle)
     * }
     */
    public static MethodHandle TF_DeletePRunHandle$handle() {
        return TF_DeletePRunHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeletePRunHandle(const char *handle)
     * }
     */
    public static MemorySegment TF_DeletePRunHandle$address() {
        return TF_DeletePRunHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeletePRunHandle(const char *handle)
     * }
     */
    public static void TF_DeletePRunHandle(MemorySegment handle) {
        var mh$ = TF_DeletePRunHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeletePRunHandle", handle);
            }
            mh$.invokeExact(handle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewDeprecatedSession {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewDeprecatedSession");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_DeprecatedSession *TF_NewDeprecatedSession(const TF_SessionOptions *, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_NewDeprecatedSession$descriptor() {
        return TF_NewDeprecatedSession.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_DeprecatedSession *TF_NewDeprecatedSession(const TF_SessionOptions *, TF_Status *status)
     * }
     */
    public static MethodHandle TF_NewDeprecatedSession$handle() {
        return TF_NewDeprecatedSession.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_DeprecatedSession *TF_NewDeprecatedSession(const TF_SessionOptions *, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewDeprecatedSession$address() {
        return TF_NewDeprecatedSession.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_DeprecatedSession *TF_NewDeprecatedSession(const TF_SessionOptions *, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewDeprecatedSession(MemorySegment x0, MemorySegment status) {
        var mh$ = TF_NewDeprecatedSession.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewDeprecatedSession", x0, status);
            }
            return (MemorySegment)mh$.invokeExact(x0, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_CloseDeprecatedSession {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_CloseDeprecatedSession");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_CloseDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_CloseDeprecatedSession$descriptor() {
        return TF_CloseDeprecatedSession.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_CloseDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static MethodHandle TF_CloseDeprecatedSession$handle() {
        return TF_CloseDeprecatedSession.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_CloseDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static MemorySegment TF_CloseDeprecatedSession$address() {
        return TF_CloseDeprecatedSession.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_CloseDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static void TF_CloseDeprecatedSession(MemorySegment x0, MemorySegment status) {
        var mh$ = TF_CloseDeprecatedSession.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_CloseDeprecatedSession", x0, status);
            }
            mh$.invokeExact(x0, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteDeprecatedSession {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteDeprecatedSession");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_DeleteDeprecatedSession$descriptor() {
        return TF_DeleteDeprecatedSession.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static MethodHandle TF_DeleteDeprecatedSession$handle() {
        return TF_DeleteDeprecatedSession.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeleteDeprecatedSession$address() {
        return TF_DeleteDeprecatedSession.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteDeprecatedSession(TF_DeprecatedSession *, TF_Status *status)
     * }
     */
    public static void TF_DeleteDeprecatedSession(MemorySegment x0, MemorySegment status) {
        var mh$ = TF_DeleteDeprecatedSession.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteDeprecatedSession", x0, status);
            }
            mh$.invokeExact(x0, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_Reset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_Reset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_Reset(const TF_SessionOptions *opt, const char **containers, int ncontainers, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_Reset$descriptor() {
        return TF_Reset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_Reset(const TF_SessionOptions *opt, const char **containers, int ncontainers, TF_Status *status)
     * }
     */
    public static MethodHandle TF_Reset$handle() {
        return TF_Reset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_Reset(const TF_SessionOptions *opt, const char **containers, int ncontainers, TF_Status *status)
     * }
     */
    public static MemorySegment TF_Reset$address() {
        return TF_Reset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_Reset(const TF_SessionOptions *opt, const char **containers, int ncontainers, TF_Status *status)
     * }
     */
    public static void TF_Reset(MemorySegment opt, MemorySegment containers, int ncontainers, MemorySegment status) {
        var mh$ = TF_Reset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_Reset", opt, containers, ncontainers, status);
            }
            mh$.invokeExact(opt, containers, ncontainers, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ExtendGraph {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ExtendGraph");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ExtendGraph(TF_DeprecatedSession *, const void *proto, size_t proto_len, TF_Status *)
     * }
     */
    public static FunctionDescriptor TF_ExtendGraph$descriptor() {
        return TF_ExtendGraph.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ExtendGraph(TF_DeprecatedSession *, const void *proto, size_t proto_len, TF_Status *)
     * }
     */
    public static MethodHandle TF_ExtendGraph$handle() {
        return TF_ExtendGraph.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ExtendGraph(TF_DeprecatedSession *, const void *proto, size_t proto_len, TF_Status *)
     * }
     */
    public static MemorySegment TF_ExtendGraph$address() {
        return TF_ExtendGraph.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ExtendGraph(TF_DeprecatedSession *, const void *proto, size_t proto_len, TF_Status *)
     * }
     */
    public static void TF_ExtendGraph(MemorySegment x0, MemorySegment proto, long proto_len, MemorySegment x3) {
        var mh$ = TF_ExtendGraph.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ExtendGraph", x0, proto, proto_len, x3);
            }
            mh$.invokeExact(x0, proto, proto_len, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_Run {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_Run");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_Run(TF_DeprecatedSession *, const TF_Buffer *run_options, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static FunctionDescriptor TF_Run$descriptor() {
        return TF_Run.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_Run(TF_DeprecatedSession *, const TF_Buffer *run_options, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static MethodHandle TF_Run$handle() {
        return TF_Run.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_Run(TF_DeprecatedSession *, const TF_Buffer *run_options, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static MemorySegment TF_Run$address() {
        return TF_Run.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_Run(TF_DeprecatedSession *, const TF_Buffer *run_options, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Buffer *run_metadata, TF_Status *)
     * }
     */
    public static void TF_Run(MemorySegment x0, MemorySegment run_options, MemorySegment input_names, MemorySegment inputs, int ninputs, MemorySegment output_names, MemorySegment outputs, int noutputs, MemorySegment target_oper_names, int ntargets, MemorySegment run_metadata, MemorySegment x11) {
        var mh$ = TF_Run.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_Run", x0, run_options, input_names, inputs, ninputs, output_names, outputs, noutputs, target_oper_names, ntargets, run_metadata, x11);
            }
            mh$.invokeExact(x0, run_options, input_names, inputs, ninputs, output_names, outputs, noutputs, target_oper_names, ntargets, run_metadata, x11);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_PRunSetup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_PRunSetup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_PRunSetup(TF_DeprecatedSession *, const char **input_names, int ninputs, const char **output_names, int noutputs, const char **target_oper_names, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static FunctionDescriptor TF_PRunSetup$descriptor() {
        return TF_PRunSetup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_PRunSetup(TF_DeprecatedSession *, const char **input_names, int ninputs, const char **output_names, int noutputs, const char **target_oper_names, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static MethodHandle TF_PRunSetup$handle() {
        return TF_PRunSetup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_PRunSetup(TF_DeprecatedSession *, const char **input_names, int ninputs, const char **output_names, int noutputs, const char **target_oper_names, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static MemorySegment TF_PRunSetup$address() {
        return TF_PRunSetup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_PRunSetup(TF_DeprecatedSession *, const char **input_names, int ninputs, const char **output_names, int noutputs, const char **target_oper_names, int ntargets, const char **handle, TF_Status *)
     * }
     */
    public static void TF_PRunSetup(MemorySegment x0, MemorySegment input_names, int ninputs, MemorySegment output_names, int noutputs, MemorySegment target_oper_names, int ntargets, MemorySegment handle, MemorySegment x8) {
        var mh$ = TF_PRunSetup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_PRunSetup", x0, input_names, ninputs, output_names, noutputs, target_oper_names, ntargets, handle, x8);
            }
            mh$.invokeExact(x0, input_names, ninputs, output_names, noutputs, target_oper_names, ntargets, handle, x8);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_PRun {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_PRun");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_PRun(TF_DeprecatedSession *, const char *handle, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Status *)
     * }
     */
    public static FunctionDescriptor TF_PRun$descriptor() {
        return TF_PRun.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_PRun(TF_DeprecatedSession *, const char *handle, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Status *)
     * }
     */
    public static MethodHandle TF_PRun$handle() {
        return TF_PRun.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_PRun(TF_DeprecatedSession *, const char *handle, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Status *)
     * }
     */
    public static MemorySegment TF_PRun$address() {
        return TF_PRun.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_PRun(TF_DeprecatedSession *, const char *handle, const char **input_names, TF_Tensor **inputs, int ninputs, const char **output_names, TF_Tensor **outputs, int noutputs, const char **target_oper_names, int ntargets, TF_Status *)
     * }
     */
    public static void TF_PRun(MemorySegment x0, MemorySegment handle, MemorySegment input_names, MemorySegment inputs, int ninputs, MemorySegment output_names, MemorySegment outputs, int noutputs, MemorySegment target_oper_names, int ntargets, MemorySegment x10) {
        var mh$ = TF_PRun.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_PRun", x0, handle, input_names, inputs, ninputs, output_names, outputs, noutputs, target_oper_names, ntargets, x10);
            }
            mh$.invokeExact(x0, handle, input_names, inputs, ninputs, output_names, outputs, noutputs, target_oper_names, ntargets, x10);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_SessionListDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_SessionListDevices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_SessionListDevices(TF_Session *session, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_SessionListDevices$descriptor() {
        return TF_SessionListDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_SessionListDevices(TF_Session *session, TF_Status *status)
     * }
     */
    public static MethodHandle TF_SessionListDevices$handle() {
        return TF_SessionListDevices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_SessionListDevices(TF_Session *session, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SessionListDevices$address() {
        return TF_SessionListDevices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_SessionListDevices(TF_Session *session, TF_Status *status)
     * }
     */
    public static MemorySegment TF_SessionListDevices(MemorySegment session, MemorySegment status) {
        var mh$ = TF_SessionListDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_SessionListDevices", session, status);
            }
            return (MemorySegment)mh$.invokeExact(session, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeprecatedSessionListDevices {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeprecatedSessionListDevices");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_DeprecatedSessionListDevices(TF_DeprecatedSession *session, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_DeprecatedSessionListDevices$descriptor() {
        return TF_DeprecatedSessionListDevices.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_DeprecatedSessionListDevices(TF_DeprecatedSession *session, TF_Status *status)
     * }
     */
    public static MethodHandle TF_DeprecatedSessionListDevices$handle() {
        return TF_DeprecatedSessionListDevices.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_DeprecatedSessionListDevices(TF_DeprecatedSession *session, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeprecatedSessionListDevices$address() {
        return TF_DeprecatedSessionListDevices.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_DeviceList *TF_DeprecatedSessionListDevices(TF_DeprecatedSession *session, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeprecatedSessionListDevices(MemorySegment session, MemorySegment status) {
        var mh$ = TF_DeprecatedSessionListDevices.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeprecatedSessionListDevices", session, status);
            }
            return (MemorySegment)mh$.invokeExact(session, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteDeviceList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteDeviceList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteDeviceList(TF_DeviceList *list)
     * }
     */
    public static FunctionDescriptor TF_DeleteDeviceList$descriptor() {
        return TF_DeleteDeviceList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteDeviceList(TF_DeviceList *list)
     * }
     */
    public static MethodHandle TF_DeleteDeviceList$handle() {
        return TF_DeleteDeviceList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteDeviceList(TF_DeviceList *list)
     * }
     */
    public static MemorySegment TF_DeleteDeviceList$address() {
        return TF_DeleteDeviceList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteDeviceList(TF_DeviceList *list)
     * }
     */
    public static void TF_DeleteDeviceList(MemorySegment list) {
        var mh$ = TF_DeleteDeviceList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteDeviceList", list);
            }
            mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeviceListCount {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeviceListCount");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int TF_DeviceListCount(const TF_DeviceList *list)
     * }
     */
    public static FunctionDescriptor TF_DeviceListCount$descriptor() {
        return TF_DeviceListCount.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int TF_DeviceListCount(const TF_DeviceList *list)
     * }
     */
    public static MethodHandle TF_DeviceListCount$handle() {
        return TF_DeviceListCount.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int TF_DeviceListCount(const TF_DeviceList *list)
     * }
     */
    public static MemorySegment TF_DeviceListCount$address() {
        return TF_DeviceListCount.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int TF_DeviceListCount(const TF_DeviceList *list)
     * }
     */
    public static int TF_DeviceListCount(MemorySegment list) {
        var mh$ = TF_DeviceListCount.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeviceListCount", list);
            }
            return (int)mh$.invokeExact(list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeviceListName {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeviceListName");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_DeviceListName(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_DeviceListName$descriptor() {
        return TF_DeviceListName.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_DeviceListName(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MethodHandle TF_DeviceListName$handle() {
        return TF_DeviceListName.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_DeviceListName(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeviceListName$address() {
        return TF_DeviceListName.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_DeviceListName(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeviceListName(MemorySegment list, int index, MemorySegment status) {
        var mh$ = TF_DeviceListName.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeviceListName", list, index, status);
            }
            return (MemorySegment)mh$.invokeExact(list, index, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeviceListType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeviceListType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_DeviceListType(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_DeviceListType$descriptor() {
        return TF_DeviceListType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_DeviceListType(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MethodHandle TF_DeviceListType$handle() {
        return TF_DeviceListType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_DeviceListType(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeviceListType$address() {
        return TF_DeviceListType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_DeviceListType(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeviceListType(MemorySegment list, int index, MemorySegment status) {
        var mh$ = TF_DeviceListType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeviceListType", list, index, status);
            }
            return (MemorySegment)mh$.invokeExact(list, index, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeviceListMemoryBytes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeviceListMemoryBytes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int64_t TF_DeviceListMemoryBytes(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_DeviceListMemoryBytes$descriptor() {
        return TF_DeviceListMemoryBytes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int64_t TF_DeviceListMemoryBytes(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MethodHandle TF_DeviceListMemoryBytes$handle() {
        return TF_DeviceListMemoryBytes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int64_t TF_DeviceListMemoryBytes(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeviceListMemoryBytes$address() {
        return TF_DeviceListMemoryBytes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int64_t TF_DeviceListMemoryBytes(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static long TF_DeviceListMemoryBytes(MemorySegment list, int index, MemorySegment status) {
        var mh$ = TF_DeviceListMemoryBytes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeviceListMemoryBytes", list, index, status);
            }
            return (long)mh$.invokeExact(list, index, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeviceListIncarnation {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_LONG_LONG,
            c_api_h.C_POINTER,
            c_api_h.C_INT,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeviceListIncarnation");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uint64_t TF_DeviceListIncarnation(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_DeviceListIncarnation$descriptor() {
        return TF_DeviceListIncarnation.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uint64_t TF_DeviceListIncarnation(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MethodHandle TF_DeviceListIncarnation$handle() {
        return TF_DeviceListIncarnation.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uint64_t TF_DeviceListIncarnation(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static MemorySegment TF_DeviceListIncarnation$address() {
        return TF_DeviceListIncarnation.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uint64_t TF_DeviceListIncarnation(const TF_DeviceList *list, int index, TF_Status *status)
     * }
     */
    public static long TF_DeviceListIncarnation(MemorySegment list, int index, MemorySegment status) {
        var mh$ = TF_DeviceListIncarnation.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeviceListIncarnation", list, index, status);
            }
            return (long)mh$.invokeExact(list, index, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_LoadLibrary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_LoadLibrary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Library *TF_LoadLibrary(const char *library_filename, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_LoadLibrary$descriptor() {
        return TF_LoadLibrary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Library *TF_LoadLibrary(const char *library_filename, TF_Status *status)
     * }
     */
    public static MethodHandle TF_LoadLibrary$handle() {
        return TF_LoadLibrary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Library *TF_LoadLibrary(const char *library_filename, TF_Status *status)
     * }
     */
    public static MemorySegment TF_LoadLibrary$address() {
        return TF_LoadLibrary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Library *TF_LoadLibrary(const char *library_filename, TF_Status *status)
     * }
     */
    public static MemorySegment TF_LoadLibrary(MemorySegment library_filename, MemorySegment status) {
        var mh$ = TF_LoadLibrary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_LoadLibrary", library_filename, status);
            }
            return (MemorySegment)mh$.invokeExact(library_filename, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GetOpList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            TF_Buffer.layout(),
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GetOpList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Buffer TF_GetOpList(TF_Library *lib_handle)
     * }
     */
    public static FunctionDescriptor TF_GetOpList$descriptor() {
        return TF_GetOpList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Buffer TF_GetOpList(TF_Library *lib_handle)
     * }
     */
    public static MethodHandle TF_GetOpList$handle() {
        return TF_GetOpList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Buffer TF_GetOpList(TF_Library *lib_handle)
     * }
     */
    public static MemorySegment TF_GetOpList$address() {
        return TF_GetOpList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Buffer TF_GetOpList(TF_Library *lib_handle)
     * }
     */
    public static MemorySegment TF_GetOpList(SegmentAllocator allocator, MemorySegment lib_handle) {
        var mh$ = TF_GetOpList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GetOpList", allocator, lib_handle);
            }
            return (MemorySegment)mh$.invokeExact(allocator, lib_handle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteLibraryHandle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteLibraryHandle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteLibraryHandle(TF_Library *lib_handle)
     * }
     */
    public static FunctionDescriptor TF_DeleteLibraryHandle$descriptor() {
        return TF_DeleteLibraryHandle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteLibraryHandle(TF_Library *lib_handle)
     * }
     */
    public static MethodHandle TF_DeleteLibraryHandle$handle() {
        return TF_DeleteLibraryHandle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteLibraryHandle(TF_Library *lib_handle)
     * }
     */
    public static MemorySegment TF_DeleteLibraryHandle$address() {
        return TF_DeleteLibraryHandle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteLibraryHandle(TF_Library *lib_handle)
     * }
     */
    public static void TF_DeleteLibraryHandle(MemorySegment lib_handle) {
        var mh$ = TF_DeleteLibraryHandle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteLibraryHandle", lib_handle);
            }
            mh$.invokeExact(lib_handle);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GetAllOpList {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GetAllOpList");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllOpList()
     * }
     */
    public static FunctionDescriptor TF_GetAllOpList$descriptor() {
        return TF_GetAllOpList.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllOpList()
     * }
     */
    public static MethodHandle TF_GetAllOpList$handle() {
        return TF_GetAllOpList.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllOpList()
     * }
     */
    public static MemorySegment TF_GetAllOpList$address() {
        return TF_GetAllOpList.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllOpList()
     * }
     */
    public static MemorySegment TF_GetAllOpList() {
        var mh$ = TF_GetAllOpList.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GetAllOpList");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewApiDefMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewApiDefMap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_ApiDefMap *TF_NewApiDefMap(TF_Buffer *op_list_buffer, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_NewApiDefMap$descriptor() {
        return TF_NewApiDefMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_ApiDefMap *TF_NewApiDefMap(TF_Buffer *op_list_buffer, TF_Status *status)
     * }
     */
    public static MethodHandle TF_NewApiDefMap$handle() {
        return TF_NewApiDefMap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_ApiDefMap *TF_NewApiDefMap(TF_Buffer *op_list_buffer, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewApiDefMap$address() {
        return TF_NewApiDefMap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_ApiDefMap *TF_NewApiDefMap(TF_Buffer *op_list_buffer, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewApiDefMap(MemorySegment op_list_buffer, MemorySegment status) {
        var mh$ = TF_NewApiDefMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewApiDefMap", op_list_buffer, status);
            }
            return (MemorySegment)mh$.invokeExact(op_list_buffer, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteApiDefMap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteApiDefMap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteApiDefMap(TF_ApiDefMap *apimap)
     * }
     */
    public static FunctionDescriptor TF_DeleteApiDefMap$descriptor() {
        return TF_DeleteApiDefMap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteApiDefMap(TF_ApiDefMap *apimap)
     * }
     */
    public static MethodHandle TF_DeleteApiDefMap$handle() {
        return TF_DeleteApiDefMap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteApiDefMap(TF_ApiDefMap *apimap)
     * }
     */
    public static MemorySegment TF_DeleteApiDefMap$address() {
        return TF_DeleteApiDefMap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteApiDefMap(TF_ApiDefMap *apimap)
     * }
     */
    public static void TF_DeleteApiDefMap(MemorySegment apimap) {
        var mh$ = TF_DeleteApiDefMap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteApiDefMap", apimap);
            }
            mh$.invokeExact(apimap);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ApiDefMapPut {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ApiDefMapPut");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ApiDefMapPut(TF_ApiDefMap *api_def_map, const char *text, size_t text_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_ApiDefMapPut$descriptor() {
        return TF_ApiDefMapPut.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ApiDefMapPut(TF_ApiDefMap *api_def_map, const char *text, size_t text_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_ApiDefMapPut$handle() {
        return TF_ApiDefMapPut.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ApiDefMapPut(TF_ApiDefMap *api_def_map, const char *text, size_t text_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_ApiDefMapPut$address() {
        return TF_ApiDefMapPut.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ApiDefMapPut(TF_ApiDefMap *api_def_map, const char *text, size_t text_len, TF_Status *status)
     * }
     */
    public static void TF_ApiDefMapPut(MemorySegment api_def_map, MemorySegment text, long text_len, MemorySegment status) {
        var mh$ = TF_ApiDefMapPut.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ApiDefMapPut", api_def_map, text, text_len, status);
            }
            mh$.invokeExact(api_def_map, text, text_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ApiDefMapGet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ApiDefMapGet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_ApiDefMapGet(TF_ApiDefMap *api_def_map, const char *name, size_t name_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_ApiDefMapGet$descriptor() {
        return TF_ApiDefMapGet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_ApiDefMapGet(TF_ApiDefMap *api_def_map, const char *name, size_t name_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_ApiDefMapGet$handle() {
        return TF_ApiDefMapGet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_ApiDefMapGet(TF_ApiDefMap *api_def_map, const char *name, size_t name_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_ApiDefMapGet$address() {
        return TF_ApiDefMapGet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Buffer *TF_ApiDefMapGet(TF_ApiDefMap *api_def_map, const char *name, size_t name_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_ApiDefMapGet(MemorySegment api_def_map, MemorySegment name, long name_len, MemorySegment status) {
        var mh$ = TF_ApiDefMapGet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ApiDefMapGet", api_def_map, name, name_len, status);
            }
            return (MemorySegment)mh$.invokeExact(api_def_map, name, name_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GetAllRegisteredKernels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GetAllRegisteredKernels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllRegisteredKernels(TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GetAllRegisteredKernels$descriptor() {
        return TF_GetAllRegisteredKernels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllRegisteredKernels(TF_Status *status)
     * }
     */
    public static MethodHandle TF_GetAllRegisteredKernels$handle() {
        return TF_GetAllRegisteredKernels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllRegisteredKernels(TF_Status *status)
     * }
     */
    public static MemorySegment TF_GetAllRegisteredKernels$address() {
        return TF_GetAllRegisteredKernels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetAllRegisteredKernels(TF_Status *status)
     * }
     */
    public static MemorySegment TF_GetAllRegisteredKernels(MemorySegment status) {
        var mh$ = TF_GetAllRegisteredKernels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GetAllRegisteredKernels", status);
            }
            return (MemorySegment)mh$.invokeExact(status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_GetRegisteredKernelsForOp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_GetRegisteredKernelsForOp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetRegisteredKernelsForOp(const char *name, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_GetRegisteredKernelsForOp$descriptor() {
        return TF_GetRegisteredKernelsForOp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetRegisteredKernelsForOp(const char *name, TF_Status *status)
     * }
     */
    public static MethodHandle TF_GetRegisteredKernelsForOp$handle() {
        return TF_GetRegisteredKernelsForOp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetRegisteredKernelsForOp(const char *name, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GetRegisteredKernelsForOp$address() {
        return TF_GetRegisteredKernelsForOp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Buffer *TF_GetRegisteredKernelsForOp(const char *name, TF_Status *status)
     * }
     */
    public static MemorySegment TF_GetRegisteredKernelsForOp(MemorySegment name, MemorySegment status) {
        var mh$ = TF_GetRegisteredKernelsForOp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_GetRegisteredKernelsForOp", name, status);
            }
            return (MemorySegment)mh$.invokeExact(name, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_UpdateEdge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            TF_Output.layout(),
            TF_Input.layout(),
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_UpdateEdge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_UpdateEdge(TF_Graph *graph, TF_Output new_src, TF_Input dst, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_UpdateEdge$descriptor() {
        return TF_UpdateEdge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_UpdateEdge(TF_Graph *graph, TF_Output new_src, TF_Input dst, TF_Status *status)
     * }
     */
    public static MethodHandle TF_UpdateEdge$handle() {
        return TF_UpdateEdge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_UpdateEdge(TF_Graph *graph, TF_Output new_src, TF_Input dst, TF_Status *status)
     * }
     */
    public static MemorySegment TF_UpdateEdge$address() {
        return TF_UpdateEdge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_UpdateEdge(TF_Graph *graph, TF_Output new_src, TF_Input dst, TF_Status *status)
     * }
     */
    public static void TF_UpdateEdge(MemorySegment graph, MemorySegment new_src, MemorySegment dst, MemorySegment status) {
        var mh$ = TF_UpdateEdge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_UpdateEdge", graph, new_src, dst, status);
            }
            mh$.invokeExact(graph, new_src, dst, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_NewServer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER,
            c_api_h.C_LONG,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_NewServer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern TF_Server *TF_NewServer(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_NewServer$descriptor() {
        return TF_NewServer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern TF_Server *TF_NewServer(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MethodHandle TF_NewServer$handle() {
        return TF_NewServer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern TF_Server *TF_NewServer(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewServer$address() {
        return TF_NewServer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern TF_Server *TF_NewServer(const void *proto, size_t proto_len, TF_Status *status)
     * }
     */
    public static MemorySegment TF_NewServer(MemorySegment proto, long proto_len, MemorySegment status) {
        var mh$ = TF_NewServer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_NewServer", proto, proto_len, status);
            }
            return (MemorySegment)mh$.invokeExact(proto, proto_len, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ServerStart {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ServerStart");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ServerStart(TF_Server *server, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_ServerStart$descriptor() {
        return TF_ServerStart.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ServerStart(TF_Server *server, TF_Status *status)
     * }
     */
    public static MethodHandle TF_ServerStart$handle() {
        return TF_ServerStart.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ServerStart(TF_Server *server, TF_Status *status)
     * }
     */
    public static MemorySegment TF_ServerStart$address() {
        return TF_ServerStart.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ServerStart(TF_Server *server, TF_Status *status)
     * }
     */
    public static void TF_ServerStart(MemorySegment server, MemorySegment status) {
        var mh$ = TF_ServerStart.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ServerStart", server, status);
            }
            mh$.invokeExact(server, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ServerStop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ServerStop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ServerStop(TF_Server *server, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_ServerStop$descriptor() {
        return TF_ServerStop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ServerStop(TF_Server *server, TF_Status *status)
     * }
     */
    public static MethodHandle TF_ServerStop$handle() {
        return TF_ServerStop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ServerStop(TF_Server *server, TF_Status *status)
     * }
     */
    public static MemorySegment TF_ServerStop$address() {
        return TF_ServerStop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ServerStop(TF_Server *server, TF_Status *status)
     * }
     */
    public static void TF_ServerStop(MemorySegment server, MemorySegment status) {
        var mh$ = TF_ServerStop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ServerStop", server, status);
            }
            mh$.invokeExact(server, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ServerJoin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ServerJoin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_ServerJoin(TF_Server *server, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_ServerJoin$descriptor() {
        return TF_ServerJoin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_ServerJoin(TF_Server *server, TF_Status *status)
     * }
     */
    public static MethodHandle TF_ServerJoin$handle() {
        return TF_ServerJoin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_ServerJoin(TF_Server *server, TF_Status *status)
     * }
     */
    public static MemorySegment TF_ServerJoin$address() {
        return TF_ServerJoin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_ServerJoin(TF_Server *server, TF_Status *status)
     * }
     */
    public static void TF_ServerJoin(MemorySegment server, MemorySegment status) {
        var mh$ = TF_ServerJoin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ServerJoin", server, status);
            }
            mh$.invokeExact(server, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_ServerTarget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_ServerTarget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern const char *TF_ServerTarget(TF_Server *server)
     * }
     */
    public static FunctionDescriptor TF_ServerTarget$descriptor() {
        return TF_ServerTarget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern const char *TF_ServerTarget(TF_Server *server)
     * }
     */
    public static MethodHandle TF_ServerTarget$handle() {
        return TF_ServerTarget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern const char *TF_ServerTarget(TF_Server *server)
     * }
     */
    public static MemorySegment TF_ServerTarget$address() {
        return TF_ServerTarget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern const char *TF_ServerTarget(TF_Server *server)
     * }
     */
    public static MemorySegment TF_ServerTarget(MemorySegment server) {
        var mh$ = TF_ServerTarget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_ServerTarget", server);
            }
            return (MemorySegment)mh$.invokeExact(server);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_DeleteServer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_DeleteServer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_DeleteServer(TF_Server *server)
     * }
     */
    public static FunctionDescriptor TF_DeleteServer$descriptor() {
        return TF_DeleteServer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_DeleteServer(TF_Server *server)
     * }
     */
    public static MethodHandle TF_DeleteServer$handle() {
        return TF_DeleteServer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_DeleteServer(TF_Server *server)
     * }
     */
    public static MemorySegment TF_DeleteServer$address() {
        return TF_DeleteServer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_DeleteServer(TF_Server *server)
     * }
     */
    public static void TF_DeleteServer(MemorySegment server) {
        var mh$ = TF_DeleteServer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_DeleteServer", server);
            }
            mh$.invokeExact(server);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_RegisterLogListener {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_RegisterLogListener");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_RegisterLogListener(void (*listener)(const char *))
     * }
     */
    public static FunctionDescriptor TF_RegisterLogListener$descriptor() {
        return TF_RegisterLogListener.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_RegisterLogListener(void (*listener)(const char *))
     * }
     */
    public static MethodHandle TF_RegisterLogListener$handle() {
        return TF_RegisterLogListener.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_RegisterLogListener(void (*listener)(const char *))
     * }
     */
    public static MemorySegment TF_RegisterLogListener$address() {
        return TF_RegisterLogListener.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_RegisterLogListener(void (*listener)(const char *))
     * }
     */
    public static void TF_RegisterLogListener(MemorySegment listener) {
        var mh$ = TF_RegisterLogListener.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_RegisterLogListener", listener);
            }
            mh$.invokeExact(listener);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TF_RegisterFilesystemPlugin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            c_api_h.C_POINTER,
            c_api_h.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("TF_RegisterFilesystemPlugin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void TF_RegisterFilesystemPlugin(const char *plugin_filename, TF_Status *status)
     * }
     */
    public static FunctionDescriptor TF_RegisterFilesystemPlugin$descriptor() {
        return TF_RegisterFilesystemPlugin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void TF_RegisterFilesystemPlugin(const char *plugin_filename, TF_Status *status)
     * }
     */
    public static MethodHandle TF_RegisterFilesystemPlugin$handle() {
        return TF_RegisterFilesystemPlugin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void TF_RegisterFilesystemPlugin(const char *plugin_filename, TF_Status *status)
     * }
     */
    public static MemorySegment TF_RegisterFilesystemPlugin$address() {
        return TF_RegisterFilesystemPlugin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void TF_RegisterFilesystemPlugin(const char *plugin_filename, TF_Status *status)
     * }
     */
    public static void TF_RegisterFilesystemPlugin(MemorySegment plugin_filename, MemorySegment status) {
        var mh$ = TF_RegisterFilesystemPlugin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TF_RegisterFilesystemPlugin", plugin_filename, status);
            }
            mh$.invokeExact(plugin_filename, status);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = c_api_h.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int TF_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * #define TF_OK 0
     * }
     */
    public static int TF_OK() {
        return TF_OK;
    }
    private static final int TF_CANCELLED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define TF_CANCELLED 1
     * }
     */
    public static int TF_CANCELLED() {
        return TF_CANCELLED;
    }
    private static final int TF_UNKNOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * #define TF_UNKNOWN 2
     * }
     */
    public static int TF_UNKNOWN() {
        return TF_UNKNOWN;
    }
    private static final int TF_INVALID_ARGUMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define TF_INVALID_ARGUMENT 3
     * }
     */
    public static int TF_INVALID_ARGUMENT() {
        return TF_INVALID_ARGUMENT;
    }
    private static final int TF_DEADLINE_EXCEEDED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define TF_DEADLINE_EXCEEDED 4
     * }
     */
    public static int TF_DEADLINE_EXCEEDED() {
        return TF_DEADLINE_EXCEEDED;
    }
    private static final int TF_NOT_FOUND = (int)5L;
    /**
     * {@snippet lang=c :
     * #define TF_NOT_FOUND 5
     * }
     */
    public static int TF_NOT_FOUND() {
        return TF_NOT_FOUND;
    }
    private static final int TF_ALREADY_EXISTS = (int)6L;
    /**
     * {@snippet lang=c :
     * #define TF_ALREADY_EXISTS 6
     * }
     */
    public static int TF_ALREADY_EXISTS() {
        return TF_ALREADY_EXISTS;
    }
    private static final int TF_PERMISSION_DENIED = (int)7L;
    /**
     * {@snippet lang=c :
     * #define TF_PERMISSION_DENIED 7
     * }
     */
    public static int TF_PERMISSION_DENIED() {
        return TF_PERMISSION_DENIED;
    }
    private static final int TF_UNAUTHENTICATED = (int)16L;
    /**
     * {@snippet lang=c :
     * #define TF_UNAUTHENTICATED 16
     * }
     */
    public static int TF_UNAUTHENTICATED() {
        return TF_UNAUTHENTICATED;
    }
    private static final int TF_RESOURCE_EXHAUSTED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define TF_RESOURCE_EXHAUSTED 8
     * }
     */
    public static int TF_RESOURCE_EXHAUSTED() {
        return TF_RESOURCE_EXHAUSTED;
    }
    private static final int TF_FAILED_PRECONDITION = (int)9L;
    /**
     * {@snippet lang=c :
     * #define TF_FAILED_PRECONDITION 9
     * }
     */
    public static int TF_FAILED_PRECONDITION() {
        return TF_FAILED_PRECONDITION;
    }
    private static final int TF_ABORTED = (int)10L;
    /**
     * {@snippet lang=c :
     * #define TF_ABORTED 10
     * }
     */
    public static int TF_ABORTED() {
        return TF_ABORTED;
    }
    private static final int TF_OUT_OF_RANGE = (int)11L;
    /**
     * {@snippet lang=c :
     * #define TF_OUT_OF_RANGE 11
     * }
     */
    public static int TF_OUT_OF_RANGE() {
        return TF_OUT_OF_RANGE;
    }
    private static final int TF_UNIMPLEMENTED = (int)12L;
    /**
     * {@snippet lang=c :
     * #define TF_UNIMPLEMENTED 12
     * }
     */
    public static int TF_UNIMPLEMENTED() {
        return TF_UNIMPLEMENTED;
    }
    private static final int TF_INTERNAL = (int)13L;
    /**
     * {@snippet lang=c :
     * #define TF_INTERNAL 13
     * }
     */
    public static int TF_INTERNAL() {
        return TF_INTERNAL;
    }
    private static final int TF_UNAVAILABLE = (int)14L;
    /**
     * {@snippet lang=c :
     * #define TF_UNAVAILABLE 14
     * }
     */
    public static int TF_UNAVAILABLE() {
        return TF_UNAVAILABLE;
    }
    private static final int TF_DATA_LOSS = (int)15L;
    /**
     * {@snippet lang=c :
     * #define TF_DATA_LOSS 15
     * }
     */
    public static int TF_DATA_LOSS() {
        return TF_DATA_LOSS;
    }
    private static final long TF_ALLOCATOR_ATTRIBUTES_STRUCT_SIZE = 9L;
    /**
     * {@snippet lang=c :
     * #define TF_ALLOCATOR_ATTRIBUTES_STRUCT_SIZE 9
     * }
     */
    public static long TF_ALLOCATOR_ATTRIBUTES_STRUCT_SIZE() {
        return TF_ALLOCATOR_ATTRIBUTES_STRUCT_SIZE;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_7 130700
     * }
     */
    public static int MAC_OS_VERSION_13_7() {
        return MAC_OS_VERSION_13_7;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int MAC_OS_VERSION_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }
    private static final int MAC_OS_VERSION_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }
    private static final int MAC_OS_VERSION_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_5 140500
     * }
     */
    public static int MAC_OS_VERSION_14_5() {
        return MAC_OS_VERSION_14_5;
    }
    private static final int MAC_OS_VERSION_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_6 140600
     * }
     */
    public static int MAC_OS_VERSION_14_6() {
        return MAC_OS_VERSION_14_6;
    }
    private static final int MAC_OS_VERSION_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_7 140700
     * }
     */
    public static int MAC_OS_VERSION_14_7() {
        return MAC_OS_VERSION_14_7;
    }
    private static final int MAC_OS_VERSION_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_0 150000
     * }
     */
    public static int MAC_OS_VERSION_15_0() {
        return MAC_OS_VERSION_15_0;
    }
    private static final int MAC_OS_VERSION_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_1 150100
     * }
     */
    public static int MAC_OS_VERSION_15_1() {
        return MAC_OS_VERSION_15_1;
    }
    private static final int MAC_OS_VERSION_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_2 150200
     * }
     */
    public static int MAC_OS_VERSION_15_2() {
        return MAC_OS_VERSION_15_2;
    }
    private static final int MAC_OS_VERSION_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_3 150300
     * }
     */
    public static int MAC_OS_VERSION_15_3() {
        return MAC_OS_VERSION_15_3;
    }
    private static final int MAC_OS_VERSION_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_4 150400
     * }
     */
    public static int MAC_OS_VERSION_15_4() {
        return MAC_OS_VERSION_15_4;
    }
    private static final int MAC_OS_VERSION_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_5 150500
     * }
     */
    public static int MAC_OS_VERSION_15_5() {
        return MAC_OS_VERSION_15_5;
    }
    private static final int MAC_OS_VERSION_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_6 150600
     * }
     */
    public static int MAC_OS_VERSION_15_6() {
        return MAC_OS_VERSION_15_6;
    }
    private static final int MAC_OS_VERSION_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_16_0 160000
     * }
     */
    public static int MAC_OS_VERSION_16_0() {
        return MAC_OS_VERSION_16_0;
    }
    private static final int MAC_OS_VERSION_26_0 = (int)260000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_26_0 260000
     * }
     */
    public static int MAC_OS_VERSION_26_0() {
        return MAC_OS_VERSION_26_0;
    }
    private static final int MAC_OS_VERSION_26_1 = (int)260100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_26_1 260100
     * }
     */
    public static int MAC_OS_VERSION_26_1() {
        return MAC_OS_VERSION_26_1;
    }
    private static final int MAC_OS_VERSION_26_2 = (int)260200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_26_2 260200
     * }
     */
    public static int MAC_OS_VERSION_26_2() {
        return MAC_OS_VERSION_26_2;
    }
    private static final int __AVAILABILITY_VERSIONS_VERSION_HASH = (int)93585900L;
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_HASH 93585900
     * }
     */
    public static int __AVAILABILITY_VERSIONS_VERSION_HASH() {
        return __AVAILABILITY_VERSIONS_VERSION_HASH;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_STRING "Local"
     * }
     */
    public static MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING() {
        class Holder {
            static final MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING
                = c_api_h.LIBRARY_ARENA.allocateFrom("Local");
        }
        return Holder.__AVAILABILITY_VERSIONS_VERSION_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_FILE "AvailabilityVersions.h"
     * }
     */
    public static MemorySegment __AVAILABILITY_FILE() {
        class Holder {
            static final MemorySegment __AVAILABILITY_FILE
                = c_api_h.LIBRARY_ARENA.allocateFrom("AvailabilityVersions.h");
        }
        return Holder.__AVAILABILITY_FILE;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)260200L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 260200
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final int __DARWIN_WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }
    private static final int __DARWIN_WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }
    private static final int __DARWIN_WEOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }
    private static final int NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }
    private static final int SIGIOT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }
    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }
    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }
    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }
    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final int SA_USERSPACE_MASK = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }
    private static final int SV_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }
    private static final int SV_INTERRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }
    private static final int SV_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }
    private static final int SV_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }
    private static final int SV_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }
    private static final int SV_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }
    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }
    private static final int PRIO_MIN = (int)-20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MIN -20
     * }
     */
    public static int PRIO_MIN() {
        return PRIO_MIN;
    }
    private static final int RUSAGE_CHILDREN = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_CHILDREN -1
     * }
     */
    public static int RUSAGE_CHILDREN() {
        return RUSAGE_CHILDREN;
    }
    private static final int RUSAGE_INFO_CURRENT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_CURRENT 6
     * }
     */
    public static int RUSAGE_INFO_CURRENT() {
        return RUSAGE_INFO_CURRENT;
    }
    private static final long RLIM_INFINITY = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_INFINITY 9223372036854775807
     * }
     */
    public static long RLIM_INFINITY() {
        return RLIM_INFINITY;
    }
    private static final long RLIM_SAVED_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_MAX 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_MAX() {
        return RLIM_SAVED_MAX;
    }
    private static final long RLIM_SAVED_CUR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_CUR 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_CUR() {
        return RLIM_SAVED_CUR;
    }
    private static final int RLIMIT_RSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_RSS 5
     * }
     */
    public static int RLIMIT_RSS() {
        return RLIMIT_RSS;
    }
    private static final int IOPOL_APPLICATION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_APPLICATION 5
     * }
     */
    public static int IOPOL_APPLICATION() {
        return IOPOL_APPLICATION;
    }
    private static final int IOPOL_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_NORMAL 1
     * }
     */
    public static int IOPOL_NORMAL() {
        return IOPOL_NORMAL;
    }
    private static final int WAIT_ANY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_ANY -1
     * }
     */
    public static int WAIT_ANY() {
        return WAIT_ANY;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int __DARWIN_BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final int CLK_TCK = (int)100L;
    /**
     * {@snippet lang=c :
     * #define CLK_TCK 100
     * }
     */
    public static int CLK_TCK() {
        return CLK_TCK;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }
    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }
    private static final long SIZE_T_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_T_MAX -1
     * }
     */
    public static long SIZE_T_MAX() {
        return SIZE_T_MAX;
    }
    private static final long UQUAD_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UQUAD_MAX -1
     * }
     */
    public static long UQUAD_MAX() {
        return UQUAD_MAX;
    }
    private static final long QUAD_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MAX 9223372036854775807
     * }
     */
    public static long QUAD_MAX() {
        return QUAD_MAX;
    }
    private static final long QUAD_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MIN -9223372036854775808
     * }
     */
    public static long QUAD_MIN() {
        return QUAD_MIN;
    }
    private static final int ARG_MAX = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 1048576
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }
    private static final int GID_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define GID_MAX 2147483647
     * }
     */
    public static int GID_MAX() {
        return GID_MAX;
    }
    private static final int UID_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define UID_MAX 2147483647
     * }
     */
    public static int UID_MAX() {
        return UID_MAX;
    }
    private static final int _POSIX_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }
    private static final long OFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define OFF_MIN -9223372036854775808
     * }
     */
    public static long OFF_MIN() {
        return OFF_MIN;
    }
    private static final long OFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define OFF_MAX 9223372036854775807
     * }
     */
    public static long OFF_MAX() {
        return OFF_MAX;
    }
    private static final long LONG_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_LONG_MAX() {
        return LONG_LONG_MAX;
    }
    private static final long LONG_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_LONG_MIN() {
        return LONG_LONG_MIN;
    }
    private static final long ULONG_LONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_LONG_MAX -1
     * }
     */
    public static long ULONG_LONG_MAX() {
        return ULONG_LONG_MAX;
    }
}

