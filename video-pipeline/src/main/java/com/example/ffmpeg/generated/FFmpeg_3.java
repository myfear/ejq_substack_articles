// Generated by jextract

package com.example.ffmpeg.generated;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class FFmpeg_3 extends FFmpeg_4 {

    FFmpeg_3() {
        // Should not be called directly
    }
    private static final int AV_PROFILE_APV_444_10 = (int)55L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_444_10 55
     * }
     */
    public static int AV_PROFILE_APV_444_10() {
        return AV_PROFILE_APV_444_10;
    }
    private static final int AV_PROFILE_APV_444_12 = (int)66L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_444_12 66
     * }
     */
    public static int AV_PROFILE_APV_444_12() {
        return AV_PROFILE_APV_444_12;
    }
    private static final int AV_PROFILE_APV_4444_10 = (int)77L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_4444_10 77
     * }
     */
    public static int AV_PROFILE_APV_4444_10() {
        return AV_PROFILE_APV_4444_10;
    }
    private static final int AV_PROFILE_APV_4444_12 = (int)88L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_4444_12 88
     * }
     */
    public static int AV_PROFILE_APV_4444_12() {
        return AV_PROFILE_APV_4444_12;
    }
    private static final int AV_PROFILE_APV_400_10 = (int)99L;
    /**
     * {@snippet lang=c :
     * #define AV_PROFILE_APV_400_10 99
     * }
     */
    public static int AV_PROFILE_APV_400_10() {
        return AV_PROFILE_APV_400_10;
    }
    private static final int AV_DICT_MATCH_CASE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_MATCH_CASE 1
     * }
     */
    public static int AV_DICT_MATCH_CASE() {
        return AV_DICT_MATCH_CASE;
    }
    private static final int AV_DICT_IGNORE_SUFFIX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_IGNORE_SUFFIX 2
     * }
     */
    public static int AV_DICT_IGNORE_SUFFIX() {
        return AV_DICT_IGNORE_SUFFIX;
    }
    private static final int AV_DICT_DONT_STRDUP_KEY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_STRDUP_KEY 4
     * }
     */
    public static int AV_DICT_DONT_STRDUP_KEY() {
        return AV_DICT_DONT_STRDUP_KEY;
    }
    private static final int AV_DICT_DONT_STRDUP_VAL = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_STRDUP_VAL 8
     * }
     */
    public static int AV_DICT_DONT_STRDUP_VAL() {
        return AV_DICT_DONT_STRDUP_VAL;
    }
    private static final int AV_DICT_DONT_OVERWRITE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DONT_OVERWRITE 16
     * }
     */
    public static int AV_DICT_DONT_OVERWRITE() {
        return AV_DICT_DONT_OVERWRITE;
    }
    private static final int AV_DICT_APPEND = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_APPEND 32
     * }
     */
    public static int AV_DICT_APPEND() {
        return AV_DICT_APPEND;
    }
    private static final int AV_DICT_MULTIKEY = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_MULTIKEY 64
     * }
     */
    public static int AV_DICT_MULTIKEY() {
        return AV_DICT_MULTIKEY;
    }
    private static final int AV_DICT_DEDUP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AV_DICT_DEDUP 128
     * }
     */
    public static int AV_DICT_DEDUP() {
        return AV_DICT_DEDUP;
    }
    private static final int AV_PKT_FLAG_KEY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_KEY 1
     * }
     */
    public static int AV_PKT_FLAG_KEY() {
        return AV_PKT_FLAG_KEY;
    }
    private static final int AV_PKT_FLAG_CORRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_CORRUPT 2
     * }
     */
    public static int AV_PKT_FLAG_CORRUPT() {
        return AV_PKT_FLAG_CORRUPT;
    }
    private static final int AV_PKT_FLAG_DISCARD = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_DISCARD 4
     * }
     */
    public static int AV_PKT_FLAG_DISCARD() {
        return AV_PKT_FLAG_DISCARD;
    }
    private static final int AV_PKT_FLAG_TRUSTED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_TRUSTED 8
     * }
     */
    public static int AV_PKT_FLAG_TRUSTED() {
        return AV_PKT_FLAG_TRUSTED;
    }
    private static final int AV_PKT_FLAG_DISPOSABLE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AV_PKT_FLAG_DISPOSABLE 16
     * }
     */
    public static int AV_PKT_FLAG_DISPOSABLE() {
        return AV_PKT_FLAG_DISPOSABLE;
    }
    private static final int LIBAVFORMAT_VERSION_MAJOR = (int)62L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MAJOR 62
     * }
     */
    public static int LIBAVFORMAT_VERSION_MAJOR() {
        return LIBAVFORMAT_VERSION_MAJOR;
    }
    private static final int FF_API_R_FRAME_RATE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_R_FRAME_RATE 1
     * }
     */
    public static int FF_API_R_FRAME_RATE() {
        return FF_API_R_FRAME_RATE;
    }
    private static final int AVSEEK_SIZE = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_SIZE 65536
     * }
     */
    public static int AVSEEK_SIZE() {
        return AVSEEK_SIZE;
    }
    private static final int AVSEEK_FORCE = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FORCE 131072
     * }
     */
    public static int AVSEEK_FORCE() {
        return AVSEEK_FORCE;
    }
    private static final int AVIO_FLAG_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_READ 1
     * }
     */
    public static int AVIO_FLAG_READ() {
        return AVIO_FLAG_READ;
    }
    private static final int AVIO_FLAG_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_WRITE 2
     * }
     */
    public static int AVIO_FLAG_WRITE() {
        return AVIO_FLAG_WRITE;
    }
    private static final int AVIO_FLAG_NONBLOCK = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_NONBLOCK 8
     * }
     */
    public static int AVIO_FLAG_NONBLOCK() {
        return AVIO_FLAG_NONBLOCK;
    }
    private static final int AVIO_FLAG_DIRECT = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AVIO_FLAG_DIRECT 32768
     * }
     */
    public static int AVIO_FLAG_DIRECT() {
        return AVIO_FLAG_DIRECT;
    }
    private static final int LIBAVFORMAT_VERSION_MINOR = (int)3L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MINOR 3
     * }
     */
    public static int LIBAVFORMAT_VERSION_MINOR() {
        return LIBAVFORMAT_VERSION_MINOR;
    }
    private static final int LIBAVFORMAT_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFORMAT_VERSION_MICRO 100
     * }
     */
    public static int LIBAVFORMAT_VERSION_MICRO() {
        return LIBAVFORMAT_VERSION_MICRO;
    }
    private static final int AV_NUM_DATA_POINTERS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AV_NUM_DATA_POINTERS 8
     * }
     */
    public static int AV_NUM_DATA_POINTERS() {
        return AV_NUM_DATA_POINTERS;
    }
    private static final int FF_DECODE_ERROR_INVALID_BITSTREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_INVALID_BITSTREAM 1
     * }
     */
    public static int FF_DECODE_ERROR_INVALID_BITSTREAM() {
        return FF_DECODE_ERROR_INVALID_BITSTREAM;
    }
    private static final int FF_DECODE_ERROR_MISSING_REFERENCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_MISSING_REFERENCE 2
     * }
     */
    public static int FF_DECODE_ERROR_MISSING_REFERENCE() {
        return FF_DECODE_ERROR_MISSING_REFERENCE;
    }
    private static final int FF_DECODE_ERROR_CONCEALMENT_ACTIVE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_CONCEALMENT_ACTIVE 4
     * }
     */
    public static int FF_DECODE_ERROR_CONCEALMENT_ACTIVE() {
        return FF_DECODE_ERROR_CONCEALMENT_ACTIVE;
    }
    private static final int FF_DECODE_ERROR_DECODE_SLICES = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_DECODE_ERROR_DECODE_SLICES 8
     * }
     */
    public static int FF_DECODE_ERROR_DECODE_SLICES() {
        return FF_DECODE_ERROR_DECODE_SLICES;
    }
    private static final int AVPROBE_SCORE_EXTENSION = (int)50L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_EXTENSION 50
     * }
     */
    public static int AVPROBE_SCORE_EXTENSION() {
        return AVPROBE_SCORE_EXTENSION;
    }
    private static final int AVPROBE_SCORE_MIME_BONUS = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_MIME_BONUS 30
     * }
     */
    public static int AVPROBE_SCORE_MIME_BONUS() {
        return AVPROBE_SCORE_MIME_BONUS;
    }
    private static final int AVPROBE_SCORE_MAX = (int)100L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_SCORE_MAX 100
     * }
     */
    public static int AVPROBE_SCORE_MAX() {
        return AVPROBE_SCORE_MAX;
    }
    private static final int AVPROBE_PADDING_SIZE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AVPROBE_PADDING_SIZE 32
     * }
     */
    public static int AVPROBE_PADDING_SIZE() {
        return AVPROBE_PADDING_SIZE;
    }
    private static final int AVFMT_NOFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOFILE 1
     * }
     */
    public static int AVFMT_NOFILE() {
        return AVFMT_NOFILE;
    }
    private static final int AVFMT_NEEDNUMBER = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NEEDNUMBER 2
     * }
     */
    public static int AVFMT_NEEDNUMBER() {
        return AVFMT_NEEDNUMBER;
    }
    private static final int AVFMT_EXPERIMENTAL = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_EXPERIMENTAL 4
     * }
     */
    public static int AVFMT_EXPERIMENTAL() {
        return AVFMT_EXPERIMENTAL;
    }
    private static final int AVFMT_SHOW_IDS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_SHOW_IDS 8
     * }
     */
    public static int AVFMT_SHOW_IDS() {
        return AVFMT_SHOW_IDS;
    }
    private static final int AVFMT_GLOBALHEADER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_GLOBALHEADER 64
     * }
     */
    public static int AVFMT_GLOBALHEADER() {
        return AVFMT_GLOBALHEADER;
    }
    private static final int AVFMT_NOTIMESTAMPS = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOTIMESTAMPS 128
     * }
     */
    public static int AVFMT_NOTIMESTAMPS() {
        return AVFMT_NOTIMESTAMPS;
    }
    private static final int AVFMT_GENERIC_INDEX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_GENERIC_INDEX 256
     * }
     */
    public static int AVFMT_GENERIC_INDEX() {
        return AVFMT_GENERIC_INDEX;
    }
    private static final int AVFMT_TS_DISCONT = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_DISCONT 512
     * }
     */
    public static int AVFMT_TS_DISCONT() {
        return AVFMT_TS_DISCONT;
    }
    private static final int AVFMT_VARIABLE_FPS = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_VARIABLE_FPS 1024
     * }
     */
    public static int AVFMT_VARIABLE_FPS() {
        return AVFMT_VARIABLE_FPS;
    }
    private static final int AVFMT_NODIMENSIONS = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NODIMENSIONS 2048
     * }
     */
    public static int AVFMT_NODIMENSIONS() {
        return AVFMT_NODIMENSIONS;
    }
    private static final int AVFMT_NOSTREAMS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOSTREAMS 4096
     * }
     */
    public static int AVFMT_NOSTREAMS() {
        return AVFMT_NOSTREAMS;
    }
    private static final int AVFMT_NOBINSEARCH = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOBINSEARCH 8192
     * }
     */
    public static int AVFMT_NOBINSEARCH() {
        return AVFMT_NOBINSEARCH;
    }
    private static final int AVFMT_NOGENSEARCH = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NOGENSEARCH 16384
     * }
     */
    public static int AVFMT_NOGENSEARCH() {
        return AVFMT_NOGENSEARCH;
    }
    private static final int AVFMT_NO_BYTE_SEEK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_NO_BYTE_SEEK 32768
     * }
     */
    public static int AVFMT_NO_BYTE_SEEK() {
        return AVFMT_NO_BYTE_SEEK;
    }
    private static final int AVFMT_TS_NONSTRICT = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_NONSTRICT 131072
     * }
     */
    public static int AVFMT_TS_NONSTRICT() {
        return AVFMT_TS_NONSTRICT;
    }
    private static final int AVFMT_TS_NEGATIVE = (int)262144L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_TS_NEGATIVE 262144
     * }
     */
    public static int AVFMT_TS_NEGATIVE() {
        return AVFMT_TS_NEGATIVE;
    }
    private static final int AVFMT_SEEK_TO_PTS = (int)67108864L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_SEEK_TO_PTS 67108864
     * }
     */
    public static int AVFMT_SEEK_TO_PTS() {
        return AVFMT_SEEK_TO_PTS;
    }
    private static final int AVINDEX_KEYFRAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVINDEX_KEYFRAME 1
     * }
     */
    public static int AVINDEX_KEYFRAME() {
        return AVINDEX_KEYFRAME;
    }
    private static final int AVINDEX_DISCARD_FRAME = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVINDEX_DISCARD_FRAME 2
     * }
     */
    public static int AVINDEX_DISCARD_FRAME() {
        return AVINDEX_DISCARD_FRAME;
    }
    private static final int AV_PTS_WRAP_IGNORE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AV_PTS_WRAP_IGNORE 0
     * }
     */
    public static int AV_PTS_WRAP_IGNORE() {
        return AV_PTS_WRAP_IGNORE;
    }
    private static final int AV_PTS_WRAP_ADD_OFFSET = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PTS_WRAP_ADD_OFFSET 1
     * }
     */
    public static int AV_PTS_WRAP_ADD_OFFSET() {
        return AV_PTS_WRAP_ADD_OFFSET;
    }
    private static final int AVSTREAM_EVENT_FLAG_METADATA_UPDATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_EVENT_FLAG_METADATA_UPDATED 1
     * }
     */
    public static int AVSTREAM_EVENT_FLAG_METADATA_UPDATED() {
        return AVSTREAM_EVENT_FLAG_METADATA_UPDATED;
    }
    private static final int AV_PROGRAM_RUNNING = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_PROGRAM_RUNNING 1
     * }
     */
    public static int AV_PROGRAM_RUNNING() {
        return AV_PROGRAM_RUNNING;
    }
    private static final int AVFMTCTX_NOHEADER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMTCTX_NOHEADER 1
     * }
     */
    public static int AVFMTCTX_NOHEADER() {
        return AVFMTCTX_NOHEADER;
    }
    private static final int AVFMTCTX_UNSEEKABLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMTCTX_UNSEEKABLE 2
     * }
     */
    public static int AVFMTCTX_UNSEEKABLE() {
        return AVFMTCTX_UNSEEKABLE;
    }
    private static final int AVFMT_FLAG_GENPTS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_GENPTS 1
     * }
     */
    public static int AVFMT_FLAG_GENPTS() {
        return AVFMT_FLAG_GENPTS;
    }
    private static final int AVFMT_FLAG_IGNIDX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_IGNIDX 2
     * }
     */
    public static int AVFMT_FLAG_IGNIDX() {
        return AVFMT_FLAG_IGNIDX;
    }
    private static final int AVFMT_FLAG_NONBLOCK = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NONBLOCK 4
     * }
     */
    public static int AVFMT_FLAG_NONBLOCK() {
        return AVFMT_FLAG_NONBLOCK;
    }
    private static final int AVFMT_FLAG_IGNDTS = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_IGNDTS 8
     * }
     */
    public static int AVFMT_FLAG_IGNDTS() {
        return AVFMT_FLAG_IGNDTS;
    }
    private static final int AVFMT_FLAG_NOFILLIN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOFILLIN 16
     * }
     */
    public static int AVFMT_FLAG_NOFILLIN() {
        return AVFMT_FLAG_NOFILLIN;
    }
    private static final int AVFMT_FLAG_NOPARSE = (int)32L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOPARSE 32
     * }
     */
    public static int AVFMT_FLAG_NOPARSE() {
        return AVFMT_FLAG_NOPARSE;
    }
    private static final int AVFMT_FLAG_NOBUFFER = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_NOBUFFER 64
     * }
     */
    public static int AVFMT_FLAG_NOBUFFER() {
        return AVFMT_FLAG_NOBUFFER;
    }
    private static final int AVFMT_FLAG_CUSTOM_IO = (int)128L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_CUSTOM_IO 128
     * }
     */
    public static int AVFMT_FLAG_CUSTOM_IO() {
        return AVFMT_FLAG_CUSTOM_IO;
    }
    private static final int AVFMT_FLAG_DISCARD_CORRUPT = (int)256L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_DISCARD_CORRUPT 256
     * }
     */
    public static int AVFMT_FLAG_DISCARD_CORRUPT() {
        return AVFMT_FLAG_DISCARD_CORRUPT;
    }
    private static final int AVFMT_FLAG_FLUSH_PACKETS = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_FLUSH_PACKETS 512
     * }
     */
    public static int AVFMT_FLAG_FLUSH_PACKETS() {
        return AVFMT_FLAG_FLUSH_PACKETS;
    }
    private static final int AVFMT_FLAG_BITEXACT = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_BITEXACT 1024
     * }
     */
    public static int AVFMT_FLAG_BITEXACT() {
        return AVFMT_FLAG_BITEXACT;
    }
    private static final int AVFMT_FLAG_SORT_DTS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_SORT_DTS 65536
     * }
     */
    public static int AVFMT_FLAG_SORT_DTS() {
        return AVFMT_FLAG_SORT_DTS;
    }
    private static final int AVFMT_FLAG_FAST_SEEK = (int)524288L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_FAST_SEEK 524288
     * }
     */
    public static int AVFMT_FLAG_FAST_SEEK() {
        return AVFMT_FLAG_FAST_SEEK;
    }
    private static final int AVFMT_FLAG_AUTO_BSF = (int)2097152L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_FLAG_AUTO_BSF 2097152
     * }
     */
    public static int AVFMT_FLAG_AUTO_BSF() {
        return AVFMT_FLAG_AUTO_BSF;
    }
    private static final int FF_FDEBUG_TS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_FDEBUG_TS 1
     * }
     */
    public static int FF_FDEBUG_TS() {
        return FF_FDEBUG_TS;
    }
    private static final int AVFMT_EVENT_FLAG_METADATA_UPDATED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_EVENT_FLAG_METADATA_UPDATED 1
     * }
     */
    public static int AVFMT_EVENT_FLAG_METADATA_UPDATED() {
        return AVFMT_EVENT_FLAG_METADATA_UPDATED;
    }
    private static final int AVFMT_AVOID_NEG_TS_DISABLED = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_DISABLED 0
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_DISABLED() {
        return AVFMT_AVOID_NEG_TS_DISABLED;
    }
    private static final int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE 1
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE() {
        return AVFMT_AVOID_NEG_TS_MAKE_NON_NEGATIVE;
    }
    private static final int AVFMT_AVOID_NEG_TS_MAKE_ZERO = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFMT_AVOID_NEG_TS_MAKE_ZERO 2
     * }
     */
    public static int AVFMT_AVOID_NEG_TS_MAKE_ZERO() {
        return AVFMT_AVOID_NEG_TS_MAKE_ZERO;
    }
    private static final int AVSEEK_FLAG_BACKWARD = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_BACKWARD 1
     * }
     */
    public static int AVSEEK_FLAG_BACKWARD() {
        return AVSEEK_FLAG_BACKWARD;
    }
    private static final int AVSEEK_FLAG_BYTE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_BYTE 2
     * }
     */
    public static int AVSEEK_FLAG_BYTE() {
        return AVSEEK_FLAG_BYTE;
    }
    private static final int AVSEEK_FLAG_ANY = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_ANY 4
     * }
     */
    public static int AVSEEK_FLAG_ANY() {
        return AVSEEK_FLAG_ANY;
    }
    private static final int AVSEEK_FLAG_FRAME = (int)8L;
    /**
     * {@snippet lang=c :
     * #define AVSEEK_FLAG_FRAME 8
     * }
     */
    public static int AVSEEK_FLAG_FRAME() {
        return AVSEEK_FLAG_FRAME;
    }
    private static final int AVSTREAM_INIT_IN_WRITE_HEADER = (int)0L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_INIT_IN_WRITE_HEADER 0
     * }
     */
    public static int AVSTREAM_INIT_IN_WRITE_HEADER() {
        return AVSTREAM_INIT_IN_WRITE_HEADER;
    }
    private static final int AVSTREAM_INIT_IN_INIT_OUTPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVSTREAM_INIT_IN_INIT_OUTPUT 1
     * }
     */
    public static int AVSTREAM_INIT_IN_INIT_OUTPUT() {
        return AVSTREAM_INIT_IN_INIT_OUTPUT;
    }
    private static final int AV_FRAME_FILENAME_FLAGS_MULTIPLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_FRAME_FILENAME_FLAGS_MULTIPLE 1
     * }
     */
    public static int AV_FRAME_FILENAME_FLAGS_MULTIPLE() {
        return AV_FRAME_FILENAME_FLAGS_MULTIPLE;
    }
    private static final int LIBAVCODEC_VERSION_MINOR = (int)11L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MINOR 11
     * }
     */
    public static int LIBAVCODEC_VERSION_MINOR() {
        return LIBAVCODEC_VERSION_MINOR;
    }
    private static final int LIBAVCODEC_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVCODEC_VERSION_MICRO 100
     * }
     */
    public static int LIBAVCODEC_VERSION_MICRO() {
        return LIBAVCODEC_VERSION_MICRO;
    }
    private static final int SLICE_FLAG_CODED_ORDER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_CODED_ORDER 1
     * }
     */
    public static int SLICE_FLAG_CODED_ORDER() {
        return SLICE_FLAG_CODED_ORDER;
    }
    private static final int SLICE_FLAG_ALLOW_FIELD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_ALLOW_FIELD 2
     * }
     */
    public static int SLICE_FLAG_ALLOW_FIELD() {
        return SLICE_FLAG_ALLOW_FIELD;
    }
    private static final int SLICE_FLAG_ALLOW_PLANE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SLICE_FLAG_ALLOW_PLANE 4
     * }
     */
    public static int SLICE_FLAG_ALLOW_PLANE() {
        return SLICE_FLAG_ALLOW_PLANE;
    }
    private static final int FF_CMP_SAD = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SAD 0
     * }
     */
    public static int FF_CMP_SAD() {
        return FF_CMP_SAD;
    }
    private static final int FF_CMP_SSE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SSE 1
     * }
     */
    public static int FF_CMP_SSE() {
        return FF_CMP_SSE;
    }
    private static final int FF_CMP_SATD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_SATD 2
     * }
     */
    public static int FF_CMP_SATD() {
        return FF_CMP_SATD;
    }
    private static final int FF_CMP_DCT = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCT 3
     * }
     */
    public static int FF_CMP_DCT() {
        return FF_CMP_DCT;
    }
    private static final int FF_CMP_PSNR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_PSNR 4
     * }
     */
    public static int FF_CMP_PSNR() {
        return FF_CMP_PSNR;
    }
    private static final int FF_CMP_BIT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_BIT 5
     * }
     */
    public static int FF_CMP_BIT() {
        return FF_CMP_BIT;
    }
    private static final int FF_CMP_RD = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_RD 6
     * }
     */
    public static int FF_CMP_RD() {
        return FF_CMP_RD;
    }
    private static final int FF_CMP_ZERO = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_ZERO 7
     * }
     */
    public static int FF_CMP_ZERO() {
        return FF_CMP_ZERO;
    }
    private static final int FF_CMP_VSAD = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_VSAD 8
     * }
     */
    public static int FF_CMP_VSAD() {
        return FF_CMP_VSAD;
    }
    private static final int FF_CMP_VSSE = (int)9L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_VSSE 9
     * }
     */
    public static int FF_CMP_VSSE() {
        return FF_CMP_VSSE;
    }
    private static final int FF_CMP_NSSE = (int)10L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_NSSE 10
     * }
     */
    public static int FF_CMP_NSSE() {
        return FF_CMP_NSSE;
    }
    private static final int FF_CMP_W53 = (int)11L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_W53 11
     * }
     */
    public static int FF_CMP_W53() {
        return FF_CMP_W53;
    }
    private static final int FF_CMP_W97 = (int)12L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_W97 12
     * }
     */
    public static int FF_CMP_W97() {
        return FF_CMP_W97;
    }
    private static final int FF_CMP_DCTMAX = (int)13L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCTMAX 13
     * }
     */
    public static int FF_CMP_DCTMAX() {
        return FF_CMP_DCTMAX;
    }
    private static final int FF_CMP_DCT264 = (int)14L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_DCT264 14
     * }
     */
    public static int FF_CMP_DCT264() {
        return FF_CMP_DCT264;
    }
    private static final int FF_CMP_MEDIAN_SAD = (int)15L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_MEDIAN_SAD 15
     * }
     */
    public static int FF_CMP_MEDIAN_SAD() {
        return FF_CMP_MEDIAN_SAD;
    }
    private static final int FF_CMP_CHROMA = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_CMP_CHROMA 256
     * }
     */
    public static int FF_CMP_CHROMA() {
        return FF_CMP_CHROMA;
    }
    private static final int FF_MB_DECISION_SIMPLE = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_SIMPLE 0
     * }
     */
    public static int FF_MB_DECISION_SIMPLE() {
        return FF_MB_DECISION_SIMPLE;
    }
    private static final int FF_MB_DECISION_BITS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_BITS 1
     * }
     */
    public static int FF_MB_DECISION_BITS() {
        return FF_MB_DECISION_BITS;
    }
    private static final int FF_MB_DECISION_RD = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_MB_DECISION_RD 2
     * }
     */
    public static int FF_MB_DECISION_RD() {
        return FF_MB_DECISION_RD;
    }
    private static final int FF_BUG_AUTODETECT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_AUTODETECT 1
     * }
     */
    public static int FF_BUG_AUTODETECT() {
        return FF_BUG_AUTODETECT;
    }
    private static final int FF_BUG_XVID_ILACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_XVID_ILACE 4
     * }
     */
    public static int FF_BUG_XVID_ILACE() {
        return FF_BUG_XVID_ILACE;
    }
    private static final int FF_BUG_UMP4 = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_UMP4 8
     * }
     */
    public static int FF_BUG_UMP4() {
        return FF_BUG_UMP4;
    }
    private static final int FF_BUG_NO_PADDING = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_NO_PADDING 16
     * }
     */
    public static int FF_BUG_NO_PADDING() {
        return FF_BUG_NO_PADDING;
    }
    private static final int FF_BUG_AMV = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_AMV 32
     * }
     */
    public static int FF_BUG_AMV() {
        return FF_BUG_AMV;
    }
    private static final int FF_BUG_QPEL_CHROMA = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_QPEL_CHROMA 64
     * }
     */
    public static int FF_BUG_QPEL_CHROMA() {
        return FF_BUG_QPEL_CHROMA;
    }
    private static final int FF_BUG_STD_QPEL = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_STD_QPEL 128
     * }
     */
    public static int FF_BUG_STD_QPEL() {
        return FF_BUG_STD_QPEL;
    }
    private static final int FF_BUG_QPEL_CHROMA2 = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_QPEL_CHROMA2 256
     * }
     */
    public static int FF_BUG_QPEL_CHROMA2() {
        return FF_BUG_QPEL_CHROMA2;
    }
    private static final int FF_BUG_DIRECT_BLOCKSIZE = (int)512L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_DIRECT_BLOCKSIZE 512
     * }
     */
    public static int FF_BUG_DIRECT_BLOCKSIZE() {
        return FF_BUG_DIRECT_BLOCKSIZE;
    }
    private static final int FF_BUG_EDGE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_EDGE 1024
     * }
     */
    public static int FF_BUG_EDGE() {
        return FF_BUG_EDGE;
    }
    private static final int FF_BUG_HPEL_CHROMA = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_HPEL_CHROMA 2048
     * }
     */
    public static int FF_BUG_HPEL_CHROMA() {
        return FF_BUG_HPEL_CHROMA;
    }
    private static final int FF_BUG_DC_CLIP = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_DC_CLIP 4096
     * }
     */
    public static int FF_BUG_DC_CLIP() {
        return FF_BUG_DC_CLIP;
    }
    private static final int FF_BUG_MS = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_MS 8192
     * }
     */
    public static int FF_BUG_MS() {
        return FF_BUG_MS;
    }
    private static final int FF_BUG_TRUNCATED = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_TRUNCATED 16384
     * }
     */
    public static int FF_BUG_TRUNCATED() {
        return FF_BUG_TRUNCATED;
    }
    private static final int FF_BUG_IEDGE = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FF_BUG_IEDGE 32768
     * }
     */
    public static int FF_BUG_IEDGE() {
        return FF_BUG_IEDGE;
    }
    private static final int FF_EC_GUESS_MVS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_GUESS_MVS 1
     * }
     */
    public static int FF_EC_GUESS_MVS() {
        return FF_EC_GUESS_MVS;
    }
    private static final int FF_EC_DEBLOCK = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_DEBLOCK 2
     * }
     */
    public static int FF_EC_DEBLOCK() {
        return FF_EC_DEBLOCK;
    }
    private static final int FF_EC_FAVOR_INTER = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_EC_FAVOR_INTER 256
     * }
     */
    public static int FF_EC_FAVOR_INTER() {
        return FF_EC_FAVOR_INTER;
    }
    private static final int FF_DEBUG_PICT_INFO = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_PICT_INFO 1
     * }
     */
    public static int FF_DEBUG_PICT_INFO() {
        return FF_DEBUG_PICT_INFO;
    }
    private static final int FF_DEBUG_RC = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_RC 2
     * }
     */
    public static int FF_DEBUG_RC() {
        return FF_DEBUG_RC;
    }
    private static final int FF_DEBUG_BITSTREAM = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BITSTREAM 4
     * }
     */
    public static int FF_DEBUG_BITSTREAM() {
        return FF_DEBUG_BITSTREAM;
    }
    private static final int FF_DEBUG_MB_TYPE = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_MB_TYPE 8
     * }
     */
    public static int FF_DEBUG_MB_TYPE() {
        return FF_DEBUG_MB_TYPE;
    }
    private static final int FF_DEBUG_QP = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_QP 16
     * }
     */
    public static int FF_DEBUG_QP() {
        return FF_DEBUG_QP;
    }
    private static final int FF_DEBUG_DCT_COEFF = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_DCT_COEFF 64
     * }
     */
    public static int FF_DEBUG_DCT_COEFF() {
        return FF_DEBUG_DCT_COEFF;
    }
    private static final int FF_DEBUG_SKIP = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_SKIP 128
     * }
     */
    public static int FF_DEBUG_SKIP() {
        return FF_DEBUG_SKIP;
    }
    private static final int FF_DEBUG_STARTCODE = (int)256L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_STARTCODE 256
     * }
     */
    public static int FF_DEBUG_STARTCODE() {
        return FF_DEBUG_STARTCODE;
    }
    private static final int FF_DEBUG_ER = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_ER 1024
     * }
     */
    public static int FF_DEBUG_ER() {
        return FF_DEBUG_ER;
    }
    private static final int FF_DEBUG_MMCO = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_MMCO 2048
     * }
     */
    public static int FF_DEBUG_MMCO() {
        return FF_DEBUG_MMCO;
    }
    private static final int FF_DEBUG_BUGS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BUGS 4096
     * }
     */
    public static int FF_DEBUG_BUGS() {
        return FF_DEBUG_BUGS;
    }
    private static final int FF_DEBUG_BUFFERS = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_BUFFERS 32768
     * }
     */
    public static int FF_DEBUG_BUFFERS() {
        return FF_DEBUG_BUFFERS;
    }
    private static final int FF_DEBUG_THREADS = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_THREADS 65536
     * }
     */
    public static int FF_DEBUG_THREADS() {
        return FF_DEBUG_THREADS;
    }
    private static final int FF_DEBUG_GREEN_MD = (int)8388608L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_GREEN_MD 8388608
     * }
     */
    public static int FF_DEBUG_GREEN_MD() {
        return FF_DEBUG_GREEN_MD;
    }
    private static final int FF_DEBUG_NOMC = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define FF_DEBUG_NOMC 16777216
     * }
     */
    public static int FF_DEBUG_NOMC() {
        return FF_DEBUG_NOMC;
    }
    private static final int FF_DCT_AUTO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_AUTO 0
     * }
     */
    public static int FF_DCT_AUTO() {
        return FF_DCT_AUTO;
    }
    private static final int FF_DCT_FASTINT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_FASTINT 1
     * }
     */
    public static int FF_DCT_FASTINT() {
        return FF_DCT_FASTINT;
    }
    private static final int FF_DCT_INT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_INT 2
     * }
     */
    public static int FF_DCT_INT() {
        return FF_DCT_INT;
    }
    private static final int FF_DCT_MMX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_MMX 3
     * }
     */
    public static int FF_DCT_MMX() {
        return FF_DCT_MMX;
    }
    private static final int FF_DCT_ALTIVEC = (int)5L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_ALTIVEC 5
     * }
     */
    public static int FF_DCT_ALTIVEC() {
        return FF_DCT_ALTIVEC;
    }
    private static final int FF_DCT_FAAN = (int)6L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_FAAN 6
     * }
     */
    public static int FF_DCT_FAAN() {
        return FF_DCT_FAAN;
    }
    private static final int FF_DCT_NEON = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_DCT_NEON 7
     * }
     */
    public static int FF_DCT_NEON() {
        return FF_DCT_NEON;
    }
    private static final int FF_IDCT_AUTO = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_AUTO 0
     * }
     */
    public static int FF_IDCT_AUTO() {
        return FF_IDCT_AUTO;
    }
    private static final int FF_IDCT_INT = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_INT 1
     * }
     */
    public static int FF_IDCT_INT() {
        return FF_IDCT_INT;
    }
    private static final int FF_IDCT_SIMPLE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLE 2
     * }
     */
    public static int FF_IDCT_SIMPLE() {
        return FF_IDCT_SIMPLE;
    }
    private static final int FF_IDCT_SIMPLEMMX = (int)3L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEMMX 3
     * }
     */
    public static int FF_IDCT_SIMPLEMMX() {
        return FF_IDCT_SIMPLEMMX;
    }
    private static final int FF_IDCT_ARM = (int)7L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_ARM 7
     * }
     */
    public static int FF_IDCT_ARM() {
        return FF_IDCT_ARM;
    }
    private static final int FF_IDCT_ALTIVEC = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_ALTIVEC 8
     * }
     */
    public static int FF_IDCT_ALTIVEC() {
        return FF_IDCT_ALTIVEC;
    }
    private static final int FF_IDCT_SIMPLEARM = (int)10L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARM 10
     * }
     */
    public static int FF_IDCT_SIMPLEARM() {
        return FF_IDCT_SIMPLEARM;
    }
    private static final int FF_IDCT_XVID = (int)14L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_XVID 14
     * }
     */
    public static int FF_IDCT_XVID() {
        return FF_IDCT_XVID;
    }
    private static final int FF_IDCT_SIMPLEARMV5TE = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARMV5TE 16
     * }
     */
    public static int FF_IDCT_SIMPLEARMV5TE() {
        return FF_IDCT_SIMPLEARMV5TE;
    }
    private static final int FF_IDCT_SIMPLEARMV6 = (int)17L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEARMV6 17
     * }
     */
    public static int FF_IDCT_SIMPLEARMV6() {
        return FF_IDCT_SIMPLEARMV6;
    }
    private static final int FF_IDCT_FAAN = (int)20L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_FAAN 20
     * }
     */
    public static int FF_IDCT_FAAN() {
        return FF_IDCT_FAAN;
    }
    private static final int FF_IDCT_SIMPLENEON = (int)22L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLENEON 22
     * }
     */
    public static int FF_IDCT_SIMPLENEON() {
        return FF_IDCT_SIMPLENEON;
    }
    private static final int FF_IDCT_SIMPLEAUTO = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_IDCT_SIMPLEAUTO 128
     * }
     */
    public static int FF_IDCT_SIMPLEAUTO() {
        return FF_IDCT_SIMPLEAUTO;
    }
    private static final int FF_THREAD_FRAME = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_THREAD_FRAME 1
     * }
     */
    public static int FF_THREAD_FRAME() {
        return FF_THREAD_FRAME;
    }
    private static final int FF_THREAD_SLICE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_THREAD_SLICE 2
     * }
     */
    public static int FF_THREAD_SLICE() {
        return FF_THREAD_SLICE;
    }
    private static final int FF_CODEC_PROPERTY_LOSSLESS = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_LOSSLESS 1
     * }
     */
    public static int FF_CODEC_PROPERTY_LOSSLESS() {
        return FF_CODEC_PROPERTY_LOSSLESS;
    }
    private static final int FF_CODEC_PROPERTY_CLOSED_CAPTIONS = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_CLOSED_CAPTIONS 2
     * }
     */
    public static int FF_CODEC_PROPERTY_CLOSED_CAPTIONS() {
        return FF_CODEC_PROPERTY_CLOSED_CAPTIONS;
    }
    private static final int FF_CODEC_PROPERTY_FILM_GRAIN = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_CODEC_PROPERTY_FILM_GRAIN 4
     * }
     */
    public static int FF_CODEC_PROPERTY_FILM_GRAIN() {
        return FF_CODEC_PROPERTY_FILM_GRAIN;
    }
    private static final int FF_SUB_CHARENC_MODE_AUTOMATIC = (int)0L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_AUTOMATIC 0
     * }
     */
    public static int FF_SUB_CHARENC_MODE_AUTOMATIC() {
        return FF_SUB_CHARENC_MODE_AUTOMATIC;
    }
    private static final int FF_SUB_CHARENC_MODE_PRE_DECODER = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_PRE_DECODER 1
     * }
     */
    public static int FF_SUB_CHARENC_MODE_PRE_DECODER() {
        return FF_SUB_CHARENC_MODE_PRE_DECODER;
    }
    private static final int FF_SUB_CHARENC_MODE_IGNORE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_SUB_CHARENC_MODE_IGNORE 2
     * }
     */
    public static int FF_SUB_CHARENC_MODE_IGNORE() {
        return FF_SUB_CHARENC_MODE_IGNORE;
    }
    private static final int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL = (int)512L;
    /**
     * {@snippet lang=c :
     * #define AV_HWACCEL_CODEC_CAP_EXPERIMENTAL 512
     * }
     */
    public static int AV_HWACCEL_CODEC_CAP_EXPERIMENTAL() {
        return AV_HWACCEL_CODEC_CAP_EXPERIMENTAL;
    }
    private static final int AV_SUBTITLE_FLAG_FORCED = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_SUBTITLE_FLAG_FORCED 1
     * }
     */
    public static int AV_SUBTITLE_FLAG_FORCED() {
        return AV_SUBTITLE_FLAG_FORCED;
    }
    private static final int AV_PARSER_PTS_NB = (int)4L;
    /**
     * {@snippet lang=c :
     * #define AV_PARSER_PTS_NB 4
     * }
     */
    public static int AV_PARSER_PTS_NB() {
        return AV_PARSER_PTS_NB;
    }
    private static final int PARSER_FLAG_COMPLETE_FRAMES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_COMPLETE_FRAMES 1
     * }
     */
    public static int PARSER_FLAG_COMPLETE_FRAMES() {
        return PARSER_FLAG_COMPLETE_FRAMES;
    }
    private static final int PARSER_FLAG_ONCE = (int)2L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_ONCE 2
     * }
     */
    public static int PARSER_FLAG_ONCE() {
        return PARSER_FLAG_ONCE;
    }
    private static final int PARSER_FLAG_FETCHED_OFFSET = (int)4L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_FETCHED_OFFSET 4
     * }
     */
    public static int PARSER_FLAG_FETCHED_OFFSET() {
        return PARSER_FLAG_FETCHED_OFFSET;
    }
    private static final int PARSER_FLAG_USE_CODEC_TS = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PARSER_FLAG_USE_CODEC_TS 4096
     * }
     */
    public static int PARSER_FLAG_USE_CODEC_TS() {
        return PARSER_FLAG_USE_CODEC_TS;
    }
    private static final int FF_LOSS_RESOLUTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_RESOLUTION 1
     * }
     */
    public static int FF_LOSS_RESOLUTION() {
        return FF_LOSS_RESOLUTION;
    }
    private static final int FF_LOSS_DEPTH = (int)2L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_DEPTH 2
     * }
     */
    public static int FF_LOSS_DEPTH() {
        return FF_LOSS_DEPTH;
    }
    private static final int FF_LOSS_COLORSPACE = (int)4L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_COLORSPACE 4
     * }
     */
    public static int FF_LOSS_COLORSPACE() {
        return FF_LOSS_COLORSPACE;
    }
    private static final int FF_LOSS_ALPHA = (int)8L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_ALPHA 8
     * }
     */
    public static int FF_LOSS_ALPHA() {
        return FF_LOSS_ALPHA;
    }
    private static final int FF_LOSS_COLORQUANT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_COLORQUANT 16
     * }
     */
    public static int FF_LOSS_COLORQUANT() {
        return FF_LOSS_COLORQUANT;
    }
    private static final int FF_LOSS_CHROMA = (int)32L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_CHROMA 32
     * }
     */
    public static int FF_LOSS_CHROMA() {
        return FF_LOSS_CHROMA;
    }
    private static final int FF_LOSS_EXCESS_RESOLUTION = (int)64L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_EXCESS_RESOLUTION 64
     * }
     */
    public static int FF_LOSS_EXCESS_RESOLUTION() {
        return FF_LOSS_EXCESS_RESOLUTION;
    }
    private static final int FF_LOSS_EXCESS_DEPTH = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_LOSS_EXCESS_DEPTH 128
     * }
     */
    public static int FF_LOSS_EXCESS_DEPTH() {
        return FF_LOSS_EXCESS_DEPTH;
    }
    private static final int LIBSWSCALE_VERSION_MAJOR = (int)9L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MAJOR 9
     * }
     */
    public static int LIBSWSCALE_VERSION_MAJOR() {
        return LIBSWSCALE_VERSION_MAJOR;
    }
    private static final int LIBSWSCALE_VERSION_MINOR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MINOR 1
     * }
     */
    public static int LIBSWSCALE_VERSION_MINOR() {
        return LIBSWSCALE_VERSION_MINOR;
    }
    private static final int LIBSWSCALE_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBSWSCALE_VERSION_MICRO 100
     * }
     */
    public static int LIBSWSCALE_VERSION_MICRO() {
        return LIBSWSCALE_VERSION_MICRO;
    }
    private static final int SWS_SRC_V_CHR_DROP_MASK = (int)196608L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_MASK 196608
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_MASK() {
        return SWS_SRC_V_CHR_DROP_MASK;
    }
    private static final int SWS_SRC_V_CHR_DROP_SHIFT = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SWS_SRC_V_CHR_DROP_SHIFT 16
     * }
     */
    public static int SWS_SRC_V_CHR_DROP_SHIFT() {
        return SWS_SRC_V_CHR_DROP_SHIFT;
    }
    private static final int SWS_PARAM_DEFAULT = (int)123456L;
    /**
     * {@snippet lang=c :
     * #define SWS_PARAM_DEFAULT 123456
     * }
     */
    public static int SWS_PARAM_DEFAULT() {
        return SWS_PARAM_DEFAULT;
    }
    private static final int SWS_CS_ITU709 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU709 1
     * }
     */
    public static int SWS_CS_ITU709() {
        return SWS_CS_ITU709;
    }
    private static final int SWS_CS_FCC = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_FCC 4
     * }
     */
    public static int SWS_CS_FCC() {
        return SWS_CS_FCC;
    }
    private static final int SWS_CS_ITU601 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU601 5
     * }
     */
    public static int SWS_CS_ITU601() {
        return SWS_CS_ITU601;
    }
    private static final int SWS_CS_ITU624 = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_ITU624 5
     * }
     */
    public static int SWS_CS_ITU624() {
        return SWS_CS_ITU624;
    }
    private static final int SWS_CS_SMPTE170M = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE170M 5
     * }
     */
    public static int SWS_CS_SMPTE170M() {
        return SWS_CS_SMPTE170M;
    }
    private static final int SWS_CS_SMPTE240M = (int)7L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_SMPTE240M 7
     * }
     */
    public static int SWS_CS_SMPTE240M() {
        return SWS_CS_SMPTE240M;
    }
    private static final int SWS_CS_DEFAULT = (int)5L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_DEFAULT 5
     * }
     */
    public static int SWS_CS_DEFAULT() {
        return SWS_CS_DEFAULT;
    }
    private static final int SWS_CS_BT2020 = (int)9L;
    /**
     * {@snippet lang=c :
     * #define SWS_CS_BT2020 9
     * }
     */
    public static int SWS_CS_BT2020() {
        return SWS_CS_BT2020;
    }
    private static final int LIBAVFILTER_VERSION_MAJOR = (int)11L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFILTER_VERSION_MAJOR 11
     * }
     */
    public static int LIBAVFILTER_VERSION_MAJOR() {
        return LIBAVFILTER_VERSION_MAJOR;
    }
    private static final int LIBAVFILTER_VERSION_MINOR = (int)4L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFILTER_VERSION_MINOR 4
     * }
     */
    public static int LIBAVFILTER_VERSION_MINOR() {
        return LIBAVFILTER_VERSION_MINOR;
    }
    private static final int LIBAVFILTER_VERSION_MICRO = (int)100L;
    /**
     * {@snippet lang=c :
     * #define LIBAVFILTER_VERSION_MICRO 100
     * }
     */
    public static int LIBAVFILTER_VERSION_MICRO() {
        return LIBAVFILTER_VERSION_MICRO;
    }
    private static final int AVFILTER_CMD_FLAG_ONE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AVFILTER_CMD_FLAG_ONE 1
     * }
     */
    public static int AVFILTER_CMD_FLAG_ONE() {
        return AVFILTER_CMD_FLAG_ONE;
    }
    private static final int AVFILTER_CMD_FLAG_FAST = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AVFILTER_CMD_FLAG_FAST 2
     * }
     */
    public static int AVFILTER_CMD_FLAG_FAST() {
        return AVFILTER_CMD_FLAG_FAST;
    }
    private static final int AV_BUFFERSINK_FLAG_PEEK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define AV_BUFFERSINK_FLAG_PEEK 1
     * }
     */
    public static int AV_BUFFERSINK_FLAG_PEEK() {
        return AV_BUFFERSINK_FLAG_PEEK;
    }
    private static final int AV_BUFFERSINK_FLAG_NO_REQUEST = (int)2L;
    /**
     * {@snippet lang=c :
     * #define AV_BUFFERSINK_FLAG_NO_REQUEST 2
     * }
     */
    public static int AV_BUFFERSINK_FLAG_NO_REQUEST() {
        return AV_BUFFERSINK_FLAG_NO_REQUEST;
    }
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long __int64_t
     * }
     */
    public static final OfLong __int64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_intptr_t
     * }
     */
    public static final OfLong __darwin_intptr_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_natural_t
     * }
     */
    public static final OfInt __darwin_natural_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_ct_rune_t
     * }
     */
    public static final OfInt __darwin_ct_rune_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ptrdiff_t
     * }
     */
    public static final OfLong __darwin_ptrdiff_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_size_t
     * }
     */
    public static final OfLong __darwin_size_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __darwin_va_list
     * }
     */
    public static final AddressLayout __darwin_va_list = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wchar_t
     * }
     */
    public static final OfInt __darwin_wchar_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t __darwin_rune_t
     * }
     */
    public static final OfInt __darwin_rune_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wint_t
     * }
     */
    public static final OfInt __darwin_wint_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_clock_t
     * }
     */
    public static final OfLong __darwin_clock_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_socklen_t
     * }
     */
    public static final OfInt __darwin_socklen_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_ssize_t
     * }
     */
    public static final OfLong __darwin_ssize_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __darwin_time_t
     * }
     */
    public static final OfLong __darwin_time_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_blkcnt_t
     * }
     */
    public static final OfLong __darwin_blkcnt_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_blksize_t
     * }
     */
    public static final OfInt __darwin_blksize_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_dev_t
     * }
     */
    public static final OfInt __darwin_dev_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsblkcnt_t
     * }
     */
    public static final OfInt __darwin_fsblkcnt_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __darwin_fsfilcnt_t
     * }
     */
    public static final OfInt __darwin_fsfilcnt_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_gid_t
     * }
     */
    public static final OfInt __darwin_gid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_id_t
     * }
     */
    public static final OfInt __darwin_id_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __darwin_ino64_t
     * }
     */
    public static final OfLong __darwin_ino64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_ino64_t __darwin_ino_t
     * }
     */
    public static final OfLong __darwin_ino_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_natural_t __darwin_mach_port_name_t
     * }
     */
    public static final OfInt __darwin_mach_port_name_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mach_port_name_t __darwin_mach_port_t
     * }
     */
    public static final OfInt __darwin_mach_port_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __darwin_mode_t
     * }
     */
    public static final OfShort __darwin_mode_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __darwin_off_t
     * }
     */
    public static final OfLong __darwin_off_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_pid_t
     * }
     */
    public static final OfInt __darwin_pid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_sigset_t
     * }
     */
    public static final OfInt __darwin_sigset_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __darwin_suseconds_t
     * }
     */
    public static final OfInt __darwin_suseconds_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_uid_t
     * }
     */
    public static final OfInt __darwin_uid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_useconds_t
     * }
     */
    public static final OfInt __darwin_useconds_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __darwin_pthread_key_t
     * }
     */
    public static final OfLong __darwin_pthread_key_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef struct _opaque_pthread_t {
     *     long __sig;
     *     struct __darwin_pthread_handler_rec *__cleanup_stack;
     *     char __opaque[8176];
     * } *__darwin_pthread_t
     * }
     */
    public static final AddressLayout __darwin_pthread_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_nl_item
     * }
     */
    public static final OfInt __darwin_nl_item = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __darwin_wctrans_t
     * }
     */
    public static final OfInt __darwin_wctrans_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __darwin_wctype_t
     * }
     */
    public static final OfInt __darwin_wctype_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef signed char int8_t
     * }
     */
    public static final OfByte int8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short int16_t
     * }
     */
    public static final OfShort int16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int int32_t
     * }
     */
    public static final OfInt int32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long long int64_t
     * }
     */
    public static final OfLong int64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char u_int8_t
     * }
     */
    public static final OfByte u_int8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short u_int16_t
     * }
     */
    public static final OfShort u_int16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int u_int32_t
     * }
     */
    public static final OfInt u_int32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long u_int64_t
     * }
     */
    public static final OfLong u_int64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t register_t
     * }
     */
    public static final OfLong register_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_intptr_t intptr_t
     * }
     */
    public static final OfLong intptr_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_addr_t
     * }
     */
    public static final OfLong user_addr_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_size_t
     * }
     */
    public static final OfLong user_size_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_ssize_t
     * }
     */
    public static final OfLong user_ssize_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_long_t
     * }
     */
    public static final OfLong user_long_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t user_ulong_t
     * }
     */
    public static final OfLong user_ulong_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_time_t
     * }
     */
    public static final OfLong user_time_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int64_t user_off_t
     * }
     */
    public static final OfLong user_off_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef u_int64_t syscall_arg_t
     * }
     */
    public static final OfLong syscall_arg_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef __darwin_va_list va_list
     * }
     */
    public static final AddressLayout va_list = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t size_t
     * }
     */
    public static final OfLong size_t = FFmpeg.C_LONG;

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameat(int, const char *, int, const char *)
     * }
     */
    public static int renameat(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renamex_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("renamex_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renamex_np$descriptor() {
        return renamex_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MethodHandle renamex_np$handle() {
        return renamex_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static MemorySegment renamex_np$address() {
        return renamex_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renamex_np(const char *, const char *, unsigned int)
     * }
     */
    public static int renamex_np(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = renamex_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renamex_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameatx_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("renameatx_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static FunctionDescriptor renameatx_np$descriptor() {
        return renameatx_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MethodHandle renameatx_np$handle() {
        return renameatx_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static MemorySegment renameatx_np$address() {
        return renameatx_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int renameatx_np(int, const char *, int, const char *, unsigned int)
     * }
     */
    public static int renameatx_np(int x0, MemorySegment x1, int x2, MemorySegment x3, int x4) {
        var mh$ = renameatx_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameatx_np", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int printf(const char *restrict, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int printf(const char *restrict, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t fpos_t
     * }
     */
    public static final OfLong fpos_t = FFmpeg.C_LONG_LONG;

    private static class __stdinp$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__stdinp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static AddressLayout __stdinp$layout() {
        return __stdinp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp$segment() {
        return __stdinp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static MemorySegment __stdinp() {
        return __stdinp$constants.SEGMENT.get(__stdinp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdinp
     * }
     */
    public static void __stdinp(MemorySegment varValue) {
        __stdinp$constants.SEGMENT.set(__stdinp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stdoutp$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__stdoutp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static AddressLayout __stdoutp$layout() {
        return __stdoutp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp$segment() {
        return __stdoutp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static MemorySegment __stdoutp() {
        return __stdoutp$constants.SEGMENT.get(__stdoutp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stdoutp
     * }
     */
    public static void __stdoutp(MemorySegment varValue) {
        __stdoutp$constants.SEGMENT.set(__stdoutp$constants.LAYOUT, 0L, varValue);
    }

    private static class __stderrp$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__stderrp").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static AddressLayout __stderrp$layout() {
        return __stderrp$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp$segment() {
        return __stderrp$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static MemorySegment __stderrp() {
        return __stderrp$constants.SEGMENT.get(__stderrp$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *__stderrp
     * }
     */
    public static void __stderrp(MemorySegment varValue) {
        __stderrp$constants.SEGMENT.set(__stderrp$constants.LAYOUT, 0L, varValue);
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void clearerr(FILE *)
     * }
     */
    public static void clearerr(MemorySegment x0) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fclose(FILE *)
     * }
     */
    public static int fclose(MemorySegment x0) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int feof(FILE *)
     * }
     */
    public static int feof(MemorySegment x0) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ferror(FILE *)
     * }
     */
    public static int ferror(MemorySegment x0) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fflush(FILE *)
     * }
     */
    public static int fflush(MemorySegment x0) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetc(FILE *)
     * }
     */
    public static int fgetc(MemorySegment x0) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fgetpos(FILE *restrict, fpos_t *)
     * }
     */
    public static int fgetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgets(char *restrict, int __size, FILE *)
     * }
     */
    public static MemorySegment fgets(MemorySegment x0, int __size, MemorySegment x2) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", x0, __size, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, __size, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fopen(const char *restrict __filename, const char *restrict __mode)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __mode) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fprintf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fprintf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputc(int, FILE *)
     * }
     */
    public static int fputc(int x0, MemorySegment x1) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fputs(const char *restrict, FILE *restrict)
     * }
     */
    public static int fputs(MemorySegment x0, MemorySegment x1) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fread(void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *freopen(const char *restrict, const char *restrict, FILE *restrict)
     * }
     */
    public static MemorySegment freopen(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int fscanf(FILE *restrict, const char *restrict, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int fscanf(FILE *restrict, const char *restrict, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseek(FILE *, long, int)
     * }
     */
    public static int fseek(MemorySegment x0, long x1, int x2) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fsetpos(FILE *, const fpos_t *)
     * }
     */
    public static int fsetpos(MemorySegment x0, MemorySegment x1) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long ftell(FILE *)
     * }
     */
    public static long ftell(MemorySegment x0) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __nitems, FILE *restrict __stream)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __nitems, MemorySegment __stream) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __nitems, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __nitems, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc(FILE *)
     * }
     */
    public static int getc(MemorySegment x0) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static FunctionDescriptor gets$descriptor() {
        return gets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MethodHandle gets$handle() {
        return gets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets$address() {
        return gets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gets(char *)
     * }
     */
    public static MemorySegment gets(MemorySegment x0) {
        var mh$ = gets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gets", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void perror(const char *)
     * }
     */
    public static void perror(MemorySegment x0) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc(int, FILE *)
     * }
     */
    public static int putc(int x0, MemorySegment x1) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar(int)
     * }
     */
    public static int putchar(int x0) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int puts(const char *)
     * }
     */
    public static int puts(MemorySegment x0) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int remove(const char *)
     * }
     */
    public static int remove(MemorySegment x0) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void rewind(FILE *)
     * }
     */
    public static void rewind(MemorySegment x0) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int scanf(const char *restrict, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int scanf(const char *restrict, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", x0, x1);
                }
                return (int) spreader.invokeExact(x0, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuf(FILE *restrict, char *restrict)
     * }
     */
    public static void setbuf(MemorySegment x0, MemorySegment x1) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", x0, x1);
            }
            mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setvbuf(FILE *restrict, char *restrict, int, size_t __size)
     * }
     */
    public static int setvbuf(MemorySegment x0, MemorySegment x1, int x2, long __size) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", x0, x1, x2, __size);
            }
            return (int)mh$.invokeExact(x0, x1, x2, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sprintf(char *restrict, const char *restrict, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sprintf(char *restrict, const char *restrict, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int sscanf(const char *restrict, const char *restrict, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int sscanf(const char *restrict, const char *restrict, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tmpnam(char *)
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ungetc(int, FILE *)
     * }
     */
    public static int ungetc(int x0, MemorySegment x1) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfprintf(FILE *restrict, const char *restrict, va_list)
     * }
     */
    public static int vfprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vprintf(const char *restrict, va_list)
     * }
     */
    public static int vprintf(MemorySegment x0, MemorySegment x1) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsprintf(char *restrict, const char *restrict, va_list)
     * }
     */
    public static int vsprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid(char *)
     * }
     */
    public static MemorySegment ctermid(MemorySegment x0) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fdopen(int, const char *)
     * }
     */
    public static MemorySegment fdopen(int x0, MemorySegment x1) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fileno(FILE *)
     * }
     */
    public static int fileno(MemorySegment x0) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int pclose(FILE *)
     * }
     */
    public static int pclose(MemorySegment x0) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *popen(const char *, const char *)
     * }
     */
    public static MemorySegment popen(MemorySegment x0, MemorySegment x1) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __srget {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__srget");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static FunctionDescriptor __srget$descriptor() {
        return __srget.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MethodHandle __srget$handle() {
        return __srget.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static MemorySegment __srget$address() {
        return __srget.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __srget(FILE *)
     * }
     */
    public static int __srget(MemorySegment x0) {
        var mh$ = __srget.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__srget", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __svfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__svfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static FunctionDescriptor __svfscanf$descriptor() {
        return __svfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MethodHandle __svfscanf$handle() {
        return __svfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static MemorySegment __svfscanf$address() {
        return __svfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __svfscanf(FILE *, const char *, va_list)
     * }
     */
    public static int __svfscanf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = __svfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__svfscanf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __swbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__swbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static FunctionDescriptor __swbuf$descriptor() {
        return __swbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MethodHandle __swbuf$handle() {
        return __swbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static MemorySegment __swbuf$address() {
        return __swbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int __swbuf(int, FILE *)
     * }
     */
    public static int __swbuf(int x0, MemorySegment x1) {
        var mh$ = __swbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__swbuf", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void flockfile(FILE *)
     * }
     */
    public static void flockfile(MemorySegment x0) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ftrylockfile(FILE *)
     * }
     */
    public static int ftrylockfile(MemorySegment x0) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void funlockfile(FILE *)
     * }
     */
    public static void funlockfile(MemorySegment x0) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getc_unlocked(FILE *)
     * }
     */
    public static int getc_unlocked(MemorySegment x0) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putc_unlocked(int, FILE *)
     * }
     */
    public static int putc_unlocked(int x0, MemorySegment x1) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putchar_unlocked(int)
     * }
     */
    public static int putchar_unlocked(int x0) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getw(FILE *)
     * }
     */
    public static int getw(MemorySegment x0) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putw(int, FILE *)
     * }
     */
    public static int putw(int x0, MemorySegment x1) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *tempnam(const char *__dir, const char *__prefix)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __prefix) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __prefix);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_off_t off_t
     * }
     */
    public static final OfLong off_t = FFmpeg.C_LONG_LONG;

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fseeko(FILE *__stream, off_t __offset, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __offset, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __offset, __whence);
            }
            return (int)mh$.invokeExact(__stream, __offset, __whence);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_LONG,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int snprintf(char *restrict __str, size_t __size, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __str, long __size, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __str, __size, __format, x3);
                }
                return (int) spreader.invokeExact(__str, __size, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vfscanf(FILE *restrict __stream, const char *restrict __format, va_list)
     * }
     */
    public static int vfscanf(MemorySegment __stream, MemorySegment __format, MemorySegment x2) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __stream, __format, x2);
            }
            return (int)mh$.invokeExact(__stream, __format, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vscanf(const char *restrict __format, va_list)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment x1) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, x1);
            }
            return (int)mh$.invokeExact(__format, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsnprintf(char *restrict __str, size_t __size, const char *restrict __format, va_list)
     * }
     */
    public static int vsnprintf(MemorySegment __str, long __size, MemorySegment __format, MemorySegment x3) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __str, __size, __format, x3);
            }
            return (int)mh$.invokeExact(__str, __size, __format, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vsscanf(const char *restrict __str, const char *restrict __format, va_list)
     * }
     */
    public static int vsscanf(MemorySegment __str, MemorySegment __format, MemorySegment x2) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __str, __format, x2);
            }
            return (int)mh$.invokeExact(__str, __format, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = FFmpeg.C_LONG;

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int dprintf(int, const char *restrict, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int dprintf(int, const char *restrict, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vdprintf(int, const char *restrict, va_list)
     * }
     */
    public static int vdprintf(int x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getdelim(char **restrict __linep, size_t *restrict __linecapp, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __linep, MemorySegment __linecapp, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __linep, __linecapp, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __delimiter, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t getline(char **restrict __linep, size_t *restrict __linecapp, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __linep, MemorySegment __linecapp, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __linep, __linecapp, __stream);
            }
            return (long)mh$.invokeExact(__linep, __linecapp, __stream);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *fmemopen(void *restrict __buf, size_t __size, const char *restrict __mode)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __buf, long __size, MemorySegment __mode) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __buf, __size, __mode);
            }
            return (MemorySegment)mh$.invokeExact(__buf, __size, __mode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *open_memstream(char **__bufp, size_t *__sizep)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufp, MemorySegment __sizep) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufp, __sizep);
            }
            return (MemorySegment)mh$.invokeExact(__bufp, __sizep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sys_nerr$constants {
        public static final OfInt LAYOUT = FFmpeg.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("sys_nerr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static OfInt sys_nerr$layout() {
        return sys_nerr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static MemorySegment sys_nerr$segment() {
        return sys_nerr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static int sys_nerr() {
        return sys_nerr$constants.SEGMENT.get(sys_nerr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const int sys_nerr
     * }
     */
    public static void sys_nerr(int varValue) {
        sys_nerr$constants.SEGMENT.set(sys_nerr$constants.LAYOUT, 0L, varValue);
    }

    private static class sys_errlist$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(0, FFmpeg.C_POINTER);
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("sys_errlist").reinterpret(LAYOUT.byteSize());
    public static final VarHandle HANDLE = LAYOUT.varHandle();

        public static final long[] DIMS = {  };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static SequenceLayout sys_errlist$layout() {
        return sys_errlist$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static long[] sys_errlist$dimensions() {
        return sys_errlist$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static MemorySegment sys_errlist() {
        return sys_errlist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const char *const sys_errlist[]
     * }
     */
    public static void sys_errlist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, sys_errlist$constants.SEGMENT, 0L, sys_errlist$constants.LAYOUT.byteSize());
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int asprintf(char **restrict, const char *restrict, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int asprintf(char **restrict, const char *restrict, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, MemorySegment x1, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", x0, x1, x2);
                }
                return (int) spreader.invokeExact(x0, x1, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class ctermid_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ctermid_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static FunctionDescriptor ctermid_r$descriptor() {
        return ctermid_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MethodHandle ctermid_r$handle() {
        return ctermid_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r$address() {
        return ctermid_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ctermid_r(char *)
     * }
     */
    public static MemorySegment ctermid_r(MemorySegment x0) {
        var mh$ = ctermid_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid_r", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fgetln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static FunctionDescriptor fgetln$descriptor() {
        return fgetln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static MethodHandle fgetln$handle() {
        return fgetln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static MemorySegment fgetln$address() {
        return fgetln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fgetln(FILE *, size_t *__len)
     * }
     */
    public static MemorySegment fgetln(MemorySegment x0, MemorySegment __len) {
        var mh$ = fgetln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetln", x0, __len);
            }
            return (MemorySegment)mh$.invokeExact(x0, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmtcheck {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmtcheck");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static FunctionDescriptor fmtcheck$descriptor() {
        return fmtcheck.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MethodHandle fmtcheck$handle() {
        return fmtcheck.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck$address() {
        return fmtcheck.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *fmtcheck(const char *, const char *)
     * }
     */
    public static MemorySegment fmtcheck(MemorySegment x0, MemorySegment x1) {
        var mh$ = fmtcheck.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmtcheck", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fpurge {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fpurge");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static FunctionDescriptor fpurge$descriptor() {
        return fpurge.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MethodHandle fpurge$handle() {
        return fpurge.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static MemorySegment fpurge$address() {
        return fpurge.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fpurge(FILE *)
     * }
     */
    public static int fpurge(MemorySegment x0) {
        var mh$ = fpurge.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fpurge", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setbuffer(FILE *, char *, int __size)
     * }
     */
    public static void setbuffer(MemorySegment x0, MemorySegment x1, int __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", x0, x1, __size);
            }
            mh$.invokeExact(x0, x1, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setlinebuf(FILE *)
     * }
     */
    public static int setlinebuf(MemorySegment x0) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int vasprintf(char **restrict, const char *restrict, va_list)
     * }
     */
    public static int vasprintf(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("funopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static FunctionDescriptor funopen$descriptor() {
        return funopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MethodHandle funopen$handle() {
        return funopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen$address() {
        return funopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * FILE *funopen(const void *, int (* _Nullable)(void *, char *, int), int (* _Nullable)(void *, const char *, int), fpos_t (* _Nullable)(void *, fpos_t, int), int (* _Nullable)(void *))
     * }
     */
    public static MemorySegment funopen(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = funopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funopen", x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __snprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __snprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_LONG,
                FFmpeg.C_INT,
                FFmpeg.C_LONG,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__snprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __snprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __snprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, ...)
         * }
         */
        public static __snprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __snprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, long __maxlen, int x2, long x3, MemorySegment x4, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__snprintf_chk", x0, __maxlen, x2, x3, x4, x5);
                }
                return (int) spreader.invokeExact(x0, __maxlen, x2, x3, x4, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __vsnprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__vsnprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsnprintf_chk$descriptor() {
        return __vsnprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsnprintf_chk$handle() {
        return __vsnprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsnprintf_chk$address() {
        return __vsnprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsnprintf_chk(char *restrict, size_t __maxlen, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsnprintf_chk(MemorySegment x0, long __maxlen, int x2, long x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = __vsnprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsnprintf_chk", x0, __maxlen, x2, x3, x4, x5);
            }
            return (int)mh$.invokeExact(x0, __maxlen, x2, x3, x4, x5);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
     * }
     */
    public static class __sprintf_chk {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_INT,
                FFmpeg.C_LONG,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sprintf_chk");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __sprintf_chk(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __sprintf_chk(char *restrict, int, size_t, const char *restrict, ...)
         * }
         */
        public static __sprintf_chk makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __sprintf_chk(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment x0, int x1, long x2, MemorySegment x3, Object... x4) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__sprintf_chk", x0, x1, x2, x3, x4);
                }
                return (int) spreader.invokeExact(x0, x1, x2, x3, x4);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class __vsprintf_chk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__vsprintf_chk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static FunctionDescriptor __vsprintf_chk$descriptor() {
        return __vsprintf_chk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MethodHandle __vsprintf_chk$handle() {
        return __vsprintf_chk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static MemorySegment __vsprintf_chk$address() {
        return __vsprintf_chk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __vsprintf_chk(char *restrict, int, size_t, const char *restrict, va_list)
     * }
     */
    public static int __vsprintf_chk(MemorySegment x0, int x1, long x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = __vsprintf_chk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__vsprintf_chk", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint8_t
     * }
     */
    public static final OfByte uint8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short uint16_t
     * }
     */
    public static final OfShort uint16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint32_t
     * }
     */
    public static final OfInt uint32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long long uint64_t
     * }
     */
    public static final OfLong uint64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef int8_t int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef int16_t int_fast16_t
     * }
     */
    public static final OfShort int_fast16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int32_t int_fast32_t
     * }
     */
    public static final OfInt int_fast32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int64_t int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef uint8_t uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = FFmpeg.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef uint16_t uint_fast16_t
     * }
     */
    public static final OfShort uint_fast16_t = FFmpeg.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef uint32_t uint_fast32_t
     * }
     */
    public static final OfInt uint_fast32_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef uint64_t uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intmax_t
     * }
     */
    public static final OfLong intmax_t = FFmpeg.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintmax_t
     * }
     */
    public static final OfLong uintmax_t = FFmpeg.C_LONG;

    private static class avutil_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static FunctionDescriptor avutil_version$descriptor() {
        return avutil_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MethodHandle avutil_version$handle() {
        return avutil_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static MemorySegment avutil_version$address() {
        return avutil_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avutil_version()
     * }
     */
    public static int avutil_version() {
        var mh$ = avutil_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_version_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_version_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static FunctionDescriptor av_version_info$descriptor() {
        return av_version_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MethodHandle av_version_info$handle() {
        return av_version_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info$address() {
        return av_version_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_version_info()
     * }
     */
    public static MemorySegment av_version_info() {
        var mh$ = av_version_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_version_info");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static FunctionDescriptor avutil_configuration$descriptor() {
        return avutil_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MethodHandle avutil_configuration$handle() {
        return avutil_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration$address() {
        return avutil_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_configuration()
     * }
     */
    public static MemorySegment avutil_configuration() {
        var mh$ = avutil_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avutil_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avutil_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static FunctionDescriptor avutil_license$descriptor() {
        return avutil_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MethodHandle avutil_license$handle() {
        return avutil_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license$address() {
        return avutil_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avutil_license()
     * }
     */
    public static MemorySegment avutil_license() {
        var mh$ = avutil_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avutil_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVMEDIA_TYPE_UNKNOWN = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_UNKNOWN = -1
     * }
     */
    public static int AVMEDIA_TYPE_UNKNOWN() {
        return AVMEDIA_TYPE_UNKNOWN;
    }
    private static final int AVMEDIA_TYPE_VIDEO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_VIDEO = 0
     * }
     */
    public static int AVMEDIA_TYPE_VIDEO() {
        return AVMEDIA_TYPE_VIDEO;
    }
    private static final int AVMEDIA_TYPE_AUDIO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_AUDIO = 1
     * }
     */
    public static int AVMEDIA_TYPE_AUDIO() {
        return AVMEDIA_TYPE_AUDIO;
    }
    private static final int AVMEDIA_TYPE_DATA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_DATA = 2
     * }
     */
    public static int AVMEDIA_TYPE_DATA() {
        return AVMEDIA_TYPE_DATA;
    }
    private static final int AVMEDIA_TYPE_SUBTITLE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_SUBTITLE = 3
     * }
     */
    public static int AVMEDIA_TYPE_SUBTITLE() {
        return AVMEDIA_TYPE_SUBTITLE;
    }
    private static final int AVMEDIA_TYPE_ATTACHMENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_ATTACHMENT = 4
     * }
     */
    public static int AVMEDIA_TYPE_ATTACHMENT() {
        return AVMEDIA_TYPE_ATTACHMENT;
    }
    private static final int AVMEDIA_TYPE_NB = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVMediaType.AVMEDIA_TYPE_NB = 5
     * }
     */
    public static int AVMEDIA_TYPE_NB() {
        return AVMEDIA_TYPE_NB;
    }

    private static class av_get_media_type_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_media_type_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static FunctionDescriptor av_get_media_type_string$descriptor() {
        return av_get_media_type_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MethodHandle av_get_media_type_string$handle() {
        return av_get_media_type_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string$address() {
        return av_get_media_type_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_media_type_string(enum AVMediaType media_type)
     * }
     */
    public static MemorySegment av_get_media_type_string(int media_type) {
        var mh$ = av_get_media_type_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_media_type_string", media_type);
            }
            return (MemorySegment)mh$.invokeExact(media_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PICTURE_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_NONE = 0
     * }
     */
    public static int AV_PICTURE_TYPE_NONE() {
        return AV_PICTURE_TYPE_NONE;
    }
    private static final int AV_PICTURE_TYPE_I = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_I = 1
     * }
     */
    public static int AV_PICTURE_TYPE_I() {
        return AV_PICTURE_TYPE_I;
    }
    private static final int AV_PICTURE_TYPE_P = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_P = 2
     * }
     */
    public static int AV_PICTURE_TYPE_P() {
        return AV_PICTURE_TYPE_P;
    }
    private static final int AV_PICTURE_TYPE_B = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_B = 3
     * }
     */
    public static int AV_PICTURE_TYPE_B() {
        return AV_PICTURE_TYPE_B;
    }
    private static final int AV_PICTURE_TYPE_S = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_S = 4
     * }
     */
    public static int AV_PICTURE_TYPE_S() {
        return AV_PICTURE_TYPE_S;
    }
    private static final int AV_PICTURE_TYPE_SI = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SI = 5
     * }
     */
    public static int AV_PICTURE_TYPE_SI() {
        return AV_PICTURE_TYPE_SI;
    }
    private static final int AV_PICTURE_TYPE_SP = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_SP = 6
     * }
     */
    public static int AV_PICTURE_TYPE_SP() {
        return AV_PICTURE_TYPE_SP;
    }
    private static final int AV_PICTURE_TYPE_BI = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPictureType.AV_PICTURE_TYPE_BI = 7
     * }
     */
    public static int AV_PICTURE_TYPE_BI() {
        return AV_PICTURE_TYPE_BI;
    }

    private static class av_get_picture_type_char {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_CHAR,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_picture_type_char");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static FunctionDescriptor av_get_picture_type_char$descriptor() {
        return av_get_picture_type_char.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MethodHandle av_get_picture_type_char$handle() {
        return av_get_picture_type_char.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static MemorySegment av_get_picture_type_char$address() {
        return av_get_picture_type_char.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char av_get_picture_type_char(enum AVPictureType pict_type)
     * }
     */
    public static byte av_get_picture_type_char(int pict_type) {
        var mh$ = av_get_picture_type_char.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_picture_type_char", pict_type);
            }
            return (byte)mh$.invokeExact(pict_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int errno_t
     * }
     */
    public static final OfInt errno_t = FFmpeg.C_INT;

    private static class __error {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__error");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static FunctionDescriptor __error$descriptor() {
        return __error.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MethodHandle __error$handle() {
        return __error.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error$address() {
        return __error.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int *__error()
     * }
     */
    public static MemorySegment __error() {
        var mh$ = __error.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__error");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_wchar_t wchar_t
     * }
     */
    public static final OfInt wchar_t = FFmpeg.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t j)
     * }
     */
    public static long imaxabs(long j) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", j);
            }
            return (long)mh$.invokeExact(j);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const wchar_t *restrict __nptr, wchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float float_t
     * }
     */
    public static final OfFloat float_t = FFmpeg.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double double_t
     * }
     */
    public static final OfDouble double_t = FFmpeg.C_DOUBLE;

    private static class __math_errhandling {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__math_errhandling");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static FunctionDescriptor __math_errhandling$descriptor() {
        return __math_errhandling.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MethodHandle __math_errhandling$handle() {
        return __math_errhandling.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static MemorySegment __math_errhandling$address() {
        return __math_errhandling.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __math_errhandling()
     * }
     */
    public static int __math_errhandling() {
        var mh$ = __math_errhandling.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__math_errhandling");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__fpclassifyf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static FunctionDescriptor __fpclassifyf$descriptor() {
        return __fpclassifyf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MethodHandle __fpclassifyf$handle() {
        return __fpclassifyf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static MemorySegment __fpclassifyf$address() {
        return __fpclassifyf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyf(float)
     * }
     */
    public static int __fpclassifyf(float x0) {
        var mh$ = __fpclassifyf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __fpclassifyd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__fpclassifyd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static FunctionDescriptor __fpclassifyd$descriptor() {
        return __fpclassifyd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MethodHandle __fpclassifyd$handle() {
        return __fpclassifyd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static MemorySegment __fpclassifyd$address() {
        return __fpclassifyd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __fpclassifyd(double)
     * }
     */
    public static int __fpclassifyd(double x0) {
        var mh$ = __fpclassifyd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__fpclassifyd", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static FunctionDescriptor acosf$descriptor() {
        return acosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MethodHandle acosf$handle() {
        return acosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static MemorySegment acosf$address() {
        return acosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acosf(float)
     * }
     */
    public static float acosf(float x0) {
        var mh$ = acosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static FunctionDescriptor acos$descriptor() {
        return acos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MethodHandle acos$handle() {
        return acos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static MemorySegment acos$address() {
        return acos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acos(double)
     * }
     */
    public static double acos(double x0) {
        var mh$ = acos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static FunctionDescriptor asinf$descriptor() {
        return asinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MethodHandle asinf$handle() {
        return asinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static MemorySegment asinf$address() {
        return asinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinf(float)
     * }
     */
    public static float asinf(float x0) {
        var mh$ = asinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static FunctionDescriptor asin$descriptor() {
        return asin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MethodHandle asin$handle() {
        return asin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static MemorySegment asin$address() {
        return asin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asin(double)
     * }
     */
    public static double asin(double x0) {
        var mh$ = asin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static FunctionDescriptor atanf$descriptor() {
        return atanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MethodHandle atanf$handle() {
        return atanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static MemorySegment atanf$address() {
        return atanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanf(float)
     * }
     */
    public static float atanf(float x0) {
        var mh$ = atanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static FunctionDescriptor atan$descriptor() {
        return atan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MethodHandle atan$handle() {
        return atan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static MemorySegment atan$address() {
        return atan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan(double)
     * }
     */
    public static double atan(double x0) {
        var mh$ = atan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atan2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static FunctionDescriptor atan2f$descriptor() {
        return atan2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MethodHandle atan2f$handle() {
        return atan2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static MemorySegment atan2f$address() {
        return atan2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atan2f(float, float)
     * }
     */
    public static float atan2f(float x0, float x1) {
        var mh$ = atan2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2f", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atan2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atan2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static FunctionDescriptor atan2$descriptor() {
        return atan2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MethodHandle atan2$handle() {
        return atan2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static MemorySegment atan2$address() {
        return atan2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atan2(double, double)
     * }
     */
    public static double atan2(double x0, double x1) {
        var mh$ = atan2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atan2", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cosf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static FunctionDescriptor cosf$descriptor() {
        return cosf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MethodHandle cosf$handle() {
        return cosf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static MemorySegment cosf$address() {
        return cosf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cosf(float)
     * }
     */
    public static float cosf(float x0) {
        var mh$ = cosf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static FunctionDescriptor cos$descriptor() {
        return cos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MethodHandle cos$handle() {
        return cos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static MemorySegment cos$address() {
        return cos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cos(double)
     * }
     */
    public static double cos(double x0) {
        var mh$ = cos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cos", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sinf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static FunctionDescriptor sinf$descriptor() {
        return sinf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MethodHandle sinf$handle() {
        return sinf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static MemorySegment sinf$address() {
        return sinf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinf(float)
     * }
     */
    public static float sinf(float x0) {
        var mh$ = sinf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static FunctionDescriptor sin$descriptor() {
        return sin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MethodHandle sin$handle() {
        return sin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static MemorySegment sin$address() {
        return sin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sin(double)
     * }
     */
    public static double sin(double x0) {
        var mh$ = sin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sin", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static FunctionDescriptor tanf$descriptor() {
        return tanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MethodHandle tanf$handle() {
        return tanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static MemorySegment tanf$address() {
        return tanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanf(float)
     * }
     */
    public static float tanf(float x0) {
        var mh$ = tanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static FunctionDescriptor tan$descriptor() {
        return tan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MethodHandle tan$handle() {
        return tan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static MemorySegment tan$address() {
        return tan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tan(double)
     * }
     */
    public static double tan(double x0) {
        var mh$ = tan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acoshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acoshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static FunctionDescriptor acoshf$descriptor() {
        return acoshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MethodHandle acoshf$handle() {
        return acoshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static MemorySegment acoshf$address() {
        return acoshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float acoshf(float)
     * }
     */
    public static float acoshf(float x0) {
        var mh$ = acoshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acoshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class acosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("acosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static FunctionDescriptor acosh$descriptor() {
        return acosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MethodHandle acosh$handle() {
        return acosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static MemorySegment acosh$address() {
        return acosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double acosh(double)
     * }
     */
    public static double acosh(double x0) {
        var mh$ = acosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("acosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static FunctionDescriptor asinhf$descriptor() {
        return asinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MethodHandle asinhf$handle() {
        return asinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static MemorySegment asinhf$address() {
        return asinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float asinhf(float)
     * }
     */
    public static float asinhf(float x0) {
        var mh$ = asinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("asinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static FunctionDescriptor asinh$descriptor() {
        return asinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MethodHandle asinh$handle() {
        return asinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static MemorySegment asinh$address() {
        return asinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double asinh(double)
     * }
     */
    public static double asinh(double x0) {
        var mh$ = asinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static FunctionDescriptor atanhf$descriptor() {
        return atanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MethodHandle atanhf$handle() {
        return atanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static MemorySegment atanhf$address() {
        return atanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float atanhf(float)
     * }
     */
    public static float atanhf(float x0) {
        var mh$ = atanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static FunctionDescriptor atanh$descriptor() {
        return atanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MethodHandle atanh$handle() {
        return atanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static MemorySegment atanh$address() {
        return atanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atanh(double)
     * }
     */
    public static double atanh(double x0) {
        var mh$ = atanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class coshf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("coshf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static FunctionDescriptor coshf$descriptor() {
        return coshf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MethodHandle coshf$handle() {
        return coshf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static MemorySegment coshf$address() {
        return coshf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float coshf(float)
     * }
     */
    public static float coshf(float x0) {
        var mh$ = coshf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("coshf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cosh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cosh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static FunctionDescriptor cosh$descriptor() {
        return cosh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MethodHandle cosh$handle() {
        return cosh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static MemorySegment cosh$address() {
        return cosh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cosh(double)
     * }
     */
    public static double cosh(double x0) {
        var mh$ = cosh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cosh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sinhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static FunctionDescriptor sinhf$descriptor() {
        return sinhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MethodHandle sinhf$handle() {
        return sinhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static MemorySegment sinhf$address() {
        return sinhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sinhf(float)
     * }
     */
    public static float sinhf(float x0) {
        var mh$ = sinhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sinh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sinh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static FunctionDescriptor sinh$descriptor() {
        return sinh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MethodHandle sinh$handle() {
        return sinh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static MemorySegment sinh$address() {
        return sinh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sinh(double)
     * }
     */
    public static double sinh(double x0) {
        var mh$ = sinh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sinh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanhf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tanhf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static FunctionDescriptor tanhf$descriptor() {
        return tanhf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MethodHandle tanhf$handle() {
        return tanhf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static MemorySegment tanhf$address() {
        return tanhf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tanhf(float)
     * }
     */
    public static float tanhf(float x0) {
        var mh$ = tanhf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanhf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tanh {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tanh");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static FunctionDescriptor tanh$descriptor() {
        return tanh.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MethodHandle tanh$handle() {
        return tanh.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static MemorySegment tanh$address() {
        return tanh.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tanh(double)
     * }
     */
    public static double tanh(double x0) {
        var mh$ = tanh.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tanh", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static FunctionDescriptor expf$descriptor() {
        return expf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MethodHandle expf$handle() {
        return expf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static MemorySegment expf$address() {
        return expf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expf(float)
     * }
     */
    public static float expf(float x0) {
        var mh$ = expf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static FunctionDescriptor exp$descriptor() {
        return exp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MethodHandle exp$handle() {
        return exp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static MemorySegment exp$address() {
        return exp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp(double)
     * }
     */
    public static double exp(double x0) {
        var mh$ = exp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exp2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static FunctionDescriptor exp2f$descriptor() {
        return exp2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MethodHandle exp2f$handle() {
        return exp2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static MemorySegment exp2f$address() {
        return exp2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float exp2f(float)
     * }
     */
    public static float exp2f(float x0) {
        var mh$ = exp2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exp2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exp2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static FunctionDescriptor exp2$descriptor() {
        return exp2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MethodHandle exp2$handle() {
        return exp2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static MemorySegment exp2$address() {
        return exp2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double exp2(double)
     * }
     */
    public static double exp2(double x0) {
        var mh$ = exp2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exp2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expm1f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static FunctionDescriptor expm1f$descriptor() {
        return expm1f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MethodHandle expm1f$handle() {
        return expm1f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static MemorySegment expm1f$address() {
        return expm1f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float expm1f(float)
     * }
     */
    public static float expm1f(float x0) {
        var mh$ = expm1f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class expm1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("expm1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static FunctionDescriptor expm1$descriptor() {
        return expm1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MethodHandle expm1$handle() {
        return expm1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static MemorySegment expm1$address() {
        return expm1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double expm1(double)
     * }
     */
    public static double expm1(double x0) {
        var mh$ = expm1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("expm1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("logf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static FunctionDescriptor logf$descriptor() {
        return logf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MethodHandle logf$handle() {
        return logf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static MemorySegment logf$address() {
        return logf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logf(float)
     * }
     */
    public static float logf(float x0) {
        var mh$ = logf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static FunctionDescriptor log$descriptor() {
        return log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MethodHandle log$handle() {
        return log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static MemorySegment log$address() {
        return log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log(double)
     * }
     */
    public static double log(double x0) {
        var mh$ = log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static FunctionDescriptor log10f$descriptor() {
        return log10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MethodHandle log10f$handle() {
        return log10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static MemorySegment log10f$address() {
        return log10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log10f(float)
     * }
     */
    public static float log10f(float x0) {
        var mh$ = log10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static FunctionDescriptor log10$descriptor() {
        return log10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MethodHandle log10$handle() {
        return log10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static MemorySegment log10$address() {
        return log10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log10(double)
     * }
     */
    public static double log10(double x0) {
        var mh$ = log10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log2f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static FunctionDescriptor log2f$descriptor() {
        return log2f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MethodHandle log2f$handle() {
        return log2f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static MemorySegment log2f$address() {
        return log2f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log2f(float)
     * }
     */
    public static float log2f(float x0) {
        var mh$ = log2f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static FunctionDescriptor log2$descriptor() {
        return log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MethodHandle log2$handle() {
        return log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static MemorySegment log2$address() {
        return log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log2(double)
     * }
     */
    public static double log2(double x0) {
        var mh$ = log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log2", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1pf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log1pf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static FunctionDescriptor log1pf$descriptor() {
        return log1pf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MethodHandle log1pf$handle() {
        return log1pf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static MemorySegment log1pf$address() {
        return log1pf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float log1pf(float)
     * }
     */
    public static float log1pf(float x0) {
        var mh$ = log1pf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1pf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class log1p {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("log1p");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static FunctionDescriptor log1p$descriptor() {
        return log1p.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MethodHandle log1p$handle() {
        return log1p.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static MemorySegment log1p$address() {
        return log1p.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double log1p(double)
     * }
     */
    public static double log1p(double x0) {
        var mh$ = log1p.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("log1p", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("logbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static FunctionDescriptor logbf$descriptor() {
        return logbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MethodHandle logbf$handle() {
        return logbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static MemorySegment logbf$address() {
        return logbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float logbf(float)
     * }
     */
    public static float logbf(float x0) {
        var mh$ = logbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logbf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class logb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("logb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static FunctionDescriptor logb$descriptor() {
        return logb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MethodHandle logb$handle() {
        return logb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static MemorySegment logb$address() {
        return logb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double logb(double)
     * }
     */
    public static double logb(double x0) {
        var mh$ = logb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("logb", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("modff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static FunctionDescriptor modff$descriptor() {
        return modff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MethodHandle modff$handle() {
        return modff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static MemorySegment modff$address() {
        return modff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float modff(float, float *)
     * }
     */
    public static float modff(float x0, MemorySegment x1) {
        var mh$ = modff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modff", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class modf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("modf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static FunctionDescriptor modf$descriptor() {
        return modf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MethodHandle modf$handle() {
        return modf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static MemorySegment modf$address() {
        return modf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double modf(double, double *)
     * }
     */
    public static double modf(double x0, MemorySegment x1) {
        var mh$ = modf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("modf", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static FunctionDescriptor ldexpf$descriptor() {
        return ldexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MethodHandle ldexpf$handle() {
        return ldexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static MemorySegment ldexpf$address() {
        return ldexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ldexpf(float, int)
     * }
     */
    public static float ldexpf(float x0, int x1) {
        var mh$ = ldexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static FunctionDescriptor ldexp$descriptor() {
        return ldexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MethodHandle ldexp$handle() {
        return ldexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static MemorySegment ldexp$address() {
        return ldexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ldexp(double, int)
     * }
     */
    public static double ldexp(double x0, int x1) {
        var mh$ = ldexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexpf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("frexpf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static FunctionDescriptor frexpf$descriptor() {
        return frexpf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MethodHandle frexpf$handle() {
        return frexpf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static MemorySegment frexpf$address() {
        return frexpf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float frexpf(float, int *)
     * }
     */
    public static float frexpf(float x0, MemorySegment x1) {
        var mh$ = frexpf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexpf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class frexp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("frexp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static FunctionDescriptor frexp$descriptor() {
        return frexp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MethodHandle frexp$handle() {
        return frexp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static MemorySegment frexp$address() {
        return frexp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double frexp(double, int *)
     * }
     */
    public static double frexp(double x0, MemorySegment x1) {
        var mh$ = frexp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("frexp", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogbf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ilogbf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static FunctionDescriptor ilogbf$descriptor() {
        return ilogbf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MethodHandle ilogbf$handle() {
        return ilogbf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static MemorySegment ilogbf$address() {
        return ilogbf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogbf(float)
     * }
     */
    public static int ilogbf(float x0) {
        var mh$ = ilogbf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogbf", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ilogb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ilogb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static FunctionDescriptor ilogb$descriptor() {
        return ilogb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MethodHandle ilogb$handle() {
        return ilogb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static MemorySegment ilogb$address() {
        return ilogb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ilogb(double)
     * }
     */
    public static int ilogb(double x0) {
        var mh$ = ilogb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ilogb", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalbnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static FunctionDescriptor scalbnf$descriptor() {
        return scalbnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MethodHandle scalbnf$handle() {
        return scalbnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static MemorySegment scalbnf$address() {
        return scalbnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalbnf(float, int)
     * }
     */
    public static float scalbnf(float x0, int x1) {
        var mh$ = scalbnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalbn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static FunctionDescriptor scalbn$descriptor() {
        return scalbn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MethodHandle scalbn$handle() {
        return scalbn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static MemorySegment scalbn$address() {
        return scalbn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbn(double, int)
     * }
     */
    public static double scalbn(double x0, int x1) {
        var mh$ = scalbn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalblnf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalblnf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static FunctionDescriptor scalblnf$descriptor() {
        return scalblnf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MethodHandle scalblnf$handle() {
        return scalblnf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static MemorySegment scalblnf$address() {
        return scalblnf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float scalblnf(float, long)
     * }
     */
    public static float scalblnf(float x0, long x1) {
        var mh$ = scalblnf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalblnf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalbln {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalbln");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static FunctionDescriptor scalbln$descriptor() {
        return scalbln.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MethodHandle scalbln$handle() {
        return scalbln.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static MemorySegment scalbln$address() {
        return scalbln.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalbln(double, long)
     * }
     */
    public static double scalbln(double x0, long x1) {
        var mh$ = scalbln.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalbln", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabsf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fabsf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static FunctionDescriptor fabsf$descriptor() {
        return fabsf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MethodHandle fabsf$handle() {
        return fabsf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static MemorySegment fabsf$address() {
        return fabsf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fabsf(float)
     * }
     */
    public static float fabsf(float x0) {
        var mh$ = fabsf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabsf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static FunctionDescriptor fabs$descriptor() {
        return fabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MethodHandle fabs$handle() {
        return fabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static MemorySegment fabs$address() {
        return fabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fabs(double)
     * }
     */
    public static double fabs(double x0) {
        var mh$ = fabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fabs", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cbrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static FunctionDescriptor cbrtf$descriptor() {
        return cbrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MethodHandle cbrtf$handle() {
        return cbrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static MemorySegment cbrtf$address() {
        return cbrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float cbrtf(float)
     * }
     */
    public static float cbrtf(float x0) {
        var mh$ = cbrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cbrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cbrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static FunctionDescriptor cbrt$descriptor() {
        return cbrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MethodHandle cbrt$handle() {
        return cbrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static MemorySegment cbrt$address() {
        return cbrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double cbrt(double)
     * }
     */
    public static double cbrt(double x0) {
        var mh$ = cbrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cbrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypotf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("hypotf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static FunctionDescriptor hypotf$descriptor() {
        return hypotf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MethodHandle hypotf$handle() {
        return hypotf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static MemorySegment hypotf$address() {
        return hypotf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float hypotf(float, float)
     * }
     */
    public static float hypotf(float x0, float x1) {
        var mh$ = hypotf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypotf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class hypot {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("hypot");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static FunctionDescriptor hypot$descriptor() {
        return hypot.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MethodHandle hypot$handle() {
        return hypot.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static MemorySegment hypot$address() {
        return hypot.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double hypot(double, double)
     * }
     */
    public static double hypot(double x0, double x1) {
        var mh$ = hypot.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("hypot", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class powf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("powf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static FunctionDescriptor powf$descriptor() {
        return powf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MethodHandle powf$handle() {
        return powf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static MemorySegment powf$address() {
        return powf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float powf(float, float)
     * }
     */
    public static float powf(float x0, float x1) {
        var mh$ = powf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("powf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("pow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static FunctionDescriptor pow$descriptor() {
        return pow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MethodHandle pow$handle() {
        return pow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static MemorySegment pow$address() {
        return pow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double pow(double, double)
     * }
     */
    public static double pow(double x0, double x1) {
        var mh$ = pow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pow", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrtf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sqrtf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static FunctionDescriptor sqrtf$descriptor() {
        return sqrtf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MethodHandle sqrtf$handle() {
        return sqrtf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static MemorySegment sqrtf$address() {
        return sqrtf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float sqrtf(float)
     * }
     */
    public static float sqrtf(float x0) {
        var mh$ = sqrtf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrtf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sqrt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sqrt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static FunctionDescriptor sqrt$descriptor() {
        return sqrt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MethodHandle sqrt$handle() {
        return sqrt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static MemorySegment sqrt$address() {
        return sqrt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double sqrt(double)
     * }
     */
    public static double sqrt(double x0) {
        var mh$ = sqrt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sqrt", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erff {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erff");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static FunctionDescriptor erff$descriptor() {
        return erff.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MethodHandle erff$handle() {
        return erff.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static MemorySegment erff$address() {
        return erff.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erff(float)
     * }
     */
    public static float erff(float x0) {
        var mh$ = erff.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erff", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static FunctionDescriptor erf$descriptor() {
        return erf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MethodHandle erf$handle() {
        return erf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static MemorySegment erf$address() {
        return erf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erf(double)
     * }
     */
    public static double erf(double x0) {
        var mh$ = erf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erf", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfcf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erfcf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static FunctionDescriptor erfcf$descriptor() {
        return erfcf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MethodHandle erfcf$handle() {
        return erfcf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static MemorySegment erfcf$address() {
        return erfcf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float erfcf(float)
     * }
     */
    public static float erfcf(float x0) {
        var mh$ = erfcf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfcf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erfc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erfc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static FunctionDescriptor erfc$descriptor() {
        return erfc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MethodHandle erfc$handle() {
        return erfc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static MemorySegment erfc$address() {
        return erfc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erfc(double)
     * }
     */
    public static double erfc(double x0) {
        var mh$ = erfc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erfc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static FunctionDescriptor lgammaf$descriptor() {
        return lgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MethodHandle lgammaf$handle() {
        return lgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static MemorySegment lgammaf$address() {
        return lgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float lgammaf(float)
     * }
     */
    public static float lgammaf(float x0) {
        var mh$ = lgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static FunctionDescriptor lgamma$descriptor() {
        return lgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MethodHandle lgamma$handle() {
        return lgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static MemorySegment lgamma$address() {
        return lgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double lgamma(double)
     * }
     */
    public static double lgamma(double x0) {
        var mh$ = lgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgammaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tgammaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static FunctionDescriptor tgammaf$descriptor() {
        return tgammaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MethodHandle tgammaf$handle() {
        return tgammaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static MemorySegment tgammaf$address() {
        return tgammaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float tgammaf(float)
     * }
     */
    public static float tgammaf(float x0) {
        var mh$ = tgammaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgammaf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tgamma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("tgamma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static FunctionDescriptor tgamma$descriptor() {
        return tgamma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MethodHandle tgamma$handle() {
        return tgamma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static MemorySegment tgamma$address() {
        return tgamma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double tgamma(double)
     * }
     */
    public static double tgamma(double x0) {
        var mh$ = tgamma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tgamma", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceilf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ceilf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static FunctionDescriptor ceilf$descriptor() {
        return ceilf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MethodHandle ceilf$handle() {
        return ceilf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static MemorySegment ceilf$address() {
        return ceilf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float ceilf(float)
     * }
     */
    public static float ceilf(float x0) {
        var mh$ = ceilf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceilf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ceil {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ceil");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static FunctionDescriptor ceil$descriptor() {
        return ceil.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MethodHandle ceil$handle() {
        return ceil.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static MemorySegment ceil$address() {
        return ceil.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double ceil(double)
     * }
     */
    public static double ceil(double x0) {
        var mh$ = ceil.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ceil", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floorf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("floorf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static FunctionDescriptor floorf$descriptor() {
        return floorf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MethodHandle floorf$handle() {
        return floorf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static MemorySegment floorf$address() {
        return floorf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float floorf(float)
     * }
     */
    public static float floorf(float x0) {
        var mh$ = floorf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floorf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class floor {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("floor");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static FunctionDescriptor floor$descriptor() {
        return floor.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MethodHandle floor$handle() {
        return floor.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static MemorySegment floor$address() {
        return floor.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double floor(double)
     * }
     */
    public static double floor(double x0) {
        var mh$ = floor.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("floor", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nearbyintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static FunctionDescriptor nearbyintf$descriptor() {
        return nearbyintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MethodHandle nearbyintf$handle() {
        return nearbyintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static MemorySegment nearbyintf$address() {
        return nearbyintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nearbyintf(float)
     * }
     */
    public static float nearbyintf(float x0) {
        var mh$ = nearbyintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nearbyint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nearbyint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static FunctionDescriptor nearbyint$descriptor() {
        return nearbyint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MethodHandle nearbyint$handle() {
        return nearbyint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static MemorySegment nearbyint$address() {
        return nearbyint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nearbyint(double)
     * }
     */
    public static double nearbyint(double x0) {
        var mh$ = nearbyint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nearbyint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static FunctionDescriptor rintf$descriptor() {
        return rintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MethodHandle rintf$handle() {
        return rintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static MemorySegment rintf$address() {
        return rintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float rintf(float)
     * }
     */
    public static float rintf(float x0) {
        var mh$ = rintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rintf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static FunctionDescriptor rint$descriptor() {
        return rint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MethodHandle rint$handle() {
        return rint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static MemorySegment rint$address() {
        return rint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double rint(double)
     * }
     */
    public static double rint(double x0) {
        var mh$ = rint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rint", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static FunctionDescriptor lrintf$descriptor() {
        return lrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MethodHandle lrintf$handle() {
        return lrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static MemorySegment lrintf$address() {
        return lrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrintf(float)
     * }
     */
    public static long lrintf(float x0) {
        var mh$ = lrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static FunctionDescriptor lrint$descriptor() {
        return lrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MethodHandle lrint$handle() {
        return lrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static MemorySegment lrint$address() {
        return lrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrint(double)
     * }
     */
    public static long lrint(double x0) {
        var mh$ = lrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class roundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("roundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static FunctionDescriptor roundf$descriptor() {
        return roundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MethodHandle roundf$handle() {
        return roundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static MemorySegment roundf$address() {
        return roundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float roundf(float)
     * }
     */
    public static float roundf(float x0) {
        var mh$ = roundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("roundf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class round {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("round");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static FunctionDescriptor round$descriptor() {
        return round.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MethodHandle round$handle() {
        return round.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static MemorySegment round$address() {
        return round.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double round(double)
     * }
     */
    public static double round(double x0) {
        var mh$ = round.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("round", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static FunctionDescriptor lroundf$descriptor() {
        return lroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MethodHandle lroundf$handle() {
        return lroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static MemorySegment lroundf$address() {
        return lroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lroundf(float)
     * }
     */
    public static long lroundf(float x0) {
        var mh$ = lroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static FunctionDescriptor lround$descriptor() {
        return lround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MethodHandle lround$handle() {
        return lround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static MemorySegment lround$address() {
        return lround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lround(double)
     * }
     */
    public static long lround(double x0) {
        var mh$ = lround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llrintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static FunctionDescriptor llrintf$descriptor() {
        return llrintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MethodHandle llrintf$handle() {
        return llrintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static MemorySegment llrintf$address() {
        return llrintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrintf(float)
     * }
     */
    public static long llrintf(float x0) {
        var mh$ = llrintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrintf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llrint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llrint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static FunctionDescriptor llrint$descriptor() {
        return llrint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MethodHandle llrint$handle() {
        return llrint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static MemorySegment llrint$address() {
        return llrint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llrint(double)
     * }
     */
    public static long llrint(double x0) {
        var mh$ = llrint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llrint", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llroundf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llroundf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static FunctionDescriptor llroundf$descriptor() {
        return llroundf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MethodHandle llroundf$handle() {
        return llroundf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static MemorySegment llroundf$address() {
        return llroundf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llroundf(float)
     * }
     */
    public static long llroundf(float x0) {
        var mh$ = llroundf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llroundf", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llround {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llround");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static FunctionDescriptor llround$descriptor() {
        return llround.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MethodHandle llround$handle() {
        return llround.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static MemorySegment llround$address() {
        return llround.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llround(double)
     * }
     */
    public static long llround(double x0) {
        var mh$ = llround.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llround", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class truncf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("truncf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static FunctionDescriptor truncf$descriptor() {
        return truncf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MethodHandle truncf$handle() {
        return truncf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static MemorySegment truncf$address() {
        return truncf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float truncf(float)
     * }
     */
    public static float truncf(float x0) {
        var mh$ = truncf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("truncf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class trunc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("trunc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static FunctionDescriptor trunc$descriptor() {
        return trunc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MethodHandle trunc$handle() {
        return trunc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static MemorySegment trunc$address() {
        return trunc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double trunc(double)
     * }
     */
    public static double trunc(double x0) {
        var mh$ = trunc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("trunc", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmodf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmodf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static FunctionDescriptor fmodf$descriptor() {
        return fmodf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MethodHandle fmodf$handle() {
        return fmodf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static MemorySegment fmodf$address() {
        return fmodf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmodf(float, float)
     * }
     */
    public static float fmodf(float x0, float x1) {
        var mh$ = fmodf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmodf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static FunctionDescriptor fmod$descriptor() {
        return fmod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MethodHandle fmod$handle() {
        return fmod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static MemorySegment fmod$address() {
        return fmod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmod(double, double)
     * }
     */
    public static double fmod(double x0, double x1) {
        var mh$ = fmod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainderf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remainderf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static FunctionDescriptor remainderf$descriptor() {
        return remainderf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MethodHandle remainderf$handle() {
        return remainderf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static MemorySegment remainderf$address() {
        return remainderf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remainderf(float, float)
     * }
     */
    public static float remainderf(float x0, float x1) {
        var mh$ = remainderf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainderf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remainder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remainder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static FunctionDescriptor remainder$descriptor() {
        return remainder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MethodHandle remainder$handle() {
        return remainder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static MemorySegment remainder$address() {
        return remainder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remainder(double, double)
     * }
     */
    public static double remainder(double x0, double x1) {
        var mh$ = remainder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remainder", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remquof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static FunctionDescriptor remquof$descriptor() {
        return remquof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MethodHandle remquof$handle() {
        return remquof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static MemorySegment remquof$address() {
        return remquof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float remquof(float, float, int *)
     * }
     */
    public static float remquof(float x0, float x1, MemorySegment x2) {
        var mh$ = remquof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquof", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class remquo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("remquo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static FunctionDescriptor remquo$descriptor() {
        return remquo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MethodHandle remquo$handle() {
        return remquo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static MemorySegment remquo$address() {
        return remquo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double remquo(double, double, int *)
     * }
     */
    public static double remquo(double x0, double x1, MemorySegment x2) {
        var mh$ = remquo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remquo", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysignf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("copysignf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static FunctionDescriptor copysignf$descriptor() {
        return copysignf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MethodHandle copysignf$handle() {
        return copysignf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static MemorySegment copysignf$address() {
        return copysignf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float copysignf(float, float)
     * }
     */
    public static float copysignf(float x0, float x1) {
        var mh$ = copysignf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysignf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class copysign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("copysign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static FunctionDescriptor copysign$descriptor() {
        return copysign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MethodHandle copysign$handle() {
        return copysign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static MemorySegment copysign$address() {
        return copysign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double copysign(double, double)
     * }
     */
    public static double copysign(double x0, double x1) {
        var mh$ = copysign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("copysign", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static FunctionDescriptor nanf$descriptor() {
        return nanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MethodHandle nanf$handle() {
        return nanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static MemorySegment nanf$address() {
        return nanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nanf(const char *)
     * }
     */
    public static float nanf(MemorySegment x0) {
        var mh$ = nanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nanf", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nan {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nan");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static FunctionDescriptor nan$descriptor() {
        return nan.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MethodHandle nan$handle() {
        return nan.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static MemorySegment nan$address() {
        return nan.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nan(const char *)
     * }
     */
    public static double nan(MemorySegment x0) {
        var mh$ = nan.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nan", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafterf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextafterf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static FunctionDescriptor nextafterf$descriptor() {
        return nextafterf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MethodHandle nextafterf$handle() {
        return nextafterf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static MemorySegment nextafterf$address() {
        return nextafterf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float nextafterf(float, float)
     * }
     */
    public static float nextafterf(float x0, float x1) {
        var mh$ = nextafterf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafterf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nextafter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nextafter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static FunctionDescriptor nextafter$descriptor() {
        return nextafter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MethodHandle nextafter$handle() {
        return nextafter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static MemorySegment nextafter$address() {
        return nextafter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double nextafter(double, double)
     * }
     */
    public static double nextafter(double x0, double x1) {
        var mh$ = nextafter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nextafter", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdimf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdimf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static FunctionDescriptor fdimf$descriptor() {
        return fdimf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MethodHandle fdimf$handle() {
        return fdimf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static MemorySegment fdimf$address() {
        return fdimf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fdimf(float, float)
     * }
     */
    public static float fdimf(float x0, float x1) {
        var mh$ = fdimf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdimf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fdim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static FunctionDescriptor fdim$descriptor() {
        return fdim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MethodHandle fdim$handle() {
        return fdim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static MemorySegment fdim$address() {
        return fdim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fdim(double, double)
     * }
     */
    public static double fdim(double x0, double x1) {
        var mh$ = fdim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdim", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaxf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmaxf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static FunctionDescriptor fmaxf$descriptor() {
        return fmaxf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MethodHandle fmaxf$handle() {
        return fmaxf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static MemorySegment fmaxf$address() {
        return fmaxf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaxf(float, float)
     * }
     */
    public static float fmaxf(float x0, float x1) {
        var mh$ = fmaxf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaxf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static FunctionDescriptor fmax$descriptor() {
        return fmax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MethodHandle fmax$handle() {
        return fmax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static MemorySegment fmax$address() {
        return fmax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmax(double, double)
     * }
     */
    public static double fmax(double x0, double x1) {
        var mh$ = fmax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmax", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fminf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fminf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static FunctionDescriptor fminf$descriptor() {
        return fminf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MethodHandle fminf$handle() {
        return fminf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static MemorySegment fminf$address() {
        return fminf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fminf(float, float)
     * }
     */
    public static float fminf(float x0, float x1) {
        var mh$ = fminf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fminf", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmin {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmin");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static FunctionDescriptor fmin$descriptor() {
        return fmin.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MethodHandle fmin$handle() {
        return fmin.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static MemorySegment fmin$address() {
        return fmin.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fmin(double, double)
     * }
     */
    public static double fmin(double x0, double x1) {
        var mh$ = fmin.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmin", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmaf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fmaf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static FunctionDescriptor fmaf$descriptor() {
        return fmaf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MethodHandle fmaf$handle() {
        return fmaf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static MemorySegment fmaf$address() {
        return fmaf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float fmaf(float, float, float)
     * }
     */
    public static float fmaf(float x0, float x1, float x2) {
        var mh$ = fmaf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmaf", x0, x1, x2);
            }
            return (float)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fma {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fma");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static FunctionDescriptor fma$descriptor() {
        return fma.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MethodHandle fma$handle() {
        return fma.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static MemorySegment fma$address() {
        return fma.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double fma(double, double, double)
     * }
     */
    public static double fma(double x0, double x1, double x2) {
        var mh$ = fma.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fma", x0, x1, x2);
            }
            return (double)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__exp10f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static FunctionDescriptor __exp10f$descriptor() {
        return __exp10f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MethodHandle __exp10f$handle() {
        return __exp10f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static MemorySegment __exp10f$address() {
        return __exp10f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __exp10f(float)
     * }
     */
    public static float __exp10f(float x0) {
        var mh$ = __exp10f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10f", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __exp10 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__exp10");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static FunctionDescriptor __exp10$descriptor() {
        return __exp10.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MethodHandle __exp10$handle() {
        return __exp10.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static MemorySegment __exp10$address() {
        return __exp10.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __exp10(double)
     * }
     */
    public static double __exp10(double x0) {
        var mh$ = __exp10.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__exp10", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__cospif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static FunctionDescriptor __cospif$descriptor() {
        return __cospif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MethodHandle __cospif$handle() {
        return __cospif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static MemorySegment __cospif$address() {
        return __cospif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __cospif(float)
     * }
     */
    public static float __cospif(float x0) {
        var mh$ = __cospif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __cospi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__cospi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static FunctionDescriptor __cospi$descriptor() {
        return __cospi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MethodHandle __cospi$handle() {
        return __cospi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static MemorySegment __cospi$address() {
        return __cospi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __cospi(double)
     * }
     */
    public static double __cospi(double x0) {
        var mh$ = __cospi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__cospi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sinpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static FunctionDescriptor __sinpif$descriptor() {
        return __sinpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MethodHandle __sinpif$handle() {
        return __sinpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static MemorySegment __sinpif$address() {
        return __sinpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __sinpif(float)
     * }
     */
    public static float __sinpif(float x0) {
        var mh$ = __sinpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __sinpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__sinpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static FunctionDescriptor __sinpi$descriptor() {
        return __sinpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MethodHandle __sinpi$handle() {
        return __sinpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static MemorySegment __sinpi$address() {
        return __sinpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __sinpi(double)
     * }
     */
    public static double __sinpi(double x0) {
        var mh$ = __sinpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__sinpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpif {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__tanpif");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static FunctionDescriptor __tanpif$descriptor() {
        return __tanpif.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MethodHandle __tanpif$handle() {
        return __tanpif.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static MemorySegment __tanpif$address() {
        return __tanpif.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float __tanpif(float)
     * }
     */
    public static float __tanpif(float x0) {
        var mh$ = __tanpif.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpif", x0);
            }
            return (float)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __tanpi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("__tanpi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static FunctionDescriptor __tanpi$descriptor() {
        return __tanpi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MethodHandle __tanpi$handle() {
        return __tanpi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static MemorySegment __tanpi$address() {
        return __tanpi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double __tanpi(double)
     * }
     */
    public static double __tanpi(double x0) {
        var mh$ = __tanpi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__tanpi", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("j0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static FunctionDescriptor j0$descriptor() {
        return j0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MethodHandle j0$handle() {
        return j0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static MemorySegment j0$address() {
        return j0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j0(double)
     * }
     */
    public static double j0(double x0) {
        var mh$ = j0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class j1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("j1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static FunctionDescriptor j1$descriptor() {
        return j1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MethodHandle j1$handle() {
        return j1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static MemorySegment j1$address() {
        return j1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double j1(double)
     * }
     */
    public static double j1(double x0) {
        var mh$ = j1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("j1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static FunctionDescriptor jn$descriptor() {
        return jn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MethodHandle jn$handle() {
        return jn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static MemorySegment jn$address() {
        return jn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double jn(int, double)
     * }
     */
    public static double jn(int x0, double x1) {
        var mh$ = jn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("y0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static FunctionDescriptor y0$descriptor() {
        return y0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MethodHandle y0$handle() {
        return y0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static MemorySegment y0$address() {
        return y0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y0(double)
     * }
     */
    public static double y0(double x0) {
        var mh$ = y0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y0", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class y1 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("y1");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static FunctionDescriptor y1$descriptor() {
        return y1.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MethodHandle y1$handle() {
        return y1.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static MemorySegment y1$address() {
        return y1.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double y1(double)
     * }
     */
    public static double y1(double x0) {
        var mh$ = y1.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("y1", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class yn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("yn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static FunctionDescriptor yn$descriptor() {
        return yn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MethodHandle yn$handle() {
        return yn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static MemorySegment yn$address() {
        return yn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double yn(int, double)
     * }
     */
    public static double yn(int x0, double x1) {
        var mh$ = yn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("yn", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class scalb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("scalb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static FunctionDescriptor scalb$descriptor() {
        return scalb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MethodHandle scalb$handle() {
        return scalb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static MemorySegment scalb$address() {
        return scalb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double scalb(double, double)
     * }
     */
    public static double scalb(double x0, double x1) {
        var mh$ = scalb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("scalb", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class signgam$constants {
        public static final OfInt LAYOUT = FFmpeg.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("signgam").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static OfInt signgam$layout() {
        return signgam$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static MemorySegment signgam$segment() {
        return signgam$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static int signgam() {
        return signgam$constants.SEGMENT.get(signgam$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int signgam
     * }
     */
    public static void signgam(int varValue) {
        signgam$constants.SEGMENT.set(signgam$constants.LAYOUT, 0L, varValue);
    }
    private static final int P_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_ALL = 0
     * }
     */
    public static int P_ALL() {
        return P_ALL;
    }
    private static final int P_PID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PID = 1
     * }
     */
    public static int P_PID() {
        return P_PID;
    }
    private static final int P_PGID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.P_PGID = 2
     * }
     */
    public static int P_PGID() {
        return P_PGID;
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_pid_t pid_t
     * }
     */
    public static final OfInt pid_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_id_t id_t
     * }
     */
    public static final OfInt id_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int sig_atomic_t
     * }
     */
    public static final OfInt sig_atomic_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef struct __darwin_mcontext64 {
     *     struct __darwin_arm_exception_state64 __es;
     *     struct __darwin_arm_thread_state64 __ss;
     *     struct __darwin_arm_neon_state64 __ns;
     * } *mcontext_t
     * }
     */
    public static final AddressLayout mcontext_t = FFmpeg.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __darwin_sigset_t sigset_t
     * }
     */
    public static final OfInt sigset_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_uid_t uid_t
     * }
     */
    public static final OfInt uid_t = FFmpeg.C_INT;

    private static class signal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("signal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static FunctionDescriptor signal$descriptor() {
        return signal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MethodHandle signal$handle() {
        return signal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal$address() {
        return signal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void (*signal(int, void (*)(int)))(int)
     * }
     */
    public static MemorySegment signal(int x0, MemorySegment x1) {
        var mh$ = signal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("signal", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __uint64_t rlim_t
     * }
     */
    public static final OfLong rlim_t = FFmpeg.C_LONG_LONG;
    /**
     * {@snippet lang=c :
     * typedef void *rusage_info_t
     * }
     */
    public static final AddressLayout rusage_info_t = FFmpeg.C_POINTER;

    private static class getpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static FunctionDescriptor getpriority$descriptor() {
        return getpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MethodHandle getpriority$handle() {
        return getpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static MemorySegment getpriority$address() {
        return getpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getpriority(int, id_t)
     * }
     */
    public static int getpriority(int x0, int x1) {
        var mh$ = getpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getpriority", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static FunctionDescriptor getiopolicy_np$descriptor() {
        return getiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MethodHandle getiopolicy_np$handle() {
        return getiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static MemorySegment getiopolicy_np$address() {
        return getiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getiopolicy_np(int, int)
     * }
     */
    public static int getiopolicy_np(int x0, int x1) {
        var mh$ = getiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getiopolicy_np", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static FunctionDescriptor getrlimit$descriptor() {
        return getrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MethodHandle getrlimit$handle() {
        return getrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static MemorySegment getrlimit$address() {
        return getrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrlimit(int, struct rlimit *)
     * }
     */
    public static int getrlimit(int x0, MemorySegment x1) {
        var mh$ = getrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getrusage {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getrusage");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static FunctionDescriptor getrusage$descriptor() {
        return getrusage.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MethodHandle getrusage$handle() {
        return getrusage.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static MemorySegment getrusage$address() {
        return getrusage.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getrusage(int, struct rusage *)
     * }
     */
    public static int getrusage(int x0, MemorySegment x1) {
        var mh$ = getrusage.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getrusage", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setpriority {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setpriority");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static FunctionDescriptor setpriority$descriptor() {
        return setpriority.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MethodHandle setpriority$handle() {
        return setpriority.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static MemorySegment setpriority$address() {
        return setpriority.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setpriority(int, id_t, int)
     * }
     */
    public static int setpriority(int x0, int x1, int x2) {
        var mh$ = setpriority.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setpriority", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setiopolicy_np {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setiopolicy_np");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static FunctionDescriptor setiopolicy_np$descriptor() {
        return setiopolicy_np.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MethodHandle setiopolicy_np$handle() {
        return setiopolicy_np.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static MemorySegment setiopolicy_np$address() {
        return setiopolicy_np.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setiopolicy_np(int, int, int)
     * }
     */
    public static int setiopolicy_np(int x0, int x1, int x2) {
        var mh$ = setiopolicy_np.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setiopolicy_np", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setrlimit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setrlimit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static FunctionDescriptor setrlimit$descriptor() {
        return setrlimit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MethodHandle setrlimit$handle() {
        return setrlimit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static MemorySegment setrlimit$address() {
        return setrlimit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setrlimit(int, const struct rlimit *)
     * }
     */
    public static int setrlimit(int x0, MemorySegment x1) {
        var mh$ = setrlimit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setrlimit", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static FunctionDescriptor wait$descriptor() {
        return wait.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MethodHandle wait$handle() {
        return wait.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static MemorySegment wait$address() {
        return wait.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait(int *)
     * }
     */
    public static int wait(MemorySegment x0) {
        var mh$ = wait.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitpid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitpid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static FunctionDescriptor waitpid$descriptor() {
        return waitpid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MethodHandle waitpid$handle() {
        return waitpid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static MemorySegment waitpid$address() {
        return waitpid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t waitpid(pid_t, int *, int)
     * }
     */
    public static int waitpid(int x0, MemorySegment x1, int x2) {
        var mh$ = waitpid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitpid", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class waitid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("waitid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static FunctionDescriptor waitid$descriptor() {
        return waitid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MethodHandle waitid$handle() {
        return waitid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static MemorySegment waitid$address() {
        return waitid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int waitid(idtype_t, id_t, siginfo_t *, int)
     * }
     */
    public static int waitid(int x0, int x1, MemorySegment x2, int x3) {
        var mh$ = waitid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("waitid", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait3$descriptor() {
        return wait3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait3$handle() {
        return wait3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait3$address() {
        return wait3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait3(int *, int, struct rusage *)
     * }
     */
    public static int wait3(MemorySegment x0, int x1, MemorySegment x2) {
        var mh$ = wait3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait3", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wait4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wait4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static FunctionDescriptor wait4$descriptor() {
        return wait4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MethodHandle wait4$handle() {
        return wait4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static MemorySegment wait4$address() {
        return wait4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * pid_t wait4(pid_t, int *, int, struct rusage *)
     * }
     */
    public static int wait4(int x0, MemorySegment x1, int x2, MemorySegment x3) {
        var mh$ = wait4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wait4", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_ct_rune_t ct_rune_t
     * }
     */
    public static final OfInt ct_rune_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_rune_t rune_t
     * }
     */
    public static final OfInt rune_t = FFmpeg.C_INT;

    private static class __mb_cur_max$constants {
        public static final OfInt LAYOUT = FFmpeg.C_INT;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("__mb_cur_max").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static OfInt __mb_cur_max$layout() {
        return __mb_cur_max$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static MemorySegment __mb_cur_max$segment() {
        return __mb_cur_max$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static int __mb_cur_max() {
        return __mb_cur_max$constants.SEGMENT.get(__mb_cur_max$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern int __mb_cur_max
     * }
     */
    public static void __mb_cur_max(int varValue) {
        __mb_cur_max$constants.SEGMENT.set(__mb_cur_max$constants.LAYOUT, 0L, varValue);
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long long malloc_type_id_t
     * }
     */
    public static final OfLong malloc_type_id_t = FFmpeg.C_LONG_LONG;

    private static class malloc_type_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_malloc$descriptor() {
        return malloc_type_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_malloc$handle() {
        return malloc_type_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc$address() {
        return malloc_type_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_malloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_malloc(long size, long type_id) {
        var mh$ = malloc_type_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_malloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_calloc$descriptor() {
        return malloc_type_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_calloc$handle() {
        return malloc_type_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc$address() {
        return malloc_type_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_calloc(long count, long size, long type_id) {
        var mh$ = malloc_type_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_calloc", count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(count, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_free$descriptor() {
        return malloc_type_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_free$handle() {
        return malloc_type_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_free$address() {
        return malloc_type_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_free(void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_free(MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_free", ptr, type_id);
            }
            mh$.invokeExact(ptr, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_realloc$descriptor() {
        return malloc_type_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_realloc$handle() {
        return malloc_type_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc$address() {
        return malloc_type_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_realloc(MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_realloc", ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_valloc$descriptor() {
        return malloc_type_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_valloc$handle() {
        return malloc_type_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc$address() {
        return malloc_type_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_valloc(size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_valloc(long size, long type_id) {
        var mh$ = malloc_type_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_valloc", size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_aligned_alloc$descriptor() {
        return malloc_type_aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_aligned_alloc$handle() {
        return malloc_type_aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc$address() {
        return malloc_type_aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_aligned_alloc(size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_aligned_alloc(long alignment, long size, long type_id) {
        var mh$ = malloc_type_aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_aligned_alloc", alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(alignment, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_posix_memalign$descriptor() {
        return malloc_type_posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_posix_memalign$handle() {
        return malloc_type_posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_posix_memalign$address() {
        return malloc_type_posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static int malloc_type_posix_memalign(MemorySegment memptr, long alignment, long size, long type_id) {
        var mh$ = malloc_type_posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_posix_memalign", memptr, alignment, size, type_id);
            }
            return (int)mh$.invokeExact(memptr, alignment, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_malloc$descriptor() {
        return malloc_type_zone_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_malloc$handle() {
        return malloc_type_zone_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc$address() {
        return malloc_type_zone_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_malloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_malloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_malloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_calloc$descriptor() {
        return malloc_type_zone_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_calloc$handle() {
        return malloc_type_zone_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc$address() {
        return malloc_type_zone_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_calloc(malloc_zone_t *zone, size_t count, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_calloc(MemorySegment zone, long count, long size, long type_id) {
        var mh$ = malloc_type_zone_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_calloc", zone, count, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, count, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_free$descriptor() {
        return malloc_type_zone_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_free$handle() {
        return malloc_type_zone_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_free$address() {
        return malloc_type_zone_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void malloc_type_zone_free(malloc_zone_t *zone, void *ptr, malloc_type_id_t type_id)
     * }
     */
    public static void malloc_type_zone_free(MemorySegment zone, MemorySegment ptr, long type_id) {
        var mh$ = malloc_type_zone_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_free", zone, ptr, type_id);
            }
            mh$.invokeExact(zone, ptr, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_realloc$descriptor() {
        return malloc_type_zone_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_realloc$handle() {
        return malloc_type_zone_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc$address() {
        return malloc_type_zone_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_realloc(MemorySegment zone, MemorySegment ptr, long size, long type_id) {
        var mh$ = malloc_type_zone_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_realloc", zone, ptr, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, ptr, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_valloc$descriptor() {
        return malloc_type_zone_valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_valloc$handle() {
        return malloc_type_zone_valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc$address() {
        return malloc_type_zone_valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_valloc(malloc_zone_t *zone, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_valloc(MemorySegment zone, long size, long type_id) {
        var mh$ = malloc_type_zone_valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_valloc", zone, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc_type_zone_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc_type_zone_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static FunctionDescriptor malloc_type_zone_memalign$descriptor() {
        return malloc_type_zone_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MethodHandle malloc_type_zone_memalign$handle() {
        return malloc_type_zone_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign$address() {
        return malloc_type_zone_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc_type_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size, malloc_type_id_t type_id)
     * }
     */
    public static MemorySegment malloc_type_zone_memalign(MemorySegment zone, long alignment, long size, long type_id) {
        var mh$ = malloc_type_zone_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc_type_zone_memalign", zone, alignment, size, type_id);
            }
            return (MemorySegment)mh$.invokeExact(zone, alignment, size, type_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *calloc(size_t __count, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __count, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __count, __size);
            }
            return (MemorySegment)mh$.invokeExact(__count, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void free(void *)
     * }
     */
    public static void free(MemorySegment x0) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("reallocf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocf$descriptor() {
        return reallocf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle reallocf$handle() {
        return reallocf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf$address() {
        return reallocf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *reallocf(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment reallocf(MemorySegment __ptr, long __size) {
        var mh$ = reallocf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocf", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int abs(int)
     * }
     */
    public static int abs(int x0) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit(void (* _Nonnull)(void))
     * }
     */
    public static int atexit(MemorySegment x0) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int at_quick_exit(void (*)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment x0) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double atof(const char *)
     * }
     */
    public static double atof(MemorySegment x0) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atoi(const char *)
     * }
     */
    public static int atoi(MemorySegment x0) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long atol(const char *)
     * }
     */
    public static long atol(MemorySegment x0) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long atoll(const char *)
     * }
     */
    public static long atoll(MemorySegment x0) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch(const void *__key, const void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * div_t div(int, int)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int x0, int x1) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void exit(int)
     * }
     */
    public static void exit(int x0) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getenv(const char *)
     * }
     */
    public static MemorySegment getenv(MemorySegment x0) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long labs(long)
     * }
     */
    public static long labs(long x0) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ldiv_t ldiv(long, long)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long llabs(long long)
     * }
     */
    public static long llabs(long x0) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * lldiv_t lldiv(long long, long long)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long x0, long x1) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t mbstowcs(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", x0, x1, __n);
            }
            return (long)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mbtowc(wchar_t *restrict, const char *restrict, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", x0, x1, __n);
            }
            return (int)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void qsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void quick_exit(int)
     * }
     */
    public static void quick_exit(int x0) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand(unsigned int)
     * }
     */
    public static void srand(int x0) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double strtod(const char *, char **)
     * }
     */
    public static double strtod(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", x0, x1);
            }
            return (double)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_FLOAT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * float strtof(const char *, char **)
     * }
     */
    public static float strtof(MemorySegment x0, MemorySegment x1) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", x0, x1);
            }
            return (float)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long strtol(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoll(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strtoul(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtoull(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int system(const char *)
     * }
     */
    public static int system(MemorySegment x0) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t wcstombs(char *restrict, const wchar_t *restrict, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", x0, x1, __n);
            }
            return (long)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int wctomb(char *, wchar_t)
     * }
     */
    public static int wctomb(MemorySegment x0, int x1) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void _Exit(int)
     * }
     */
    public static void _Exit(int x0) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long a64l(const char *)
     * }
     */
    public static long a64l(MemorySegment x0) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ecvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment ecvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double erand48(unsigned short [3])
     * }
     */
    public static double erand48(MemorySegment x0) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", x0);
            }
            return (double)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *fcvt(double, int, int *restrict, int *restrict)
     * }
     */
    public static MemorySegment fcvt(double x0, int x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *gcvt(double, int, char *)
     * }
     */
    public static MemorySegment gcvt(double x0, int x1, MemorySegment x2) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getsubopt(char **, char *const *, char **)
     * }
     */
    public static int getsubopt(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class grantpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("grantpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static FunctionDescriptor grantpt$descriptor() {
        return grantpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MethodHandle grantpt$handle() {
        return grantpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static MemorySegment grantpt$address() {
        return grantpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int grantpt(int)
     * }
     */
    public static int grantpt(int x0) {
        var mh$ = grantpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("grantpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *initstate(unsigned int, char *, size_t __size)
     * }
     */
    public static MemorySegment initstate(int x0, MemorySegment x1, long __size) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", x0, x1, __size);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long jrand48(unsigned short [3])
     * }
     */
    public static long jrand48(MemorySegment x0) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *l64a(long)
     * }
     */
    public static MemorySegment l64a(long x0) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void lcong48(unsigned short [7])
     * }
     */
    public static void lcong48(MemorySegment x0) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *mktemp(char *)
     * }
     */
    public static MemorySegment mktemp(MemorySegment x0) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mkstemp(char *)
     * }
     */
    public static int mkstemp(MemorySegment x0) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long nrand48(unsigned short [3])
     * }
     */
    public static long nrand48(MemorySegment x0) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", x0);
            }
            return (long)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_openpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("posix_openpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static FunctionDescriptor posix_openpt$descriptor() {
        return posix_openpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MethodHandle posix_openpt$handle() {
        return posix_openpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static MemorySegment posix_openpt$address() {
        return posix_openpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int posix_openpt(int)
     * }
     */
    public static int posix_openpt(int x0) {
        var mh$ = posix_openpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_openpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ptsname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static FunctionDescriptor ptsname$descriptor() {
        return ptsname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MethodHandle ptsname$handle() {
        return ptsname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname$address() {
        return ptsname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ptsname(int)
     * }
     */
    public static MemorySegment ptsname(int x0) {
        var mh$ = ptsname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ptsname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ptsname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static FunctionDescriptor ptsname_r$descriptor() {
        return ptsname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MethodHandle ptsname_r$handle() {
        return ptsname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static MemorySegment ptsname_r$address() {
        return ptsname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ptsname_r(int fildes, char *buffer, size_t buflen)
     * }
     */
    public static int ptsname_r(int fildes, MemorySegment buffer, long buflen) {
        var mh$ = ptsname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ptsname_r", fildes, buffer, buflen);
            }
            return (int)mh$.invokeExact(fildes, buffer, buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int putenv(char *)
     * }
     */
    public static int putenv(MemorySegment x0) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rand_r(unsigned int *)
     * }
     */
    public static int rand_r(MemorySegment x0) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("realpath$DARWIN_EXTSN");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *realpath(const char *restrict, char *restrict)
     * }
     */
    public static MemorySegment realpath(MemorySegment x0, MemorySegment x1) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned short *seed48(unsigned short [3])
     * }
     */
    public static MemorySegment seed48(MemorySegment x0) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int setenv(const char *__name, const char *__value, int __overwrite)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __overwrite) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __overwrite);
            }
            return (int)mh$.invokeExact(__name, __value, __overwrite);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setkey {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setkey");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static FunctionDescriptor setkey$descriptor() {
        return setkey.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MethodHandle setkey$handle() {
        return setkey.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static MemorySegment setkey$address() {
        return setkey.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setkey(const char *)
     * }
     */
    public static void setkey(MemorySegment x0) {
        var mh$ = setkey.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setkey", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *setstate(const char *)
     * }
     */
    public static MemorySegment setstate(MemorySegment x0) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srand48(long)
     * }
     */
    public static void srand48(long x0) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandom(unsigned int)
     * }
     */
    public static void srandom(int x0) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unlockpt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unlockpt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static FunctionDescriptor unlockpt$descriptor() {
        return unlockpt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MethodHandle unlockpt$handle() {
        return unlockpt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static MemorySegment unlockpt$address() {
        return unlockpt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unlockpt(int)
     * }
     */
    public static int unlockpt(int x0) {
        var mh$ = unlockpt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unlockpt", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int unsetenv(const char *)
     * }
     */
    public static int unsetenv(MemorySegment x0) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_dev_t dev_t
     * }
     */
    public static final OfInt dev_t = FFmpeg.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __darwin_mode_t mode_t
     * }
     */
    public static final OfShort mode_t = FFmpeg.C_SHORT;

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_addrandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_addrandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static FunctionDescriptor arc4random_addrandom$descriptor() {
        return arc4random_addrandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static MethodHandle arc4random_addrandom$handle() {
        return arc4random_addrandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static MemorySegment arc4random_addrandom$address() {
        return arc4random_addrandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_addrandom(unsigned char *, int __datlen)
     * }
     */
    public static void arc4random_addrandom(MemorySegment x0, int __datlen) {
        var mh$ = arc4random_addrandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_addrandom", x0, __datlen);
            }
            mh$.invokeExact(x0, __datlen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_buf(void *__buf, size_t __nbytes)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __nbytes) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __nbytes);
            }
            mh$.invokeExact(__buf, __nbytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_stir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_stir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static FunctionDescriptor arc4random_stir$descriptor() {
        return arc4random_stir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MethodHandle arc4random_stir$handle() {
        return arc4random_stir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static MemorySegment arc4random_stir$address() {
        return arc4random_stir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void arc4random_stir()
     * }
     */
    public static void arc4random_stir() {
        var mh$ = arc4random_stir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_stir");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t arc4random_uniform(uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("atexit_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static FunctionDescriptor atexit_b$descriptor() {
        return atexit_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MethodHandle atexit_b$handle() {
        return atexit_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static MemorySegment atexit_b$address() {
        return atexit_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int atexit_b(void (^ _Nonnull)(void))
     * }
     */
    public static int atexit_b(MemorySegment x0) {
        var mh$ = atexit_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit_b", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bsearch_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor bsearch_b$descriptor() {
        return bsearch_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle bsearch_b$handle() {
        return bsearch_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b$address() {
        return bsearch_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *bsearch_b(const void *__key, const void *__base, size_t __nel, size_t __width, __bsearch_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment bsearch_b(MemorySegment __key, MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = bsearch_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch_b", __key, __base, __nel, __width, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetcap {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetcap");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static FunctionDescriptor cgetcap$descriptor() {
        return cgetcap.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MethodHandle cgetcap$handle() {
        return cgetcap.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap$address() {
        return cgetcap.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *cgetcap(char *, const char *, int)
     * }
     */
    public static MemorySegment cgetcap(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = cgetcap.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetcap", x0, x1, x2);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static FunctionDescriptor cgetclose$descriptor() {
        return cgetclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MethodHandle cgetclose$handle() {
        return cgetclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static MemorySegment cgetclose$address() {
        return cgetclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetclose()
     * }
     */
    public static int cgetclose() {
        var mh$ = cgetclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetclose");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static FunctionDescriptor cgetent$descriptor() {
        return cgetent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MethodHandle cgetent$handle() {
        return cgetent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static MemorySegment cgetent$address() {
        return cgetent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetent(char **, char **, const char *)
     * }
     */
    public static int cgetent(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetent", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetfirst {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetfirst");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetfirst$descriptor() {
        return cgetfirst.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MethodHandle cgetfirst$handle() {
        return cgetfirst.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static MemorySegment cgetfirst$address() {
        return cgetfirst.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetfirst(char **, char **)
     * }
     */
    public static int cgetfirst(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetfirst.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetfirst", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static FunctionDescriptor cgetmatch$descriptor() {
        return cgetmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MethodHandle cgetmatch$handle() {
        return cgetmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static MemorySegment cgetmatch$address() {
        return cgetmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetmatch(const char *, const char *)
     * }
     */
    public static int cgetmatch(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetmatch", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetnext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static FunctionDescriptor cgetnext$descriptor() {
        return cgetnext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MethodHandle cgetnext$handle() {
        return cgetnext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static MemorySegment cgetnext$address() {
        return cgetnext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnext(char **, char **)
     * }
     */
    public static int cgetnext(MemorySegment x0, MemorySegment x1) {
        var mh$ = cgetnext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnext", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetnum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetnum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static FunctionDescriptor cgetnum$descriptor() {
        return cgetnum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MethodHandle cgetnum$handle() {
        return cgetnum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static MemorySegment cgetnum$address() {
        return cgetnum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetnum(char *, const char *, long *)
     * }
     */
    public static int cgetnum(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetnum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetnum", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static FunctionDescriptor cgetset$descriptor() {
        return cgetset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MethodHandle cgetset$handle() {
        return cgetset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static MemorySegment cgetset$address() {
        return cgetset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetset(const char *)
     * }
     */
    public static int cgetset(MemorySegment x0) {
        var mh$ = cgetset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetset", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetstr$descriptor() {
        return cgetstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetstr$handle() {
        return cgetstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetstr$address() {
        return cgetstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetstr(char *, const char *, char **)
     * }
     */
    public static int cgetstr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetstr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class cgetustr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("cgetustr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static FunctionDescriptor cgetustr$descriptor() {
        return cgetustr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MethodHandle cgetustr$handle() {
        return cgetustr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static MemorySegment cgetustr$address() {
        return cgetustr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int cgetustr(char *, const char *, char **)
     * }
     */
    public static int cgetustr(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = cgetustr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("cgetustr", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class daemon {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("daemon");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static FunctionDescriptor daemon$descriptor() {
        return daemon.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MethodHandle daemon$handle() {
        return daemon.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static MemorySegment daemon$address() {
        return daemon.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int daemon(int, int)
     * }
     */
    public static int daemon(int x0, int x1) {
        var mh$ = daemon.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("daemon", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_SHORT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("devname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static FunctionDescriptor devname$descriptor() {
        return devname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MethodHandle devname$handle() {
        return devname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname$address() {
        return devname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname(dev_t, mode_t)
     * }
     */
    public static MemorySegment devname(int x0, short x1) {
        var mh$ = devname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class devname_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_SHORT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("devname_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static FunctionDescriptor devname_r$descriptor() {
        return devname_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MethodHandle devname_r$handle() {
        return devname_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r$address() {
        return devname_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *devname_r(dev_t, mode_t, char *buf, int len)
     * }
     */
    public static MemorySegment devname_r(int x0, short x1, MemorySegment buf, int len) {
        var mh$ = devname_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("devname_r", x0, x1, buf, len);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1, buf, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getbsize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getbsize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static FunctionDescriptor getbsize$descriptor() {
        return getbsize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MethodHandle getbsize$handle() {
        return getbsize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize$address() {
        return getbsize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *getbsize(int *, long *)
     * }
     */
    public static MemorySegment getbsize(MemorySegment x0, MemorySegment x1) {
        var mh$ = getbsize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getbsize", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int getloadavg(double [], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment x0, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", x0, __nelem);
            }
            return (int)mh$.invokeExact(x0, __nelem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("getprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static FunctionDescriptor getprogname$descriptor() {
        return getprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MethodHandle getprogname$handle() {
        return getprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname$address() {
        return getprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *getprogname()
     * }
     */
    public static MemorySegment getprogname() {
        var mh$ = getprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getprogname");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setprogname {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("setprogname");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static FunctionDescriptor setprogname$descriptor() {
        return setprogname.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MethodHandle setprogname$handle() {
        return setprogname.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static MemorySegment setprogname$address() {
        return setprogname.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void setprogname(const char *)
     * }
     */
    public static void setprogname(MemorySegment x0) {
        var mh$ = setprogname.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setprogname", x0);
            }
            mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("heapsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort$descriptor() {
        return heapsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort$handle() {
        return heapsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort$address() {
        return heapsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int heapsort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class heapsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("heapsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor heapsort_b$descriptor() {
        return heapsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle heapsort_b$handle() {
        return heapsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment heapsort_b$address() {
        return heapsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int heapsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int heapsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = heapsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("heapsort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mergesort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort$descriptor() {
        return mergesort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort$handle() {
        return mergesort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort$address() {
        return mergesort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static int mergesort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mergesort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("mergesort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor mergesort_b$descriptor() {
        return mergesort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle mergesort_b$handle() {
        return mergesort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment mergesort_b$address() {
        return mergesort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int mergesort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static int mergesort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = mergesort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mergesort_b", __base, __nel, __width, __compar);
            }
            return (int)mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort$descriptor() {
        return psort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort$handle() {
        return psort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort$address() {
        return psort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort(void *__base, size_t __nel, size_t __width, int (* _Nonnull __compar)(const void *, const void *))
     * }
     */
    public static void psort(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_b$descriptor() {
        return psort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle psort_b$handle() {
        return psort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment psort_b$address() {
        return psort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void psort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = psort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class psort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("psort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor psort_r$descriptor() {
        return psort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle psort_r$handle() {
        return psort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment psort_r$address() {
        return psort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void psort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void psort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = psort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("psort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_b {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_b");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_b$descriptor() {
        return qsort_b.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MethodHandle qsort_b$handle() {
        return qsort_b.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static MemorySegment qsort_b$address() {
        return qsort_b.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_b(void *__base, size_t __nel, size_t __width, __sort_noescape int (^__compar)(const void *, const void *))
     * }
     */
    public static void qsort_b(MemorySegment __base, long __nel, long __width, MemorySegment __compar) {
        var mh$ = qsort_b.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_b", __base, __nel, __width, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("qsort_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static FunctionDescriptor qsort_r$descriptor() {
        return qsort_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MethodHandle qsort_r$handle() {
        return qsort_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static MemorySegment qsort_r$address() {
        return qsort_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void qsort_r(void *__base, size_t __nel, size_t __width, void *, int (* _Nonnull __compar)(void *, const void *, const void *))
     * }
     */
    public static void qsort_r(MemorySegment __base, long __nel, long __width, MemorySegment x3, MemorySegment __compar) {
        var mh$ = qsort_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort_r", __base, __nel, __width, x3, __compar);
            }
            mh$.invokeExact(__base, __nel, __width, x3, __compar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class radixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("radixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor radixsort$descriptor() {
        return radixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle radixsort$handle() {
        return radixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment radixsort$address() {
        return radixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int radixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = radixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("radixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int rpmatch(const char *)
     * }
     */
    public static int rpmatch(MemorySegment x0) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sradixsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sradixsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static FunctionDescriptor sradixsort$descriptor() {
        return sradixsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MethodHandle sradixsort$handle() {
        return sradixsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static MemorySegment sradixsort$address() {
        return sradixsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table, unsigned int __endbyte)
     * }
     */
    public static int sradixsort(MemorySegment __base, int __nel, MemorySegment __table, int __endbyte) {
        var mh$ = sradixsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sradixsort", __base, __nel, __table, __endbyte);
            }
            return (int)mh$.invokeExact(__base, __nel, __table, __endbyte);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sranddev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sranddev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static FunctionDescriptor sranddev$descriptor() {
        return sranddev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MethodHandle sranddev$handle() {
        return sranddev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static MemorySegment sranddev$address() {
        return sranddev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sranddev()
     * }
     */
    public static void sranddev() {
        var mh$ = sranddev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sranddev");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandomdev {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("srandomdev");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static FunctionDescriptor srandomdev$descriptor() {
        return srandomdev.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MethodHandle srandomdev$handle() {
        return srandomdev.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static MemorySegment srandomdev$address() {
        return srandomdev.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void srandomdev()
     * }
     */
    public static void srandomdev() {
        var mh$ = srandomdev.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandomdev");
            }
            mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtonum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtonum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static FunctionDescriptor strtonum$descriptor() {
        return strtonum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MethodHandle strtonum$handle() {
        return strtonum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static MemorySegment strtonum$address() {
        return strtonum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
     * }
     */
    public static long strtonum(MemorySegment __numstr, long __minval, long __maxval, MemorySegment __errstrp) {
        var mh$ = strtonum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtonum", __numstr, __minval, __maxval, __errstrp);
            }
            return (long)mh$.invokeExact(__numstr, __minval, __maxval, __errstrp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long long strtoq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long long strtouq(const char *__str, char **__endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __str, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __str, __endptr, __base);
            }
            return (long)mh$.invokeExact(__str, __endptr, __base);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class suboptarg$constants {
        public static final AddressLayout LAYOUT = FFmpeg.C_POINTER;
        public static final MemorySegment SEGMENT = SYMBOL_LOOKUP.findOrThrow("suboptarg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static AddressLayout suboptarg$layout() {
        return suboptarg$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg$segment() {
        return suboptarg$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static MemorySegment suboptarg() {
        return suboptarg$constants.SEGMENT.get(suboptarg$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern char *suboptarg
     * }
     */
    public static void suboptarg(MemorySegment varValue) {
        suboptarg$constants.SEGMENT.set(suboptarg$constants.LAYOUT, 0L, varValue);
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memcpy(void *__dst, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmove(void *__dst, const void *__src, size_t __len)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dst, MemorySegment __src, long __len) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dst, __src, __len);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memset(void *__b, int __c, size_t __len)
     * }
     */
    public static MemorySegment memset(MemorySegment __b, int __c, long __len) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __b, __c, __len);
            }
            return (MemorySegment)mh$.invokeExact(__b, __c, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcat(char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcat(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __s1, __s2);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strcspn(const char *__s, const char *__charset)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncat(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __s1, __s2, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strpbrk(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __charset);
            }
            return (MemorySegment)mh$.invokeExact(__s, __charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strspn(const char *__s, const char *__charset)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __charset) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __charset);
            }
            return (long)mh$.invokeExact(__s, __charset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strstr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strstr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok(char *__str, const char *__sep)
     * }
     */
    public static MemorySegment strtok(MemorySegment __str, MemorySegment __sep) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __str, __sep);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strxfrm(char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __s1, __s2, __n);
            }
            return (long)mh$.invokeExact(__s1, __s2, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strtok_r(char *__str, const char *__sep, char **__lasts)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __str, MemorySegment __sep, MemorySegment __lasts) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __str, __sep, __lasts);
            }
            return (MemorySegment)mh$.invokeExact(__str, __sep, __lasts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __strerrbuf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __strerrbuf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __strerrbuf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strdup(const char *__s1)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s1) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s1);
            }
            return (MemorySegment)mh$.invokeExact(__s1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memccpy(void *__dst, const void *__src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dst, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dst, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpcpy(char *__dst, const char *__src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dst, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dst, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *stpncpy(char *__dst, const char *__src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dst, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dst, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dst, __src, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strndup(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __s1, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __s1, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t strnlen(const char *__s1, size_t __n)
     * }
     */
    public static long strnlen(MemorySegment __s1, long __n) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __s1, __n);
            }
            return (long)mh$.invokeExact(__s1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __darwin_size_t rsize_t
     * }
     */
    public static final OfLong rsize_t = FFmpeg.C_LONG;

    private static class memset_s {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_s");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static FunctionDescriptor memset_s$descriptor() {
        return memset_s.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MethodHandle memset_s$handle() {
        return memset_s.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static MemorySegment memset_s$address() {
        return memset_s.ADDR;
    }

    /**
     * {@snippet lang=c :
     * errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
     * }
     */
    public static int memset_s(MemorySegment __s, long __smax, int __c, long __n) {
        var mh$ = memset_s.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_s", __s, __smax, __c, __n);
            }
            return (int)mh$.invokeExact(__s, __smax, __c, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len)
     * }
     */
    public static MemorySegment memmem(MemorySegment __big, long __big_len, MemorySegment __little, long __little_len) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __big, __big_len, __little, __little_len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __big_len, __little, __little_len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern4 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_pattern4");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern4$descriptor() {
        return memset_pattern4.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern4$handle() {
        return memset_pattern4.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern4$address() {
        return memset_pattern4.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern4(void *__b, const void *__pattern4, size_t __len)
     * }
     */
    public static void memset_pattern4(MemorySegment __b, MemorySegment __pattern4, long __len) {
        var mh$ = memset_pattern4.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern4", __b, __pattern4, __len);
            }
            mh$.invokeExact(__b, __pattern4, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_pattern8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern8$descriptor() {
        return memset_pattern8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern8$handle() {
        return memset_pattern8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern8$address() {
        return memset_pattern8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern8(void *__b, const void *__pattern8, size_t __len)
     * }
     */
    public static void memset_pattern8(MemorySegment __b, MemorySegment __pattern8, long __len) {
        var mh$ = memset_pattern8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern8", __b, __pattern8, __len);
            }
            mh$.invokeExact(__b, __pattern8, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset_pattern16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("memset_pattern16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static FunctionDescriptor memset_pattern16$descriptor() {
        return memset_pattern16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MethodHandle memset_pattern16$handle() {
        return memset_pattern16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static MemorySegment memset_pattern16$address() {
        return memset_pattern16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
     * }
     */
    public static void memset_pattern16(MemorySegment __b, MemorySegment __pattern16, long __len) {
        var mh$ = memset_pattern16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset_pattern16", __b, __pattern16, __len);
            }
            mh$.invokeExact(__b, __pattern16, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strcasestr(const char *__big, const char *__little)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __big, MemorySegment __little) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __big, __little);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strchrnul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul$address() {
        return strchrnul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strnstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static FunctionDescriptor strnstr$descriptor() {
        return strnstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MethodHandle strnstr$handle() {
        return strnstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr$address() {
        return strnstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strnstr(const char *__big, const char *__little, size_t __len)
     * }
     */
    public static MemorySegment strnstr(MemorySegment __big, MemorySegment __little, long __len) {
        var mh$ = strnstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnstr", __big, __little, __len);
            }
            return (MemorySegment)mh$.invokeExact(__big, __little, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcat(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcat(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned long strlcpy(char *__dst, const char *__source, size_t __size)
     * }
     */
    public static long strlcpy(MemorySegment __dst, MemorySegment __source, long __size) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dst, __source, __size);
            }
            return (long)mh$.invokeExact(__dst, __source, __size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strmode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strmode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static FunctionDescriptor strmode$descriptor() {
        return strmode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MethodHandle strmode$handle() {
        return strmode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static MemorySegment strmode$address() {
        return strmode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void strmode(int __mode, char *__bp)
     * }
     */
    public static void strmode(int __mode, MemorySegment __bp) {
        var mh$ = strmode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strmode", __mode, __bp);
            }
            mh$.invokeExact(__mode, __bp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *strsep(char **__stringp, const char *__delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swab {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swab");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static FunctionDescriptor swab$descriptor() {
        return swab.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static MethodHandle swab$handle() {
        return swab.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static MemorySegment swab$address() {
        return swab.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void swab(const void *restrict, void *restrict, ssize_t __len)
     * }
     */
    public static void swab(MemorySegment x0, MemorySegment x1, long __len) {
        var mh$ = swab.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swab", x0, x1, __len);
            }
            mh$.invokeExact(x0, x1, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class timingsafe_bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("timingsafe_bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static FunctionDescriptor timingsafe_bcmp$descriptor() {
        return timingsafe_bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MethodHandle timingsafe_bcmp$handle() {
        return timingsafe_bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static MemorySegment timingsafe_bcmp$address() {
        return timingsafe_bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
     * }
     */
    public static int timingsafe_bcmp(MemorySegment __b1, MemorySegment __b2, long __len) {
        var mh$ = timingsafe_bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("timingsafe_bcmp", __b1, __b2, __len);
            }
            return (int)mh$.invokeExact(__b1, __b2, __len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strsignal_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strsignal_r$descriptor() {
        return strsignal_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MethodHandle strsignal_r$handle() {
        return strsignal_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static MemorySegment strsignal_r$address() {
        return strsignal_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen)
     * }
     */
    public static int strsignal_r(int __sig, MemorySegment __strsignalbuf, long __buflen) {
        var mh$ = strsignal_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal_r", __sig, __strsignalbuf, __buflen);
            }
            return (int)mh$.invokeExact(__sig, __strsignalbuf, __buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int bcmp(const void *, const void *, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", x0, x1, __n);
            }
            return (int)mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bcopy(const void *, void *, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment x0, MemorySegment x1, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", x0, x1, __n);
            }
            mh$.invokeExact(x0, x1, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void bzero(void *, size_t __n)
     * }
     */
    public static void bzero(MemorySegment x0, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", x0, __n);
            }
            mh$.invokeExact(x0, __n);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *index(const char *, int)
     * }
     */
    public static MemorySegment index(MemorySegment x0, int x1) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *rindex(const char *, int)
     * }
     */
    public static MemorySegment rindex(MemorySegment x0, int x1) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", x0, x1);
            }
            return (MemorySegment)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffs(int)
     * }
     */
    public static int ffs(int x0) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strcasecmp(const char *, const char *)
     * }
     */
    public static int strcasecmp(MemorySegment x0, MemorySegment x1) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int strncasecmp(const char *, const char *, size_t)
     * }
     */
    public static int strncasecmp(MemorySegment x0, MemorySegment x1, long x2) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsl(long)
     * }
     */
    public static int ffsl(long x0) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ffsll(long long)
     * }
     */
    public static int ffsll(long x0) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fls {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("fls");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static FunctionDescriptor fls$descriptor() {
        return fls.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MethodHandle fls$handle() {
        return fls.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static MemorySegment fls$address() {
        return fls.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int fls(int)
     * }
     */
    public static int fls(int x0) {
        var mh$ = fls.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fls", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static FunctionDescriptor flsl$descriptor() {
        return flsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MethodHandle flsl$handle() {
        return flsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static MemorySegment flsl$address() {
        return flsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsl(long)
     * }
     */
    public static int flsl(long x0) {
        var mh$ = flsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsl", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("flsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static FunctionDescriptor flsll$descriptor() {
        return flsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MethodHandle flsll$handle() {
        return flsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static MemorySegment flsll$address() {
        return flsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int flsll(long long)
     * }
     */
    public static int flsll(long x0) {
        var mh$ = flsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flsll", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = FFmpeg.C_LONG;

    private static class av_strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static FunctionDescriptor av_strerror$descriptor() {
        return av_strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MethodHandle av_strerror$handle() {
        return av_strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static MemorySegment av_strerror$address() {
        return av_strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_strerror(int errnum, char *errbuf, size_t errbuf_size)
     * }
     */
    public static int av_strerror(int errnum, MemorySegment errbuf, long errbuf_size) {
        var mh$ = av_strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strerror", errnum, errbuf, errbuf_size);
            }
            return (int)mh$.invokeExact(errnum, errbuf, errbuf_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc$descriptor() {
        return av_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MethodHandle av_malloc$handle() {
        return av_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc$address() {
        return av_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc(size_t size)
     * }
     */
    public static MemorySegment av_malloc(long size) {
        var mh$ = av_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static FunctionDescriptor av_mallocz$descriptor() {
        return av_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MethodHandle av_mallocz$handle() {
        return av_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz$address() {
        return av_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_mallocz(size_t size)
     * }
     */
    public static MemorySegment av_mallocz(long size) {
        var mh$ = av_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mallocz", size);
            }
            return (MemorySegment)mh$.invokeExact(size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_malloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_malloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_malloc_array$descriptor() {
        return av_malloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_malloc_array$handle() {
        return av_malloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array$address() {
        return av_malloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_malloc_array(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_malloc_array(long nmemb, long size) {
        var mh$ = av_malloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_malloc_array", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_calloc$descriptor() {
        return av_calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_calloc$handle() {
        return av_calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc$address() {
        return av_calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_calloc(size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_calloc(long nmemb, long size) {
        var mh$ = av_calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_calloc", nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc$descriptor() {
        return av_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_realloc$handle() {
        return av_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc$address() {
        return av_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_realloc(MemorySegment ptr, long size) {
        var mh$ = av_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc", ptr, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reallocp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp$descriptor() {
        return av_reallocp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MethodHandle av_reallocp$handle() {
        return av_reallocp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static MemorySegment av_reallocp$address() {
        return av_reallocp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp(void *ptr, size_t size)
     * }
     */
    public static int av_reallocp(MemorySegment ptr, long size) {
        var mh$ = av_reallocp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp", ptr, size);
            }
            return (int)mh$.invokeExact(ptr, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_f {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc_f");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static FunctionDescriptor av_realloc_f$descriptor() {
        return av_realloc_f.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MethodHandle av_realloc_f$handle() {
        return av_realloc_f.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f$address() {
        return av_realloc_f.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_f(void *ptr, size_t nelem, size_t elsize)
     * }
     */
    public static MemorySegment av_realloc_f(MemorySegment ptr, long nelem, long elsize) {
        var mh$ = av_realloc_f.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_f", ptr, nelem, elsize);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nelem, elsize);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_realloc_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_realloc_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_realloc_array$descriptor() {
        return av_realloc_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_realloc_array$handle() {
        return av_realloc_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array$address() {
        return av_realloc_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_realloc_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_realloc_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_realloc_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_realloc_array", ptr, nmemb, size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reallocp_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reallocp_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static FunctionDescriptor av_reallocp_array$descriptor() {
        return av_reallocp_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MethodHandle av_reallocp_array$handle() {
        return av_reallocp_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static MemorySegment av_reallocp_array$address() {
        return av_reallocp_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reallocp_array(void *ptr, size_t nmemb, size_t size)
     * }
     */
    public static int av_reallocp_array(MemorySegment ptr, long nmemb, long size) {
        var mh$ = av_reallocp_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reallocp_array", ptr, nmemb, size);
            }
            return (int)mh$.invokeExact(ptr, nmemb, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_realloc$descriptor() {
        return av_fast_realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_realloc$handle() {
        return av_fast_realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc$address() {
        return av_fast_realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_fast_realloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_realloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_realloc", ptr, size, min_size);
            }
            return (MemorySegment)mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_malloc$descriptor() {
        return av_fast_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_malloc$handle() {
        return av_fast_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_malloc$address() {
        return av_fast_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_mallocz$descriptor() {
        return av_fast_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_mallocz$handle() {
        return av_fast_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_mallocz$address() {
        return av_fast_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static FunctionDescriptor av_free$descriptor() {
        return av_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MethodHandle av_free$handle() {
        return av_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static MemorySegment av_free$address() {
        return av_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_free(void *ptr)
     * }
     */
    public static void av_free(MemorySegment ptr) {
        var mh$ = av_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_free", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_freep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_freep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static FunctionDescriptor av_freep$descriptor() {
        return av_freep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MethodHandle av_freep$handle() {
        return av_freep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static MemorySegment av_freep$address() {
        return av_freep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_freep(void *ptr)
     * }
     */
    public static void av_freep(MemorySegment ptr) {
        var mh$ = av_freep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_freep", ptr);
            }
            mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static FunctionDescriptor av_strdup$descriptor() {
        return av_strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MethodHandle av_strdup$handle() {
        return av_strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup$address() {
        return av_strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strdup(const char *s)
     * }
     */
    public static MemorySegment av_strdup(MemorySegment s) {
        var mh$ = av_strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strdup", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static FunctionDescriptor av_strndup$descriptor() {
        return av_strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MethodHandle av_strndup$handle() {
        return av_strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup$address() {
        return av_strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_strndup(const char *s, size_t len)
     * }
     */
    public static MemorySegment av_strndup(MemorySegment s, long len) {
        var mh$ = av_strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_strndup", s, len);
            }
            return (MemorySegment)mh$.invokeExact(s, len);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_memdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static FunctionDescriptor av_memdup$descriptor() {
        return av_memdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MethodHandle av_memdup$handle() {
        return av_memdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup$address() {
        return av_memdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_memdup(const void *p, size_t size)
     * }
     */
    public static MemorySegment av_memdup(MemorySegment p, long size) {
        var mh$ = av_memdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memdup", p, size);
            }
            return (MemorySegment)mh$.invokeExact(p, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_memcpy_backptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_memcpy_backptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static FunctionDescriptor av_memcpy_backptr$descriptor() {
        return av_memcpy_backptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MethodHandle av_memcpy_backptr$handle() {
        return av_memcpy_backptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static MemorySegment av_memcpy_backptr$address() {
        return av_memcpy_backptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_memcpy_backptr(uint8_t *dst, int back, int cnt)
     * }
     */
    public static void av_memcpy_backptr(MemorySegment dst, int back, int cnt) {
        var mh$ = av_memcpy_backptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_memcpy_backptr", dst, back, cnt);
            }
            mh$.invokeExact(dst, back, cnt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add$descriptor() {
        return av_dynarray_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add$handle() {
        return av_dynarray_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add$address() {
        return av_dynarray_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dynarray_add(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static void av_dynarray_add(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add", tab_ptr, nb_ptr, elem);
            }
            mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray_add_nofree {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray_add_nofree");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static FunctionDescriptor av_dynarray_add_nofree$descriptor() {
        return av_dynarray_add_nofree.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MethodHandle av_dynarray_add_nofree$handle() {
        return av_dynarray_add_nofree.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static MemorySegment av_dynarray_add_nofree$address() {
        return av_dynarray_add_nofree.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_dynarray_add_nofree(void *tab_ptr, int *nb_ptr, void *elem)
     * }
     */
    public static int av_dynarray_add_nofree(MemorySegment tab_ptr, MemorySegment nb_ptr, MemorySegment elem) {
        var mh$ = av_dynarray_add_nofree.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray_add_nofree", tab_ptr, nb_ptr, elem);
            }
            return (int)mh$.invokeExact(tab_ptr, nb_ptr, elem);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dynarray2_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dynarray2_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static FunctionDescriptor av_dynarray2_add$descriptor() {
        return av_dynarray2_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MethodHandle av_dynarray2_add$handle() {
        return av_dynarray2_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add$address() {
        return av_dynarray2_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_dynarray2_add(void **tab_ptr, int *nb_ptr, size_t elem_size, const uint8_t *elem_data)
     * }
     */
    public static MemorySegment av_dynarray2_add(MemorySegment tab_ptr, MemorySegment nb_ptr, long elem_size, MemorySegment elem_data) {
        var mh$ = av_dynarray2_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dynarray2_add", tab_ptr, nb_ptr, elem_size, elem_data);
            }
            return (MemorySegment)mh$.invokeExact(tab_ptr, nb_ptr, elem_size, elem_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_size_mult {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_size_mult");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static FunctionDescriptor av_size_mult$descriptor() {
        return av_size_mult.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MethodHandle av_size_mult$handle() {
        return av_size_mult.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static MemorySegment av_size_mult$address() {
        return av_size_mult.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_size_mult(size_t a, size_t b, size_t *r)
     * }
     */
    public static int av_size_mult(long a, long b, MemorySegment r) {
        var mh$ = av_size_mult.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_size_mult", a, b, r);
            }
            return (int)mh$.invokeExact(a, b, r);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_max_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_max_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static FunctionDescriptor av_max_alloc$descriptor() {
        return av_max_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MethodHandle av_max_alloc$handle() {
        return av_max_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static MemorySegment av_max_alloc$address() {
        return av_max_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_max_alloc(size_t max)
     * }
     */
    public static void av_max_alloc(long max) {
        var mh$ = av_max_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_max_alloc", max);
            }
            mh$.invokeExact(max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2$descriptor() {
        return av_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static MethodHandle av_log2$handle() {
        return av_log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static MemorySegment av_log2$address() {
        return av_log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log2(unsigned int v)
     * }
     */
    public static int av_log2(int v) {
        var mh$ = av_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log2_16bit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log2_16bit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static FunctionDescriptor av_log2_16bit$descriptor() {
        return av_log2_16bit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static MethodHandle av_log2_16bit$handle() {
        return av_log2_16bit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static MemorySegment av_log2_16bit$address() {
        return av_log2_16bit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log2_16bit(unsigned int v)
     * }
     */
    public static int av_log2_16bit(int v) {
        var mh$ = av_log2_16bit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log2_16bit", v);
            }
            return (int)mh$.invokeExact(v);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_reduce {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_reduce");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static FunctionDescriptor av_reduce$descriptor() {
        return av_reduce.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static MethodHandle av_reduce$handle() {
        return av_reduce.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static MemorySegment av_reduce$address() {
        return av_reduce.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_reduce(int *dst_num, int *dst_den, int64_t num, int64_t den, int64_t max)
     * }
     */
    public static int av_reduce(MemorySegment dst_num, MemorySegment dst_den, long num, long den, long max) {
        var mh$ = av_reduce.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_reduce", dst_num, dst_den, num, den, max);
            }
            return (int)mh$.invokeExact(dst_num, dst_den, num, den, max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_mul_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_mul_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_mul_q$descriptor() {
        return av_mul_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_mul_q$handle() {
        return av_mul_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_mul_q$address() {
        return av_mul_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_mul_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_mul_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_mul_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_mul_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_div_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_div_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_div_q$descriptor() {
        return av_div_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_div_q$handle() {
        return av_div_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_div_q$address() {
        return av_div_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_div_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_div_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_div_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_div_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_add_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_add_q$descriptor() {
        return av_add_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_add_q$handle() {
        return av_add_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_add_q$address() {
        return av_add_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_add_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_add_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_add_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sub_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_sub_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static FunctionDescriptor av_sub_q$descriptor() {
        return av_sub_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MethodHandle av_sub_q$handle() {
        return av_sub_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_sub_q$address() {
        return av_sub_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_sub_q(AVRational b, AVRational c)
     * }
     */
    public static MemorySegment av_sub_q(SegmentAllocator allocator, MemorySegment b, MemorySegment c) {
        var mh$ = av_sub_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sub_q", allocator, b, c);
            }
            return (MemorySegment)mh$.invokeExact(allocator, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_d2q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_DOUBLE,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_d2q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static FunctionDescriptor av_d2q$descriptor() {
        return av_d2q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MethodHandle av_d2q$handle() {
        return av_d2q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MemorySegment av_d2q$address() {
        return av_d2q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_d2q(double d, int max)
     * }
     */
    public static MemorySegment av_d2q(SegmentAllocator allocator, double d, int max) {
        var mh$ = av_d2q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_d2q", allocator, d, max);
            }
            return (MemorySegment)mh$.invokeExact(allocator, d, max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_nearer_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_nearer_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static FunctionDescriptor av_nearer_q$descriptor() {
        return av_nearer_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static MethodHandle av_nearer_q$handle() {
        return av_nearer_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static MemorySegment av_nearer_q$address() {
        return av_nearer_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_nearer_q(AVRational q, AVRational q1, AVRational q2)
     * }
     */
    public static int av_nearer_q(MemorySegment q, MemorySegment q1, MemorySegment q2) {
        var mh$ = av_nearer_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_nearer_q", q, q1, q2);
            }
            return (int)mh$.invokeExact(q, q1, q2);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_nearest_q_idx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_nearest_q_idx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static FunctionDescriptor av_find_nearest_q_idx$descriptor() {
        return av_find_nearest_q_idx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static MethodHandle av_find_nearest_q_idx$handle() {
        return av_find_nearest_q_idx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static MemorySegment av_find_nearest_q_idx$address() {
        return av_find_nearest_q_idx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_nearest_q_idx(AVRational q, const AVRational *q_list)
     * }
     */
    public static int av_find_nearest_q_idx(MemorySegment q, MemorySegment q_list) {
        var mh$ = av_find_nearest_q_idx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_nearest_q_idx", q, q_list);
            }
            return (int)mh$.invokeExact(q, q_list);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_q2intfloat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_q2intfloat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static FunctionDescriptor av_q2intfloat$descriptor() {
        return av_q2intfloat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static MethodHandle av_q2intfloat$handle() {
        return av_q2intfloat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static MemorySegment av_q2intfloat$address() {
        return av_q2intfloat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint32_t av_q2intfloat(AVRational q)
     * }
     */
    public static int av_q2intfloat(MemorySegment q) {
        var mh$ = av_q2intfloat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_q2intfloat", q);
            }
            return (int)mh$.invokeExact(q);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_gcd_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            AVRational.layout(),
            AVRational.layout(),
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_gcd_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static FunctionDescriptor av_gcd_q$descriptor() {
        return av_gcd_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MethodHandle av_gcd_q$handle() {
        return av_gcd_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MemorySegment av_gcd_q$address() {
        return av_gcd_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_gcd_q(AVRational a, AVRational b, int max_den, AVRational def)
     * }
     */
    public static MemorySegment av_gcd_q(SegmentAllocator allocator, MemorySegment a, MemorySegment b, int max_den, MemorySegment def) {
        var mh$ = av_gcd_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd_q", allocator, a, b, max_den, def);
            }
            return (MemorySegment)mh$.invokeExact(allocator, a, b, max_den, def);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_ROUND_ZERO = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_ZERO = 0
     * }
     */
    public static int AV_ROUND_ZERO() {
        return AV_ROUND_ZERO;
    }
    private static final int AV_ROUND_INF = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_INF = 1
     * }
     */
    public static int AV_ROUND_INF() {
        return AV_ROUND_INF;
    }
    private static final int AV_ROUND_DOWN = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_DOWN = 2
     * }
     */
    public static int AV_ROUND_DOWN() {
        return AV_ROUND_DOWN;
    }
    private static final int AV_ROUND_UP = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_UP = 3
     * }
     */
    public static int AV_ROUND_UP() {
        return AV_ROUND_UP;
    }
    private static final int AV_ROUND_NEAR_INF = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_NEAR_INF = 5
     * }
     */
    public static int AV_ROUND_NEAR_INF() {
        return AV_ROUND_NEAR_INF;
    }
    private static final int AV_ROUND_PASS_MINMAX = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum AVRounding.AV_ROUND_PASS_MINMAX = 8192
     * }
     */
    public static int AV_ROUND_PASS_MINMAX() {
        return AV_ROUND_PASS_MINMAX;
    }

    private static class av_gcd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_gcd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static FunctionDescriptor av_gcd$descriptor() {
        return av_gcd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static MethodHandle av_gcd$handle() {
        return av_gcd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static MemorySegment av_gcd$address() {
        return av_gcd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_gcd(int64_t a, int64_t b)
     * }
     */
    public static long av_gcd(long a, long b) {
        var mh$ = av_gcd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_gcd", a, b);
            }
            return (long)mh$.invokeExact(a, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static FunctionDescriptor av_rescale$descriptor() {
        return av_rescale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static MethodHandle av_rescale$handle() {
        return av_rescale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static MemorySegment av_rescale$address() {
        return av_rescale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale(int64_t a, int64_t b, int64_t c)
     * }
     */
    public static long av_rescale(long a, long b, long c) {
        var mh$ = av_rescale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale", a, b, c);
            }
            return (long)mh$.invokeExact(a, b, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_rnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_rnd$descriptor() {
        return av_rescale_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_rnd$handle() {
        return av_rescale_rnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static MemorySegment av_rescale_rnd$address() {
        return av_rescale_rnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_rnd(int64_t a, int64_t b, int64_t c, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_rnd(long a, long b, long c, int rnd) {
        var mh$ = av_rescale_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_rnd", a, b, c, rnd);
            }
            return (long)mh$.invokeExact(a, b, c, rnd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            AVRational.layout(),
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_q");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static FunctionDescriptor av_rescale_q$descriptor() {
        return av_rescale_q.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static MethodHandle av_rescale_q$handle() {
        return av_rescale_q.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static MemorySegment av_rescale_q$address() {
        return av_rescale_q.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q(int64_t a, AVRational bq, AVRational cq)
     * }
     */
    public static long av_rescale_q(long a, MemorySegment bq, MemorySegment cq) {
        var mh$ = av_rescale_q.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q", a, bq, cq);
            }
            return (long)mh$.invokeExact(a, bq, cq);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_q_rnd {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            AVRational.layout(),
            AVRational.layout(),
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_q_rnd");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static FunctionDescriptor av_rescale_q_rnd$descriptor() {
        return av_rescale_q_rnd.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static MethodHandle av_rescale_q_rnd$handle() {
        return av_rescale_q_rnd.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static MemorySegment av_rescale_q_rnd$address() {
        return av_rescale_q_rnd.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_q_rnd(int64_t a, AVRational bq, AVRational cq, enum AVRounding rnd)
     * }
     */
    public static long av_rescale_q_rnd(long a, MemorySegment bq, MemorySegment cq, int rnd) {
        var mh$ = av_rescale_q_rnd.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_q_rnd", a, bq, cq, rnd);
            }
            return (long)mh$.invokeExact(a, bq, cq, rnd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_ts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG_LONG,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_compare_ts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static FunctionDescriptor av_compare_ts$descriptor() {
        return av_compare_ts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static MethodHandle av_compare_ts$handle() {
        return av_compare_ts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static MemorySegment av_compare_ts$address() {
        return av_compare_ts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_compare_ts(int64_t ts_a, AVRational tb_a, int64_t ts_b, AVRational tb_b)
     * }
     */
    public static int av_compare_ts(long ts_a, MemorySegment tb_a, long ts_b, MemorySegment tb_b) {
        var mh$ = av_compare_ts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_ts", ts_a, tb_a, ts_b, tb_b);
            }
            return (int)mh$.invokeExact(ts_a, tb_a, ts_b, tb_b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_compare_mod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_compare_mod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static FunctionDescriptor av_compare_mod$descriptor() {
        return av_compare_mod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static MethodHandle av_compare_mod$handle() {
        return av_compare_mod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static MemorySegment av_compare_mod$address() {
        return av_compare_mod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_compare_mod(uint64_t a, uint64_t b, uint64_t mod)
     * }
     */
    public static long av_compare_mod(long a, long b, long mod) {
        var mh$ = av_compare_mod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_compare_mod", a, b, mod);
            }
            return (long)mh$.invokeExact(a, b, mod);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_rescale_delta {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG_LONG,
            AVRational.layout(),
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_rescale_delta");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static FunctionDescriptor av_rescale_delta$descriptor() {
        return av_rescale_delta.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static MethodHandle av_rescale_delta$handle() {
        return av_rescale_delta.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static MemorySegment av_rescale_delta$address() {
        return av_rescale_delta.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_rescale_delta(AVRational in_tb, int64_t in_ts, AVRational fs_tb, int duration, int64_t *last, AVRational out_tb)
     * }
     */
    public static long av_rescale_delta(MemorySegment in_tb, long in_ts, MemorySegment fs_tb, int duration, MemorySegment last, MemorySegment out_tb) {
        var mh$ = av_rescale_delta.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_rescale_delta", in_tb, in_ts, fs_tb, duration, last, out_tb);
            }
            return (long)mh$.invokeExact(in_tb, in_ts, fs_tb, duration, last, out_tb);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_stable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG_LONG,
            AVRational.layout(),
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_add_stable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static FunctionDescriptor av_add_stable$descriptor() {
        return av_add_stable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static MethodHandle av_add_stable$handle() {
        return av_add_stable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static MemorySegment av_add_stable$address() {
        return av_add_stable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_add_stable(AVRational ts_tb, int64_t ts, AVRational inc_tb, int64_t inc)
     * }
     */
    public static long av_add_stable(MemorySegment ts_tb, long ts, MemorySegment inc_tb, long inc) {
        var mh$ = av_add_stable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_stable", ts_tb, ts, inc_tb, inc);
            }
            return (long)mh$.invokeExact(ts_tb, ts, inc_tb, inc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_bessel_i0 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_bessel_i0");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static FunctionDescriptor av_bessel_i0$descriptor() {
        return av_bessel_i0.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static MethodHandle av_bessel_i0$handle() {
        return av_bessel_i0.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static MemorySegment av_bessel_i0$address() {
        return av_bessel_i0.ADDR;
    }

    /**
     * {@snippet lang=c :
     * double av_bessel_i0(double x)
     * }
     */
    public static double av_bessel_i0(double x) {
        var mh$ = av_bessel_i0.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_bessel_i0", x);
            }
            return (double)mh$.invokeExact(x);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __builtin_va_list __gnuc_va_list
     * }
     */
    public static final AddressLayout __gnuc_va_list = FFmpeg.C_POINTER;
    private static final int AV_CLASS_CATEGORY_NA = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NA = 0
     * }
     */
    public static int AV_CLASS_CATEGORY_NA() {
        return AV_CLASS_CATEGORY_NA;
    }
    private static final int AV_CLASS_CATEGORY_INPUT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_INPUT = 1
     * }
     */
    public static int AV_CLASS_CATEGORY_INPUT() {
        return AV_CLASS_CATEGORY_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_OUTPUT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_OUTPUT = 2
     * }
     */
    public static int AV_CLASS_CATEGORY_OUTPUT() {
        return AV_CLASS_CATEGORY_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_MUXER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_MUXER = 3
     * }
     */
    public static int AV_CLASS_CATEGORY_MUXER() {
        return AV_CLASS_CATEGORY_MUXER;
    }
    private static final int AV_CLASS_CATEGORY_DEMUXER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEMUXER = 4
     * }
     */
    public static int AV_CLASS_CATEGORY_DEMUXER() {
        return AV_CLASS_CATEGORY_DEMUXER;
    }
    private static final int AV_CLASS_CATEGORY_ENCODER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_ENCODER = 5
     * }
     */
    public static int AV_CLASS_CATEGORY_ENCODER() {
        return AV_CLASS_CATEGORY_ENCODER;
    }
    private static final int AV_CLASS_CATEGORY_DECODER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DECODER = 6
     * }
     */
    public static int AV_CLASS_CATEGORY_DECODER() {
        return AV_CLASS_CATEGORY_DECODER;
    }
    private static final int AV_CLASS_CATEGORY_FILTER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_FILTER = 7
     * }
     */
    public static int AV_CLASS_CATEGORY_FILTER() {
        return AV_CLASS_CATEGORY_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_BITSTREAM_FILTER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_BITSTREAM_FILTER = 8
     * }
     */
    public static int AV_CLASS_CATEGORY_BITSTREAM_FILTER() {
        return AV_CLASS_CATEGORY_BITSTREAM_FILTER;
    }
    private static final int AV_CLASS_CATEGORY_SWSCALER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWSCALER = 9
     * }
     */
    public static int AV_CLASS_CATEGORY_SWSCALER() {
        return AV_CLASS_CATEGORY_SWSCALER;
    }
    private static final int AV_CLASS_CATEGORY_SWRESAMPLER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_SWRESAMPLER = 10
     * }
     */
    public static int AV_CLASS_CATEGORY_SWRESAMPLER() {
        return AV_CLASS_CATEGORY_SWRESAMPLER;
    }
    private static final int AV_CLASS_CATEGORY_HWDEVICE = (int)11L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_HWDEVICE = 11
     * }
     */
    public static int AV_CLASS_CATEGORY_HWDEVICE() {
        return AV_CLASS_CATEGORY_HWDEVICE;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = (int)40L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT = 40
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = (int)41L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT = 41
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_VIDEO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = (int)42L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT = 42
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = (int)43L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT = 43
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_AUDIO_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_OUTPUT = (int)44L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_OUTPUT = 44
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_OUTPUT() {
        return AV_CLASS_CATEGORY_DEVICE_OUTPUT;
    }
    private static final int AV_CLASS_CATEGORY_DEVICE_INPUT = (int)45L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_DEVICE_INPUT = 45
     * }
     */
    public static int AV_CLASS_CATEGORY_DEVICE_INPUT() {
        return AV_CLASS_CATEGORY_DEVICE_INPUT;
    }
    private static final int AV_CLASS_CATEGORY_NB = (int)46L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CLASS_CATEGORY_NB = 46
     * }
     */
    public static int AV_CLASS_CATEGORY_NB() {
        return AV_CLASS_CATEGORY_NB;
    }
    private static final int AV_CLASS_STATE_INITIALIZED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVClassStateFlags.AV_CLASS_STATE_INITIALIZED = 1
     * }
     */
    public static int AV_CLASS_STATE_INITIALIZED() {
        return AV_CLASS_STATE_INITIALIZED;
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log(void *avcl, int level, const char *fmt, ...)
     * }
     */
    public static class av_log {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                FFmpeg.C_POINTER,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log(void *avcl, int level, const char *fmt, ...)
         * }
         */
        public static av_log makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int level, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log", avcl, level, fmt, x3);
                }
                 spreader.invokeExact(avcl, level, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
     * }
     */
    public static class av_log_once {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.ofVoid(
                FFmpeg.C_POINTER,
                FFmpeg.C_INT,
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_once");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private av_log_once(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * void av_log_once(void *avcl, int initial_level, int subsequent_level, int *state, const char *fmt, ...)
         * }
         */
        public static av_log_once makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new av_log_once(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public void apply(MemorySegment avcl, int initial_level, int subsequent_level, MemorySegment state, MemorySegment fmt, Object... x5) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("av_log_once", avcl, initial_level, subsequent_level, state, fmt, x5);
                }
                 spreader.invokeExact(avcl, initial_level, subsequent_level, state, fmt, x5);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class av_vlog {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_vlog");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_vlog$descriptor() {
        return av_vlog.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_vlog$handle() {
        return av_vlog.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MemorySegment av_vlog$address() {
        return av_vlog.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_vlog(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_vlog(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_vlog.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_vlog", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_get_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static FunctionDescriptor av_log_get_level$descriptor() {
        return av_log_get_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static MethodHandle av_log_get_level$handle() {
        return av_log_get_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static MemorySegment av_log_get_level$address() {
        return av_log_get_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_get_level()
     * }
     */
    public static int av_log_get_level() {
        var mh$ = av_log_get_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_level");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_level {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_set_level");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static FunctionDescriptor av_log_set_level$descriptor() {
        return av_log_set_level.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MethodHandle av_log_set_level$handle() {
        return av_log_set_level.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static MemorySegment av_log_set_level$address() {
        return av_log_set_level.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_level(int level)
     * }
     */
    public static void av_log_set_level(int level) {
        var mh$ = av_log_set_level.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_level", level);
            }
            mh$.invokeExact(level);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_set_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static FunctionDescriptor av_log_set_callback$descriptor() {
        return av_log_set_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static MethodHandle av_log_set_callback$handle() {
        return av_log_set_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static MemorySegment av_log_set_callback$address() {
        return av_log_set_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_callback(void (*callback)(void *, int, const char *, va_list))
     * }
     */
    public static void av_log_set_callback(MemorySegment callback) {
        var mh$ = av_log_set_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_callback", callback);
            }
            mh$.invokeExact(callback);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_default_callback {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_default_callback");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static FunctionDescriptor av_log_default_callback$descriptor() {
        return av_log_default_callback.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MethodHandle av_log_default_callback$handle() {
        return av_log_default_callback.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static MemorySegment av_log_default_callback$address() {
        return av_log_default_callback.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_default_callback(void *avcl, int level, const char *fmt, va_list vl)
     * }
     */
    public static void av_log_default_callback(MemorySegment avcl, int level, MemorySegment fmt, MemorySegment vl) {
        var mh$ = av_log_default_callback.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_default_callback", avcl, level, fmt, vl);
            }
            mh$.invokeExact(avcl, level, fmt, vl);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_item_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_default_item_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static FunctionDescriptor av_default_item_name$descriptor() {
        return av_default_item_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MethodHandle av_default_item_name$handle() {
        return av_default_item_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MemorySegment av_default_item_name$address() {
        return av_default_item_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_default_item_name(void *ctx)
     * }
     */
    public static MemorySegment av_default_item_name(MemorySegment ctx) {
        var mh$ = av_default_item_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_item_name", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_default_get_category {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_default_get_category");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static FunctionDescriptor av_default_get_category$descriptor() {
        return av_default_get_category.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static MethodHandle av_default_get_category$handle() {
        return av_default_get_category.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static MemorySegment av_default_get_category$address() {
        return av_default_get_category.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVClassCategory av_default_get_category(void *ptr)
     * }
     */
    public static int av_default_get_category(MemorySegment ptr) {
        var mh$ = av_default_get_category.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_default_get_category", ptr);
            }
            return (int)mh$.invokeExact(ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_format_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line$descriptor() {
        return av_log_format_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line$handle() {
        return av_log_format_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MemorySegment av_log_format_line$address() {
        return av_log_format_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_format_line(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static void av_log_format_line(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_format_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_format_line2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static FunctionDescriptor av_log_format_line2$descriptor() {
        return av_log_format_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MethodHandle av_log_format_line2$handle() {
        return av_log_format_line2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static MemorySegment av_log_format_line2$address() {
        return av_log_format_line2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_format_line2(void *ptr, int level, const char *fmt, va_list vl, char *line, int line_size, int *print_prefix)
     * }
     */
    public static int av_log_format_line2(MemorySegment ptr, int level, MemorySegment fmt, MemorySegment vl, MemorySegment line, int line_size, MemorySegment print_prefix) {
        var mh$ = av_log_format_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_format_line2", ptr, level, fmt, vl, line, line_size, print_prefix);
            }
            return (int)mh$.invokeExact(ptr, level, fmt, vl, line, line_size, print_prefix);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_set_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_set_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static FunctionDescriptor av_log_set_flags$descriptor() {
        return av_log_set_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static MethodHandle av_log_set_flags$handle() {
        return av_log_set_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static MemorySegment av_log_set_flags$address() {
        return av_log_set_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_log_set_flags(int arg)
     * }
     */
    public static void av_log_set_flags(int arg) {
        var mh$ = av_log_set_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_set_flags", arg);
            }
            mh$.invokeExact(arg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_log_get_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_log_get_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static FunctionDescriptor av_log_get_flags$descriptor() {
        return av_log_get_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static MethodHandle av_log_get_flags$handle() {
        return av_log_get_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static MemorySegment av_log_get_flags$address() {
        return av_log_get_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_log_get_flags()
     * }
     */
    public static int av_log_get_flags() {
        var mh$ = av_log_get_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_log_get_flags");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PIX_FMT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NONE = -1
     * }
     */
    public static int AV_PIX_FMT_NONE() {
        return AV_PIX_FMT_NONE;
    }
    private static final int AV_PIX_FMT_YUV420P = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P = 0
     * }
     */
    public static int AV_PIX_FMT_YUV420P() {
        return AV_PIX_FMT_YUV420P;
    }
    private static final int AV_PIX_FMT_YUYV422 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUYV422 = 1
     * }
     */
    public static int AV_PIX_FMT_YUYV422() {
        return AV_PIX_FMT_YUYV422;
    }
    private static final int AV_PIX_FMT_RGB24 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB24 = 2
     * }
     */
    public static int AV_PIX_FMT_RGB24() {
        return AV_PIX_FMT_RGB24;
    }
    private static final int AV_PIX_FMT_BGR24 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR24 = 3
     * }
     */
    public static int AV_PIX_FMT_BGR24() {
        return AV_PIX_FMT_BGR24;
    }
    private static final int AV_PIX_FMT_YUV422P = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P = 4
     * }
     */
    public static int AV_PIX_FMT_YUV422P() {
        return AV_PIX_FMT_YUV422P;
    }
    private static final int AV_PIX_FMT_YUV444P = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P = 5
     * }
     */
    public static int AV_PIX_FMT_YUV444P() {
        return AV_PIX_FMT_YUV444P;
    }
    private static final int AV_PIX_FMT_YUV410P = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV410P = 6
     * }
     */
    public static int AV_PIX_FMT_YUV410P() {
        return AV_PIX_FMT_YUV410P;
    }
    private static final int AV_PIX_FMT_YUV411P = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV411P = 7
     * }
     */
    public static int AV_PIX_FMT_YUV411P() {
        return AV_PIX_FMT_YUV411P;
    }
    private static final int AV_PIX_FMT_GRAY8 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8 = 8
     * }
     */
    public static int AV_PIX_FMT_GRAY8() {
        return AV_PIX_FMT_GRAY8;
    }
    private static final int AV_PIX_FMT_MONOWHITE = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOWHITE = 9
     * }
     */
    public static int AV_PIX_FMT_MONOWHITE() {
        return AV_PIX_FMT_MONOWHITE;
    }
    private static final int AV_PIX_FMT_MONOBLACK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MONOBLACK = 10
     * }
     */
    public static int AV_PIX_FMT_MONOBLACK() {
        return AV_PIX_FMT_MONOBLACK;
    }
    private static final int AV_PIX_FMT_PAL8 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_PAL8 = 11
     * }
     */
    public static int AV_PIX_FMT_PAL8() {
        return AV_PIX_FMT_PAL8;
    }
    private static final int AV_PIX_FMT_YUVJ420P = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ420P = 12
     * }
     */
    public static int AV_PIX_FMT_YUVJ420P() {
        return AV_PIX_FMT_YUVJ420P;
    }
    private static final int AV_PIX_FMT_YUVJ422P = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ422P = 13
     * }
     */
    public static int AV_PIX_FMT_YUVJ422P() {
        return AV_PIX_FMT_YUVJ422P;
    }
    private static final int AV_PIX_FMT_YUVJ444P = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ444P = 14
     * }
     */
    public static int AV_PIX_FMT_YUVJ444P() {
        return AV_PIX_FMT_YUVJ444P;
    }
    private static final int AV_PIX_FMT_UYVY422 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYVY422 = 15
     * }
     */
    public static int AV_PIX_FMT_UYVY422() {
        return AV_PIX_FMT_UYVY422;
    }
    private static final int AV_PIX_FMT_UYYVYY411 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_UYYVYY411 = 16
     * }
     */
    public static int AV_PIX_FMT_UYYVYY411() {
        return AV_PIX_FMT_UYYVYY411;
    }
    private static final int AV_PIX_FMT_BGR8 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR8 = 17
     * }
     */
    public static int AV_PIX_FMT_BGR8() {
        return AV_PIX_FMT_BGR8;
    }
    private static final int AV_PIX_FMT_BGR4 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4 = 18
     * }
     */
    public static int AV_PIX_FMT_BGR4() {
        return AV_PIX_FMT_BGR4;
    }
    private static final int AV_PIX_FMT_BGR4_BYTE = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR4_BYTE = 19
     * }
     */
    public static int AV_PIX_FMT_BGR4_BYTE() {
        return AV_PIX_FMT_BGR4_BYTE;
    }
    private static final int AV_PIX_FMT_RGB8 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB8 = 20
     * }
     */
    public static int AV_PIX_FMT_RGB8() {
        return AV_PIX_FMT_RGB8;
    }
    private static final int AV_PIX_FMT_RGB4 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4 = 21
     * }
     */
    public static int AV_PIX_FMT_RGB4() {
        return AV_PIX_FMT_RGB4;
    }
    private static final int AV_PIX_FMT_RGB4_BYTE = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB4_BYTE = 22
     * }
     */
    public static int AV_PIX_FMT_RGB4_BYTE() {
        return AV_PIX_FMT_RGB4_BYTE;
    }
    private static final int AV_PIX_FMT_NV12 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV12 = 23
     * }
     */
    public static int AV_PIX_FMT_NV12() {
        return AV_PIX_FMT_NV12;
    }
    private static final int AV_PIX_FMT_NV21 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV21 = 24
     * }
     */
    public static int AV_PIX_FMT_NV21() {
        return AV_PIX_FMT_NV21;
    }
    private static final int AV_PIX_FMT_ARGB = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ARGB = 25
     * }
     */
    public static int AV_PIX_FMT_ARGB() {
        return AV_PIX_FMT_ARGB;
    }
    private static final int AV_PIX_FMT_RGBA = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA = 26
     * }
     */
    public static int AV_PIX_FMT_RGBA() {
        return AV_PIX_FMT_RGBA;
    }
    private static final int AV_PIX_FMT_ABGR = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_ABGR = 27
     * }
     */
    public static int AV_PIX_FMT_ABGR() {
        return AV_PIX_FMT_ABGR;
    }
    private static final int AV_PIX_FMT_BGRA = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA = 28
     * }
     */
    public static int AV_PIX_FMT_BGRA() {
        return AV_PIX_FMT_BGRA;
    }
    private static final int AV_PIX_FMT_GRAY16BE = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16BE = 29
     * }
     */
    public static int AV_PIX_FMT_GRAY16BE() {
        return AV_PIX_FMT_GRAY16BE;
    }
    private static final int AV_PIX_FMT_GRAY16LE = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY16LE = 30
     * }
     */
    public static int AV_PIX_FMT_GRAY16LE() {
        return AV_PIX_FMT_GRAY16LE;
    }
    private static final int AV_PIX_FMT_YUV440P = (int)31L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV440P = 31
     * }
     */
    public static int AV_PIX_FMT_YUV440P() {
        return AV_PIX_FMT_YUV440P;
    }
    private static final int AV_PIX_FMT_YUVJ440P = (int)32L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVJ440P = 32
     * }
     */
    public static int AV_PIX_FMT_YUVJ440P() {
        return AV_PIX_FMT_YUVJ440P;
    }
    private static final int AV_PIX_FMT_YUVA420P = (int)33L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P = 33
     * }
     */
    public static int AV_PIX_FMT_YUVA420P() {
        return AV_PIX_FMT_YUVA420P;
    }
    private static final int AV_PIX_FMT_RGB48BE = (int)34L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48BE = 34
     * }
     */
    public static int AV_PIX_FMT_RGB48BE() {
        return AV_PIX_FMT_RGB48BE;
    }
    private static final int AV_PIX_FMT_RGB48LE = (int)35L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB48LE = 35
     * }
     */
    public static int AV_PIX_FMT_RGB48LE() {
        return AV_PIX_FMT_RGB48LE;
    }
    private static final int AV_PIX_FMT_RGB565BE = (int)36L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565BE = 36
     * }
     */
    public static int AV_PIX_FMT_RGB565BE() {
        return AV_PIX_FMT_RGB565BE;
    }
    private static final int AV_PIX_FMT_RGB565LE = (int)37L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB565LE = 37
     * }
     */
    public static int AV_PIX_FMT_RGB565LE() {
        return AV_PIX_FMT_RGB565LE;
    }
    private static final int AV_PIX_FMT_RGB555BE = (int)38L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555BE = 38
     * }
     */
    public static int AV_PIX_FMT_RGB555BE() {
        return AV_PIX_FMT_RGB555BE;
    }
    private static final int AV_PIX_FMT_RGB555LE = (int)39L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB555LE = 39
     * }
     */
    public static int AV_PIX_FMT_RGB555LE() {
        return AV_PIX_FMT_RGB555LE;
    }
    private static final int AV_PIX_FMT_BGR565BE = (int)40L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565BE = 40
     * }
     */
    public static int AV_PIX_FMT_BGR565BE() {
        return AV_PIX_FMT_BGR565BE;
    }
    private static final int AV_PIX_FMT_BGR565LE = (int)41L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR565LE = 41
     * }
     */
    public static int AV_PIX_FMT_BGR565LE() {
        return AV_PIX_FMT_BGR565LE;
    }
    private static final int AV_PIX_FMT_BGR555BE = (int)42L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555BE = 42
     * }
     */
    public static int AV_PIX_FMT_BGR555BE() {
        return AV_PIX_FMT_BGR555BE;
    }
    private static final int AV_PIX_FMT_BGR555LE = (int)43L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR555LE = 43
     * }
     */
    public static int AV_PIX_FMT_BGR555LE() {
        return AV_PIX_FMT_BGR555LE;
    }
    private static final int AV_PIX_FMT_VAAPI = (int)44L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VAAPI = 44
     * }
     */
    public static int AV_PIX_FMT_VAAPI() {
        return AV_PIX_FMT_VAAPI;
    }
    private static final int AV_PIX_FMT_YUV420P16LE = (int)45L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16LE = 45
     * }
     */
    public static int AV_PIX_FMT_YUV420P16LE() {
        return AV_PIX_FMT_YUV420P16LE;
    }
    private static final int AV_PIX_FMT_YUV420P16BE = (int)46L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P16BE = 46
     * }
     */
    public static int AV_PIX_FMT_YUV420P16BE() {
        return AV_PIX_FMT_YUV420P16BE;
    }
    private static final int AV_PIX_FMT_YUV422P16LE = (int)47L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16LE = 47
     * }
     */
    public static int AV_PIX_FMT_YUV422P16LE() {
        return AV_PIX_FMT_YUV422P16LE;
    }
    private static final int AV_PIX_FMT_YUV422P16BE = (int)48L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P16BE = 48
     * }
     */
    public static int AV_PIX_FMT_YUV422P16BE() {
        return AV_PIX_FMT_YUV422P16BE;
    }
    private static final int AV_PIX_FMT_YUV444P16LE = (int)49L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16LE = 49
     * }
     */
    public static int AV_PIX_FMT_YUV444P16LE() {
        return AV_PIX_FMT_YUV444P16LE;
    }
    private static final int AV_PIX_FMT_YUV444P16BE = (int)50L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P16BE = 50
     * }
     */
    public static int AV_PIX_FMT_YUV444P16BE() {
        return AV_PIX_FMT_YUV444P16BE;
    }
    private static final int AV_PIX_FMT_DXVA2_VLD = (int)51L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_DXVA2_VLD = 51
     * }
     */
    public static int AV_PIX_FMT_DXVA2_VLD() {
        return AV_PIX_FMT_DXVA2_VLD;
    }
    private static final int AV_PIX_FMT_RGB444LE = (int)52L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444LE = 52
     * }
     */
    public static int AV_PIX_FMT_RGB444LE() {
        return AV_PIX_FMT_RGB444LE;
    }
    private static final int AV_PIX_FMT_RGB444BE = (int)53L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB444BE = 53
     * }
     */
    public static int AV_PIX_FMT_RGB444BE() {
        return AV_PIX_FMT_RGB444BE;
    }
    private static final int AV_PIX_FMT_BGR444LE = (int)54L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444LE = 54
     * }
     */
    public static int AV_PIX_FMT_BGR444LE() {
        return AV_PIX_FMT_BGR444LE;
    }
    private static final int AV_PIX_FMT_BGR444BE = (int)55L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR444BE = 55
     * }
     */
    public static int AV_PIX_FMT_BGR444BE() {
        return AV_PIX_FMT_BGR444BE;
    }
    private static final int AV_PIX_FMT_YA8 = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA8 = 56
     * }
     */
    public static int AV_PIX_FMT_YA8() {
        return AV_PIX_FMT_YA8;
    }
    private static final int AV_PIX_FMT_Y400A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_Y400A = 56
     * }
     */
    public static int AV_PIX_FMT_Y400A() {
        return AV_PIX_FMT_Y400A;
    }
    private static final int AV_PIX_FMT_GRAY8A = (int)56L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GRAY8A = 56
     * }
     */
    public static int AV_PIX_FMT_GRAY8A() {
        return AV_PIX_FMT_GRAY8A;
    }
    private static final int AV_PIX_FMT_BGR48BE = (int)57L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48BE = 57
     * }
     */
    public static int AV_PIX_FMT_BGR48BE() {
        return AV_PIX_FMT_BGR48BE;
    }
    private static final int AV_PIX_FMT_BGR48LE = (int)58L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR48LE = 58
     * }
     */
    public static int AV_PIX_FMT_BGR48LE() {
        return AV_PIX_FMT_BGR48LE;
    }
    private static final int AV_PIX_FMT_YUV420P9BE = (int)59L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9BE = 59
     * }
     */
    public static int AV_PIX_FMT_YUV420P9BE() {
        return AV_PIX_FMT_YUV420P9BE;
    }
    private static final int AV_PIX_FMT_YUV420P9LE = (int)60L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P9LE = 60
     * }
     */
    public static int AV_PIX_FMT_YUV420P9LE() {
        return AV_PIX_FMT_YUV420P9LE;
    }
    private static final int AV_PIX_FMT_YUV420P10BE = (int)61L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10BE = 61
     * }
     */
    public static int AV_PIX_FMT_YUV420P10BE() {
        return AV_PIX_FMT_YUV420P10BE;
    }
    private static final int AV_PIX_FMT_YUV420P10LE = (int)62L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P10LE = 62
     * }
     */
    public static int AV_PIX_FMT_YUV420P10LE() {
        return AV_PIX_FMT_YUV420P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P10BE = (int)63L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10BE = 63
     * }
     */
    public static int AV_PIX_FMT_YUV422P10BE() {
        return AV_PIX_FMT_YUV422P10BE;
    }
    private static final int AV_PIX_FMT_YUV422P10LE = (int)64L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P10LE = 64
     * }
     */
    public static int AV_PIX_FMT_YUV422P10LE() {
        return AV_PIX_FMT_YUV422P10LE;
    }
    private static final int AV_PIX_FMT_YUV444P9BE = (int)65L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9BE = 65
     * }
     */
    public static int AV_PIX_FMT_YUV444P9BE() {
        return AV_PIX_FMT_YUV444P9BE;
    }
    private static final int AV_PIX_FMT_YUV444P9LE = (int)66L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P9LE = 66
     * }
     */
    public static int AV_PIX_FMT_YUV444P9LE() {
        return AV_PIX_FMT_YUV444P9LE;
    }
    private static final int AV_PIX_FMT_YUV444P10BE = (int)67L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10BE = 67
     * }
     */
    public static int AV_PIX_FMT_YUV444P10BE() {
        return AV_PIX_FMT_YUV444P10BE;
    }
    private static final int AV_PIX_FMT_YUV444P10LE = (int)68L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P10LE = 68
     * }
     */
    public static int AV_PIX_FMT_YUV444P10LE() {
        return AV_PIX_FMT_YUV444P10LE;
    }
    private static final int AV_PIX_FMT_YUV422P9BE = (int)69L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9BE = 69
     * }
     */
    public static int AV_PIX_FMT_YUV422P9BE() {
        return AV_PIX_FMT_YUV422P9BE;
    }
    private static final int AV_PIX_FMT_YUV422P9LE = (int)70L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P9LE = 70
     * }
     */
    public static int AV_PIX_FMT_YUV422P9LE() {
        return AV_PIX_FMT_YUV422P9LE;
    }
    private static final int AV_PIX_FMT_GBRP = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP = 71
     * }
     */
    public static int AV_PIX_FMT_GBRP() {
        return AV_PIX_FMT_GBRP;
    }
    private static final int AV_PIX_FMT_GBR24P = (int)71L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBR24P = 71
     * }
     */
    public static int AV_PIX_FMT_GBR24P() {
        return AV_PIX_FMT_GBR24P;
    }
    private static final int AV_PIX_FMT_GBRP9BE = (int)72L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9BE = 72
     * }
     */
    public static int AV_PIX_FMT_GBRP9BE() {
        return AV_PIX_FMT_GBRP9BE;
    }
    private static final int AV_PIX_FMT_GBRP9LE = (int)73L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP9LE = 73
     * }
     */
    public static int AV_PIX_FMT_GBRP9LE() {
        return AV_PIX_FMT_GBRP9LE;
    }
    private static final int AV_PIX_FMT_GBRP10BE = (int)74L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10BE = 74
     * }
     */
    public static int AV_PIX_FMT_GBRP10BE() {
        return AV_PIX_FMT_GBRP10BE;
    }
    private static final int AV_PIX_FMT_GBRP10LE = (int)75L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP10LE = 75
     * }
     */
    public static int AV_PIX_FMT_GBRP10LE() {
        return AV_PIX_FMT_GBRP10LE;
    }
    private static final int AV_PIX_FMT_GBRP16BE = (int)76L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16BE = 76
     * }
     */
    public static int AV_PIX_FMT_GBRP16BE() {
        return AV_PIX_FMT_GBRP16BE;
    }
    private static final int AV_PIX_FMT_GBRP16LE = (int)77L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRP16LE = 77
     * }
     */
    public static int AV_PIX_FMT_GBRP16LE() {
        return AV_PIX_FMT_GBRP16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P = (int)78L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P = 78
     * }
     */
    public static int AV_PIX_FMT_YUVA422P() {
        return AV_PIX_FMT_YUVA422P;
    }
    private static final int AV_PIX_FMT_YUVA444P = (int)79L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P = 79
     * }
     */
    public static int AV_PIX_FMT_YUVA444P() {
        return AV_PIX_FMT_YUVA444P;
    }
    private static final int AV_PIX_FMT_YUVA420P9BE = (int)80L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9BE = 80
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9BE() {
        return AV_PIX_FMT_YUVA420P9BE;
    }
    private static final int AV_PIX_FMT_YUVA420P9LE = (int)81L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P9LE = 81
     * }
     */
    public static int AV_PIX_FMT_YUVA420P9LE() {
        return AV_PIX_FMT_YUVA420P9LE;
    }
    private static final int AV_PIX_FMT_YUVA422P9BE = (int)82L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9BE = 82
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9BE() {
        return AV_PIX_FMT_YUVA422P9BE;
    }
    private static final int AV_PIX_FMT_YUVA422P9LE = (int)83L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P9LE = 83
     * }
     */
    public static int AV_PIX_FMT_YUVA422P9LE() {
        return AV_PIX_FMT_YUVA422P9LE;
    }
    private static final int AV_PIX_FMT_YUVA444P9BE = (int)84L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9BE = 84
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9BE() {
        return AV_PIX_FMT_YUVA444P9BE;
    }
    private static final int AV_PIX_FMT_YUVA444P9LE = (int)85L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P9LE = 85
     * }
     */
    public static int AV_PIX_FMT_YUVA444P9LE() {
        return AV_PIX_FMT_YUVA444P9LE;
    }
    private static final int AV_PIX_FMT_YUVA420P10BE = (int)86L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10BE = 86
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10BE() {
        return AV_PIX_FMT_YUVA420P10BE;
    }
    private static final int AV_PIX_FMT_YUVA420P10LE = (int)87L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P10LE = 87
     * }
     */
    public static int AV_PIX_FMT_YUVA420P10LE() {
        return AV_PIX_FMT_YUVA420P10LE;
    }
    private static final int AV_PIX_FMT_YUVA422P10BE = (int)88L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10BE = 88
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10BE() {
        return AV_PIX_FMT_YUVA422P10BE;
    }
    private static final int AV_PIX_FMT_YUVA422P10LE = (int)89L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P10LE = 89
     * }
     */
    public static int AV_PIX_FMT_YUVA422P10LE() {
        return AV_PIX_FMT_YUVA422P10LE;
    }
    private static final int AV_PIX_FMT_YUVA444P10BE = (int)90L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10BE = 90
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10BE() {
        return AV_PIX_FMT_YUVA444P10BE;
    }
    private static final int AV_PIX_FMT_YUVA444P10LE = (int)91L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P10LE = 91
     * }
     */
    public static int AV_PIX_FMT_YUVA444P10LE() {
        return AV_PIX_FMT_YUVA444P10LE;
    }
    private static final int AV_PIX_FMT_YUVA420P16BE = (int)92L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16BE = 92
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16BE() {
        return AV_PIX_FMT_YUVA420P16BE;
    }
    private static final int AV_PIX_FMT_YUVA420P16LE = (int)93L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA420P16LE = 93
     * }
     */
    public static int AV_PIX_FMT_YUVA420P16LE() {
        return AV_PIX_FMT_YUVA420P16LE;
    }
    private static final int AV_PIX_FMT_YUVA422P16BE = (int)94L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16BE = 94
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16BE() {
        return AV_PIX_FMT_YUVA422P16BE;
    }
    private static final int AV_PIX_FMT_YUVA422P16LE = (int)95L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA422P16LE = 95
     * }
     */
    public static int AV_PIX_FMT_YUVA422P16LE() {
        return AV_PIX_FMT_YUVA422P16LE;
    }
    private static final int AV_PIX_FMT_YUVA444P16BE = (int)96L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16BE = 96
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16BE() {
        return AV_PIX_FMT_YUVA444P16BE;
    }
    private static final int AV_PIX_FMT_YUVA444P16LE = (int)97L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUVA444P16LE = 97
     * }
     */
    public static int AV_PIX_FMT_YUVA444P16LE() {
        return AV_PIX_FMT_YUVA444P16LE;
    }
    private static final int AV_PIX_FMT_VDPAU = (int)98L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_VDPAU = 98
     * }
     */
    public static int AV_PIX_FMT_VDPAU() {
        return AV_PIX_FMT_VDPAU;
    }
    private static final int AV_PIX_FMT_XYZ12LE = (int)99L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12LE = 99
     * }
     */
    public static int AV_PIX_FMT_XYZ12LE() {
        return AV_PIX_FMT_XYZ12LE;
    }
    private static final int AV_PIX_FMT_XYZ12BE = (int)100L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_XYZ12BE = 100
     * }
     */
    public static int AV_PIX_FMT_XYZ12BE() {
        return AV_PIX_FMT_XYZ12BE;
    }
    private static final int AV_PIX_FMT_NV16 = (int)101L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV16 = 101
     * }
     */
    public static int AV_PIX_FMT_NV16() {
        return AV_PIX_FMT_NV16;
    }
    private static final int AV_PIX_FMT_NV20LE = (int)102L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20LE = 102
     * }
     */
    public static int AV_PIX_FMT_NV20LE() {
        return AV_PIX_FMT_NV20LE;
    }
    private static final int AV_PIX_FMT_NV20BE = (int)103L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_NV20BE = 103
     * }
     */
    public static int AV_PIX_FMT_NV20BE() {
        return AV_PIX_FMT_NV20BE;
    }
    private static final int AV_PIX_FMT_RGBA64BE = (int)104L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64BE = 104
     * }
     */
    public static int AV_PIX_FMT_RGBA64BE() {
        return AV_PIX_FMT_RGBA64BE;
    }
    private static final int AV_PIX_FMT_RGBA64LE = (int)105L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGBA64LE = 105
     * }
     */
    public static int AV_PIX_FMT_RGBA64LE() {
        return AV_PIX_FMT_RGBA64LE;
    }
    private static final int AV_PIX_FMT_BGRA64BE = (int)106L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64BE = 106
     * }
     */
    public static int AV_PIX_FMT_BGRA64BE() {
        return AV_PIX_FMT_BGRA64BE;
    }
    private static final int AV_PIX_FMT_BGRA64LE = (int)107L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGRA64LE = 107
     * }
     */
    public static int AV_PIX_FMT_BGRA64LE() {
        return AV_PIX_FMT_BGRA64LE;
    }
    private static final int AV_PIX_FMT_YVYU422 = (int)108L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YVYU422 = 108
     * }
     */
    public static int AV_PIX_FMT_YVYU422() {
        return AV_PIX_FMT_YVYU422;
    }
    private static final int AV_PIX_FMT_YA16BE = (int)109L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16BE = 109
     * }
     */
    public static int AV_PIX_FMT_YA16BE() {
        return AV_PIX_FMT_YA16BE;
    }
    private static final int AV_PIX_FMT_YA16LE = (int)110L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YA16LE = 110
     * }
     */
    public static int AV_PIX_FMT_YA16LE() {
        return AV_PIX_FMT_YA16LE;
    }
    private static final int AV_PIX_FMT_GBRAP = (int)111L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP = 111
     * }
     */
    public static int AV_PIX_FMT_GBRAP() {
        return AV_PIX_FMT_GBRAP;
    }
    private static final int AV_PIX_FMT_GBRAP16BE = (int)112L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16BE = 112
     * }
     */
    public static int AV_PIX_FMT_GBRAP16BE() {
        return AV_PIX_FMT_GBRAP16BE;
    }
    private static final int AV_PIX_FMT_GBRAP16LE = (int)113L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_GBRAP16LE = 113
     * }
     */
    public static int AV_PIX_FMT_GBRAP16LE() {
        return AV_PIX_FMT_GBRAP16LE;
    }
    private static final int AV_PIX_FMT_QSV = (int)114L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_QSV = 114
     * }
     */
    public static int AV_PIX_FMT_QSV() {
        return AV_PIX_FMT_QSV;
    }
    private static final int AV_PIX_FMT_MMAL = (int)115L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_MMAL = 115
     * }
     */
    public static int AV_PIX_FMT_MMAL() {
        return AV_PIX_FMT_MMAL;
    }
    private static final int AV_PIX_FMT_D3D11VA_VLD = (int)116L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_D3D11VA_VLD = 116
     * }
     */
    public static int AV_PIX_FMT_D3D11VA_VLD() {
        return AV_PIX_FMT_D3D11VA_VLD;
    }
    private static final int AV_PIX_FMT_CUDA = (int)117L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_CUDA = 117
     * }
     */
    public static int AV_PIX_FMT_CUDA() {
        return AV_PIX_FMT_CUDA;
    }
    private static final int AV_PIX_FMT_0RGB = (int)118L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0RGB = 118
     * }
     */
    public static int AV_PIX_FMT_0RGB() {
        return AV_PIX_FMT_0RGB;
    }
    private static final int AV_PIX_FMT_RGB0 = (int)119L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_RGB0 = 119
     * }
     */
    public static int AV_PIX_FMT_RGB0() {
        return AV_PIX_FMT_RGB0;
    }
    private static final int AV_PIX_FMT_0BGR = (int)120L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_0BGR = 120
     * }
     */
    public static int AV_PIX_FMT_0BGR() {
        return AV_PIX_FMT_0BGR;
    }
    private static final int AV_PIX_FMT_BGR0 = (int)121L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_BGR0 = 121
     * }
     */
    public static int AV_PIX_FMT_BGR0() {
        return AV_PIX_FMT_BGR0;
    }
    private static final int AV_PIX_FMT_YUV420P12BE = (int)122L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12BE = 122
     * }
     */
    public static int AV_PIX_FMT_YUV420P12BE() {
        return AV_PIX_FMT_YUV420P12BE;
    }
    private static final int AV_PIX_FMT_YUV420P12LE = (int)123L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P12LE = 123
     * }
     */
    public static int AV_PIX_FMT_YUV420P12LE() {
        return AV_PIX_FMT_YUV420P12LE;
    }
    private static final int AV_PIX_FMT_YUV420P14BE = (int)124L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14BE = 124
     * }
     */
    public static int AV_PIX_FMT_YUV420P14BE() {
        return AV_PIX_FMT_YUV420P14BE;
    }
    private static final int AV_PIX_FMT_YUV420P14LE = (int)125L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV420P14LE = 125
     * }
     */
    public static int AV_PIX_FMT_YUV420P14LE() {
        return AV_PIX_FMT_YUV420P14LE;
    }
    private static final int AV_PIX_FMT_YUV422P12BE = (int)126L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12BE = 126
     * }
     */
    public static int AV_PIX_FMT_YUV422P12BE() {
        return AV_PIX_FMT_YUV422P12BE;
    }
    private static final int AV_PIX_FMT_YUV422P12LE = (int)127L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P12LE = 127
     * }
     */
    public static int AV_PIX_FMT_YUV422P12LE() {
        return AV_PIX_FMT_YUV422P12LE;
    }
    private static final int AV_PIX_FMT_YUV422P14BE = (int)128L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14BE = 128
     * }
     */
    public static int AV_PIX_FMT_YUV422P14BE() {
        return AV_PIX_FMT_YUV422P14BE;
    }
    private static final int AV_PIX_FMT_YUV422P14LE = (int)129L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV422P14LE = 129
     * }
     */
    public static int AV_PIX_FMT_YUV422P14LE() {
        return AV_PIX_FMT_YUV422P14LE;
    }
    private static final int AV_PIX_FMT_YUV444P12BE = (int)130L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12BE = 130
     * }
     */
    public static int AV_PIX_FMT_YUV444P12BE() {
        return AV_PIX_FMT_YUV444P12BE;
    }
    private static final int AV_PIX_FMT_YUV444P12LE = (int)131L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P12LE = 131
     * }
     */
    public static int AV_PIX_FMT_YUV444P12LE() {
        return AV_PIX_FMT_YUV444P12LE;
    }
    private static final int AV_PIX_FMT_YUV444P14BE = (int)132L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14BE = 132
     * }
     */
    public static int AV_PIX_FMT_YUV444P14BE() {
        return AV_PIX_FMT_YUV444P14BE;
    }
    private static final int AV_PIX_FMT_YUV444P14LE = (int)133L;
    /**
     * {@snippet lang=c :
     * enum AVPixelFormat.AV_PIX_FMT_YUV444P14LE = 133
     * }
     */
    public static int AV_PIX_FMT_YUV444P14LE() {
        return AV_PIX_FMT_YUV444P14LE;
    }
}

