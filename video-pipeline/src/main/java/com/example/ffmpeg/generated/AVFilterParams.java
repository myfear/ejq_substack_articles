// Generated by jextract

package com.example.ffmpeg.generated;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct AVFilterParams {
 *     AVFilterContext *filter;
 *     char *filter_name;
 *     char *instance_name;
 *     AVDictionary *opts;
 *     AVFilterPadParams **inputs;
 *     unsigned int nb_inputs;
 *     AVFilterPadParams **outputs;
 *     unsigned int nb_outputs;
 * }
 * }
 */
public class AVFilterParams {

    AVFilterParams() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        FFmpeg.C_POINTER.withName("filter"),
        FFmpeg.C_POINTER.withName("filter_name"),
        FFmpeg.C_POINTER.withName("instance_name"),
        FFmpeg.C_POINTER.withName("opts"),
        FFmpeg.C_POINTER.withName("inputs"),
        FFmpeg.C_INT.withName("nb_inputs"),
        MemoryLayout.paddingLayout(4),
        FFmpeg.C_POINTER.withName("outputs"),
        FFmpeg.C_INT.withName("nb_outputs"),
        MemoryLayout.paddingLayout(4)
    ).withName("AVFilterParams");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout filter$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("filter"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVFilterContext *filter
     * }
     */
    public static final AddressLayout filter$layout() {
        return filter$LAYOUT;
    }

    private static final long filter$OFFSET = $LAYOUT.byteOffset(groupElement("filter"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVFilterContext *filter
     * }
     */
    public static final long filter$offset() {
        return filter$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVFilterContext *filter
     * }
     */
    public static MemorySegment filter(MemorySegment struct) {
        return struct.get(filter$LAYOUT, filter$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVFilterContext *filter
     * }
     */
    public static void filter(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(filter$LAYOUT, filter$OFFSET, fieldValue);
    }

    private static final AddressLayout filter_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("filter_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *filter_name
     * }
     */
    public static final AddressLayout filter_name$layout() {
        return filter_name$LAYOUT;
    }

    private static final long filter_name$OFFSET = $LAYOUT.byteOffset(groupElement("filter_name"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *filter_name
     * }
     */
    public static final long filter_name$offset() {
        return filter_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *filter_name
     * }
     */
    public static MemorySegment filter_name(MemorySegment struct) {
        return struct.get(filter_name$LAYOUT, filter_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *filter_name
     * }
     */
    public static void filter_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(filter_name$LAYOUT, filter_name$OFFSET, fieldValue);
    }

    private static final AddressLayout instance_name$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("instance_name"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * char *instance_name
     * }
     */
    public static final AddressLayout instance_name$layout() {
        return instance_name$LAYOUT;
    }

    private static final long instance_name$OFFSET = $LAYOUT.byteOffset(groupElement("instance_name"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * char *instance_name
     * }
     */
    public static final long instance_name$offset() {
        return instance_name$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * char *instance_name
     * }
     */
    public static MemorySegment instance_name(MemorySegment struct) {
        return struct.get(instance_name$LAYOUT, instance_name$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * char *instance_name
     * }
     */
    public static void instance_name(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(instance_name$LAYOUT, instance_name$OFFSET, fieldValue);
    }

    private static final AddressLayout opts$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("opts"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVDictionary *opts
     * }
     */
    public static final AddressLayout opts$layout() {
        return opts$LAYOUT;
    }

    private static final long opts$OFFSET = $LAYOUT.byteOffset(groupElement("opts"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVDictionary *opts
     * }
     */
    public static final long opts$offset() {
        return opts$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVDictionary *opts
     * }
     */
    public static MemorySegment opts(MemorySegment struct) {
        return struct.get(opts$LAYOUT, opts$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVDictionary *opts
     * }
     */
    public static void opts(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(opts$LAYOUT, opts$OFFSET, fieldValue);
    }

    private static final AddressLayout inputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("inputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVFilterPadParams **inputs
     * }
     */
    public static final AddressLayout inputs$layout() {
        return inputs$LAYOUT;
    }

    private static final long inputs$OFFSET = $LAYOUT.byteOffset(groupElement("inputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVFilterPadParams **inputs
     * }
     */
    public static final long inputs$offset() {
        return inputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVFilterPadParams **inputs
     * }
     */
    public static MemorySegment inputs(MemorySegment struct) {
        return struct.get(inputs$LAYOUT, inputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVFilterPadParams **inputs
     * }
     */
    public static void inputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(inputs$LAYOUT, inputs$OFFSET, fieldValue);
    }

    private static final OfInt nb_inputs$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nb_inputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int nb_inputs
     * }
     */
    public static final OfInt nb_inputs$layout() {
        return nb_inputs$LAYOUT;
    }

    private static final long nb_inputs$OFFSET = $LAYOUT.byteOffset(groupElement("nb_inputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int nb_inputs
     * }
     */
    public static final long nb_inputs$offset() {
        return nb_inputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int nb_inputs
     * }
     */
    public static int nb_inputs(MemorySegment struct) {
        return struct.get(nb_inputs$LAYOUT, nb_inputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int nb_inputs
     * }
     */
    public static void nb_inputs(MemorySegment struct, int fieldValue) {
        struct.set(nb_inputs$LAYOUT, nb_inputs$OFFSET, fieldValue);
    }

    private static final AddressLayout outputs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("outputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * AVFilterPadParams **outputs
     * }
     */
    public static final AddressLayout outputs$layout() {
        return outputs$LAYOUT;
    }

    private static final long outputs$OFFSET = $LAYOUT.byteOffset(groupElement("outputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * AVFilterPadParams **outputs
     * }
     */
    public static final long outputs$offset() {
        return outputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * AVFilterPadParams **outputs
     * }
     */
    public static MemorySegment outputs(MemorySegment struct) {
        return struct.get(outputs$LAYOUT, outputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * AVFilterPadParams **outputs
     * }
     */
    public static void outputs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(outputs$LAYOUT, outputs$OFFSET, fieldValue);
    }

    private static final OfInt nb_outputs$LAYOUT = (OfInt)$LAYOUT.select(groupElement("nb_outputs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * unsigned int nb_outputs
     * }
     */
    public static final OfInt nb_outputs$layout() {
        return nb_outputs$LAYOUT;
    }

    private static final long nb_outputs$OFFSET = $LAYOUT.byteOffset(groupElement("nb_outputs"));

    /**
     * Offset for field:
     * {@snippet lang=c :
     * unsigned int nb_outputs
     * }
     */
    public static final long nb_outputs$offset() {
        return nb_outputs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * unsigned int nb_outputs
     * }
     */
    public static int nb_outputs(MemorySegment struct) {
        return struct.get(nb_outputs$LAYOUT, nb_outputs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * unsigned int nb_outputs
     * }
     */
    public static void nb_outputs(MemorySegment struct, int fieldValue) {
        struct.set(nb_outputs$LAYOUT, nb_outputs$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

