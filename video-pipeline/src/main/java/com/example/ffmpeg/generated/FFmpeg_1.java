// Generated by jextract

package com.example.ffmpeg.generated;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.nio.ByteOrder;
import java.util.*;
import java.util.function.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

class FFmpeg_1 extends FFmpeg_2 {

    FFmpeg_1() {
        // Should not be called directly
    }
    private static final int AVIO_DATA_MARKER_FLUSH_POINT = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVIODataMarkerType.AVIO_DATA_MARKER_FLUSH_POINT = 5
     * }
     */
    public static int AVIO_DATA_MARKER_FLUSH_POINT() {
        return AVIO_DATA_MARKER_FLUSH_POINT;
    }

    private static class avio_find_protocol_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_find_protocol_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static FunctionDescriptor avio_find_protocol_name$descriptor() {
        return avio_find_protocol_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static MethodHandle avio_find_protocol_name$handle() {
        return avio_find_protocol_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static MemorySegment avio_find_protocol_name$address() {
        return avio_find_protocol_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avio_find_protocol_name(const char *url)
     * }
     */
    public static MemorySegment avio_find_protocol_name(MemorySegment url) {
        var mh$ = avio_find_protocol_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_find_protocol_name", url);
            }
            return (MemorySegment)mh$.invokeExact(url);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_check {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_check");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static FunctionDescriptor avio_check$descriptor() {
        return avio_check.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static MethodHandle avio_check$handle() {
        return avio_check.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static MemorySegment avio_check$address() {
        return avio_check.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_check(const char *url, int flags)
     * }
     */
    public static int avio_check(MemorySegment url, int flags) {
        var mh$ = avio_check.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_check", url, flags);
            }
            return (int)mh$.invokeExact(url, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_open_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avio_open_dir$descriptor() {
        return avio_open_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static MethodHandle avio_open_dir$handle() {
        return avio_open_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static MemorySegment avio_open_dir$address() {
        return avio_open_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open_dir(AVIODirContext **s, const char *url, AVDictionary **options)
     * }
     */
    public static int avio_open_dir(MemorySegment s, MemorySegment url, MemorySegment options) {
        var mh$ = avio_open_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open_dir", s, url, options);
            }
            return (int)mh$.invokeExact(s, url, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_read_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static FunctionDescriptor avio_read_dir$descriptor() {
        return avio_read_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static MethodHandle avio_read_dir$handle() {
        return avio_read_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static MemorySegment avio_read_dir$address() {
        return avio_read_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read_dir(AVIODirContext *s, AVIODirEntry **next)
     * }
     */
    public static int avio_read_dir(MemorySegment s, MemorySegment next) {
        var mh$ = avio_read_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read_dir", s, next);
            }
            return (int)mh$.invokeExact(s, next);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_close_dir {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_close_dir");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static FunctionDescriptor avio_close_dir$descriptor() {
        return avio_close_dir.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static MethodHandle avio_close_dir$handle() {
        return avio_close_dir.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static MemorySegment avio_close_dir$address() {
        return avio_close_dir.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_close_dir(AVIODirContext **s)
     * }
     */
    public static int avio_close_dir(MemorySegment s) {
        var mh$ = avio_close_dir.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_close_dir", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_free_directory_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_free_directory_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static FunctionDescriptor avio_free_directory_entry$descriptor() {
        return avio_free_directory_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static MethodHandle avio_free_directory_entry$handle() {
        return avio_free_directory_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static MemorySegment avio_free_directory_entry$address() {
        return avio_free_directory_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_free_directory_entry(AVIODirEntry **entry)
     * }
     */
    public static void avio_free_directory_entry(MemorySegment entry) {
        var mh$ = avio_free_directory_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_free_directory_entry", entry);
            }
            mh$.invokeExact(entry);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, const uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static FunctionDescriptor avio_alloc_context$descriptor() {
        return avio_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, const uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static MethodHandle avio_alloc_context$handle() {
        return avio_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, const uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static MemorySegment avio_alloc_context$address() {
        return avio_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVIOContext *avio_alloc_context(unsigned char *buffer, int buffer_size, int write_flag, void *opaque, int (*read_packet)(void *, uint8_t *, int), int (*write_packet)(void *, const uint8_t *, int), int64_t (*seek)(void *, int64_t, int))
     * }
     */
    public static MemorySegment avio_alloc_context(MemorySegment buffer, int buffer_size, int write_flag, MemorySegment opaque, MemorySegment read_packet, MemorySegment write_packet, MemorySegment seek) {
        var mh$ = avio_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_alloc_context", buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek);
            }
            return (MemorySegment)mh$.invokeExact(buffer, buffer_size, write_flag, opaque, read_packet, write_packet, seek);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_context_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_context_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static FunctionDescriptor avio_context_free$descriptor() {
        return avio_context_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static MethodHandle avio_context_free$handle() {
        return avio_context_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static MemorySegment avio_context_free$address() {
        return avio_context_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_context_free(AVIOContext **s)
     * }
     */
    public static void avio_context_free(MemorySegment s) {
        var mh$ = avio_context_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_context_free", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_w8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_w8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static FunctionDescriptor avio_w8$descriptor() {
        return avio_w8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static MethodHandle avio_w8$handle() {
        return avio_w8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static MemorySegment avio_w8$address() {
        return avio_w8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_w8(AVIOContext *s, int b)
     * }
     */
    public static void avio_w8(MemorySegment s, int b) {
        var mh$ = avio_w8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_w8", s, b);
            }
            mh$.invokeExact(s, b);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_write {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_write");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static FunctionDescriptor avio_write$descriptor() {
        return avio_write.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static MethodHandle avio_write$handle() {
        return avio_write.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static MemorySegment avio_write$address() {
        return avio_write.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_write(AVIOContext *s, const unsigned char *buf, int size)
     * }
     */
    public static void avio_write(MemorySegment s, MemorySegment buf, int size) {
        var mh$ = avio_write.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_write", s, buf, size);
            }
            mh$.invokeExact(s, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static FunctionDescriptor avio_wl64$descriptor() {
        return avio_wl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MethodHandle avio_wl64$handle() {
        return avio_wl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MemorySegment avio_wl64$address() {
        return avio_wl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl64(AVIOContext *s, uint64_t val)
     * }
     */
    public static void avio_wl64(MemorySegment s, long val) {
        var mh$ = avio_wl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl64", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wb64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static FunctionDescriptor avio_wb64$descriptor() {
        return avio_wb64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MethodHandle avio_wb64$handle() {
        return avio_wb64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static MemorySegment avio_wb64$address() {
        return avio_wb64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb64(AVIOContext *s, uint64_t val)
     * }
     */
    public static void avio_wb64(MemorySegment s, long val) {
        var mh$ = avio_wb64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb64", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wl32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wl32$descriptor() {
        return avio_wl32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wl32$handle() {
        return avio_wl32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wl32$address() {
        return avio_wl32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl32(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wl32(MemorySegment s, int val) {
        var mh$ = avio_wl32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl32", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wb32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wb32$descriptor() {
        return avio_wb32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wb32$handle() {
        return avio_wb32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wb32$address() {
        return avio_wb32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb32(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wb32(MemorySegment s, int val) {
        var mh$ = avio_wb32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb32", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wl24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wl24$descriptor() {
        return avio_wl24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wl24$handle() {
        return avio_wl24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wl24$address() {
        return avio_wl24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl24(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wl24(MemorySegment s, int val) {
        var mh$ = avio_wl24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl24", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wb24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wb24$descriptor() {
        return avio_wb24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wb24$handle() {
        return avio_wb24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wb24$address() {
        return avio_wb24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb24(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wb24(MemorySegment s, int val) {
        var mh$ = avio_wb24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb24", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wl16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wl16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wl16$descriptor() {
        return avio_wl16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wl16$handle() {
        return avio_wl16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wl16$address() {
        return avio_wl16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wl16(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wl16(MemorySegment s, int val) {
        var mh$ = avio_wl16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wl16", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_wb16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_wb16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static FunctionDescriptor avio_wb16$descriptor() {
        return avio_wb16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MethodHandle avio_wb16$handle() {
        return avio_wb16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static MemorySegment avio_wb16$address() {
        return avio_wb16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_wb16(AVIOContext *s, unsigned int val)
     * }
     */
    public static void avio_wb16(MemorySegment s, int val) {
        var mh$ = avio_wb16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_wb16", s, val);
            }
            mh$.invokeExact(s, val);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_put_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_put_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static FunctionDescriptor avio_put_str$descriptor() {
        return avio_put_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static MethodHandle avio_put_str$handle() {
        return avio_put_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static MemorySegment avio_put_str$address() {
        return avio_put_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_put_str(AVIOContext *s, const char *str)
     * }
     */
    public static int avio_put_str(MemorySegment s, MemorySegment str) {
        var mh$ = avio_put_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_put_str", s, str);
            }
            return (int)mh$.invokeExact(s, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_put_str16le {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_put_str16le");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static FunctionDescriptor avio_put_str16le$descriptor() {
        return avio_put_str16le.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static MethodHandle avio_put_str16le$handle() {
        return avio_put_str16le.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static MemorySegment avio_put_str16le$address() {
        return avio_put_str16le.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_put_str16le(AVIOContext *s, const char *str)
     * }
     */
    public static int avio_put_str16le(MemorySegment s, MemorySegment str) {
        var mh$ = avio_put_str16le.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_put_str16le", s, str);
            }
            return (int)mh$.invokeExact(s, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_put_str16be {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_put_str16be");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static FunctionDescriptor avio_put_str16be$descriptor() {
        return avio_put_str16be.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static MethodHandle avio_put_str16be$handle() {
        return avio_put_str16be.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static MemorySegment avio_put_str16be$address() {
        return avio_put_str16be.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_put_str16be(AVIOContext *s, const char *str)
     * }
     */
    public static int avio_put_str16be(MemorySegment s, MemorySegment str) {
        var mh$ = avio_put_str16be.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_put_str16be", s, str);
            }
            return (int)mh$.invokeExact(s, str);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_write_marker {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_write_marker");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static FunctionDescriptor avio_write_marker$descriptor() {
        return avio_write_marker.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static MethodHandle avio_write_marker$handle() {
        return avio_write_marker.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static MemorySegment avio_write_marker$address() {
        return avio_write_marker.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_write_marker(AVIOContext *s, int64_t time, enum AVIODataMarkerType type)
     * }
     */
    public static void avio_write_marker(MemorySegment s, long time, int type) {
        var mh$ = avio_write_marker.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_write_marker", s, time, type);
            }
            mh$.invokeExact(s, time, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_seek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_seek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static FunctionDescriptor avio_seek$descriptor() {
        return avio_seek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static MethodHandle avio_seek$handle() {
        return avio_seek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static MemorySegment avio_seek$address() {
        return avio_seek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_seek(AVIOContext *s, int64_t offset, int whence)
     * }
     */
    public static long avio_seek(MemorySegment s, long offset, int whence) {
        var mh$ = avio_seek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_seek", s, offset, whence);
            }
            return (long)mh$.invokeExact(s, offset, whence);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_skip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_skip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static FunctionDescriptor avio_skip$descriptor() {
        return avio_skip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static MethodHandle avio_skip$handle() {
        return avio_skip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static MemorySegment avio_skip$address() {
        return avio_skip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_skip(AVIOContext *s, int64_t offset)
     * }
     */
    public static long avio_skip(MemorySegment s, long offset) {
        var mh$ = avio_skip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_skip", s, offset);
            }
            return (long)mh$.invokeExact(s, offset);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_size$descriptor() {
        return avio_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_size$handle() {
        return avio_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_size$address() {
        return avio_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_size(AVIOContext *s)
     * }
     */
    public static long avio_size(MemorySegment s) {
        var mh$ = avio_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_size", s);
            }
            return (long)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_feof$descriptor() {
        return avio_feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_feof$handle() {
        return avio_feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_feof$address() {
        return avio_feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_feof(AVIOContext *s)
     * }
     */
    public static int avio_feof(MemorySegment s) {
        var mh$ = avio_feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_feof", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static FunctionDescriptor avio_vprintf$descriptor() {
        return avio_vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static MethodHandle avio_vprintf$handle() {
        return avio_vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static MemorySegment avio_vprintf$address() {
        return avio_vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_vprintf(AVIOContext *s, const char *fmt, va_list ap)
     * }
     */
    public static int avio_vprintf(MemorySegment s, MemorySegment fmt, MemorySegment ap) {
        var mh$ = avio_vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_vprintf", s, fmt, ap);
            }
            return (int)mh$.invokeExact(s, fmt, ap);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * int avio_printf(AVIOContext *s, const char *fmt, ...)
     * }
     */
    public static class avio_printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                FFmpeg.C_INT,
                FFmpeg.C_POINTER,
                FFmpeg.C_POINTER
            );
        private static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private avio_printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * int avio_printf(AVIOContext *s, const char *fmt, ...)
         * }
         */
        public static avio_printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new avio_printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment s, MemorySegment fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("avio_printf", s, fmt, x2);
                }
                return (int) spreader.invokeExact(s, fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class avio_print_string_array {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_print_string_array");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *const strings[])
     * }
     */
    public static FunctionDescriptor avio_print_string_array$descriptor() {
        return avio_print_string_array.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *const strings[])
     * }
     */
    public static MethodHandle avio_print_string_array$handle() {
        return avio_print_string_array.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *const strings[])
     * }
     */
    public static MemorySegment avio_print_string_array$address() {
        return avio_print_string_array.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_print_string_array(AVIOContext *s, const char *const strings[])
     * }
     */
    public static void avio_print_string_array(MemorySegment s, MemorySegment strings) {
        var mh$ = avio_print_string_array.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_print_string_array", s, strings);
            }
            mh$.invokeExact(s, strings);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_flush$descriptor() {
        return avio_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_flush$handle() {
        return avio_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_flush$address() {
        return avio_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avio_flush(AVIOContext *s)
     * }
     */
    public static void avio_flush(MemorySegment s) {
        var mh$ = avio_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_flush", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_read");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static FunctionDescriptor avio_read$descriptor() {
        return avio_read.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MethodHandle avio_read$handle() {
        return avio_read.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MemorySegment avio_read$address() {
        return avio_read.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static int avio_read(MemorySegment s, MemorySegment buf, int size) {
        var mh$ = avio_read.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read", s, buf, size);
            }
            return (int)mh$.invokeExact(s, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read_partial {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_read_partial");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static FunctionDescriptor avio_read_partial$descriptor() {
        return avio_read_partial.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MethodHandle avio_read_partial$handle() {
        return avio_read_partial.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static MemorySegment avio_read_partial$address() {
        return avio_read_partial.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read_partial(AVIOContext *s, unsigned char *buf, int size)
     * }
     */
    public static int avio_read_partial(MemorySegment s, MemorySegment buf, int size) {
        var mh$ = avio_read_partial.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read_partial", s, buf, size);
            }
            return (int)mh$.invokeExact(s, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_r8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_r8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_r8$descriptor() {
        return avio_r8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_r8$handle() {
        return avio_r8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_r8$address() {
        return avio_r8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_r8(AVIOContext *s)
     * }
     */
    public static int avio_r8(MemorySegment s) {
        var mh$ = avio_r8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_r8", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rl16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl16$descriptor() {
        return avio_rl16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl16$handle() {
        return avio_rl16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl16$address() {
        return avio_rl16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rl16(AVIOContext *s)
     * }
     */
    public static int avio_rl16(MemorySegment s) {
        var mh$ = avio_rl16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl16", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rl24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl24$descriptor() {
        return avio_rl24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl24$handle() {
        return avio_rl24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl24$address() {
        return avio_rl24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rl24(AVIOContext *s)
     * }
     */
    public static int avio_rl24(MemorySegment s) {
        var mh$ = avio_rl24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl24", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rl32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl32$descriptor() {
        return avio_rl32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl32$handle() {
        return avio_rl32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl32$address() {
        return avio_rl32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rl32(AVIOContext *s)
     * }
     */
    public static int avio_rl32(MemorySegment s) {
        var mh$ = avio_rl32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl32", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rl64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rl64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rl64$descriptor() {
        return avio_rl64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rl64$handle() {
        return avio_rl64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rl64$address() {
        return avio_rl64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t avio_rl64(AVIOContext *s)
     * }
     */
    public static long avio_rl64(MemorySegment s) {
        var mh$ = avio_rl64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rl64", s);
            }
            return (long)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb16 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rb16");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb16$descriptor() {
        return avio_rb16.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb16$handle() {
        return avio_rb16.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb16$address() {
        return avio_rb16.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rb16(AVIOContext *s)
     * }
     */
    public static int avio_rb16(MemorySegment s) {
        var mh$ = avio_rb16.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb16", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rb24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb24$descriptor() {
        return avio_rb24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb24$handle() {
        return avio_rb24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb24$address() {
        return avio_rb24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rb24(AVIOContext *s)
     * }
     */
    public static int avio_rb24(MemorySegment s) {
        var mh$ = avio_rb24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb24", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rb32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb32$descriptor() {
        return avio_rb32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb32$handle() {
        return avio_rb32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb32$address() {
        return avio_rb32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avio_rb32(AVIOContext *s)
     * }
     */
    public static int avio_rb32(MemorySegment s) {
        var mh$ = avio_rb32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb32", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_rb64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_rb64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_rb64$descriptor() {
        return avio_rb64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_rb64$handle() {
        return avio_rb64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_rb64$address() {
        return avio_rb64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * uint64_t avio_rb64(AVIOContext *s)
     * }
     */
    public static long avio_rb64(MemorySegment s) {
        var mh$ = avio_rb64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_rb64", s);
            }
            return (long)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_get_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor avio_get_str$descriptor() {
        return avio_get_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MethodHandle avio_get_str$handle() {
        return avio_get_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MemorySegment avio_get_str$address() {
        return avio_get_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_str(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static int avio_get_str(MemorySegment pb, int maxlen, MemorySegment buf, int buflen) {
        var mh$ = avio_get_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_str", pb, maxlen, buf, buflen);
            }
            return (int)mh$.invokeExact(pb, maxlen, buf, buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_str16le {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_get_str16le");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor avio_get_str16le$descriptor() {
        return avio_get_str16le.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MethodHandle avio_get_str16le$handle() {
        return avio_get_str16le.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MemorySegment avio_get_str16le$address() {
        return avio_get_str16le.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_str16le(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static int avio_get_str16le(MemorySegment pb, int maxlen, MemorySegment buf, int buflen) {
        var mh$ = avio_get_str16le.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_str16le", pb, maxlen, buf, buflen);
            }
            return (int)mh$.invokeExact(pb, maxlen, buf, buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_str16be {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_get_str16be");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static FunctionDescriptor avio_get_str16be$descriptor() {
        return avio_get_str16be.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MethodHandle avio_get_str16be$handle() {
        return avio_get_str16be.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static MemorySegment avio_get_str16be$address() {
        return avio_get_str16be.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_str16be(AVIOContext *pb, int maxlen, char *buf, int buflen)
     * }
     */
    public static int avio_get_str16be(MemorySegment pb, int maxlen, MemorySegment buf, int buflen) {
        var mh$ = avio_get_str16be.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_str16be", pb, maxlen, buf, buflen);
            }
            return (int)mh$.invokeExact(pb, maxlen, buf, buflen);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static FunctionDescriptor avio_open$descriptor() {
        return avio_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static MethodHandle avio_open$handle() {
        return avio_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static MemorySegment avio_open$address() {
        return avio_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open(AVIOContext **s, const char *url, int flags)
     * }
     */
    public static int avio_open(MemorySegment s, MemorySegment url, int flags) {
        var mh$ = avio_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open", s, url, flags);
            }
            return (int)mh$.invokeExact(s, url, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_open2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avio_open2$descriptor() {
        return avio_open2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static MethodHandle avio_open2$handle() {
        return avio_open2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static MemorySegment avio_open2$address() {
        return avio_open2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open2(AVIOContext **s, const char *url, int flags, const AVIOInterruptCB *int_cb, AVDictionary **options)
     * }
     */
    public static int avio_open2(MemorySegment s, MemorySegment url, int flags, MemorySegment int_cb, MemorySegment options) {
        var mh$ = avio_open2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open2", s, url, flags, int_cb, options);
            }
            return (int)mh$.invokeExact(s, url, flags, int_cb, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static FunctionDescriptor avio_close$descriptor() {
        return avio_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static MethodHandle avio_close$handle() {
        return avio_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static MemorySegment avio_close$address() {
        return avio_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_close(AVIOContext *s)
     * }
     */
    public static int avio_close(MemorySegment s) {
        var mh$ = avio_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_close", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_closep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_closep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static FunctionDescriptor avio_closep$descriptor() {
        return avio_closep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static MethodHandle avio_closep$handle() {
        return avio_closep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static MemorySegment avio_closep$address() {
        return avio_closep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_closep(AVIOContext **s)
     * }
     */
    public static int avio_closep(MemorySegment s) {
        var mh$ = avio_closep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_closep", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_open_dyn_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_open_dyn_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static FunctionDescriptor avio_open_dyn_buf$descriptor() {
        return avio_open_dyn_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static MethodHandle avio_open_dyn_buf$handle() {
        return avio_open_dyn_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static MemorySegment avio_open_dyn_buf$address() {
        return avio_open_dyn_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_open_dyn_buf(AVIOContext **s)
     * }
     */
    public static int avio_open_dyn_buf(MemorySegment s) {
        var mh$ = avio_open_dyn_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_open_dyn_buf", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_get_dyn_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_get_dyn_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static FunctionDescriptor avio_get_dyn_buf$descriptor() {
        return avio_get_dyn_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MethodHandle avio_get_dyn_buf$handle() {
        return avio_get_dyn_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MemorySegment avio_get_dyn_buf$address() {
        return avio_get_dyn_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_get_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static int avio_get_dyn_buf(MemorySegment s, MemorySegment pbuffer) {
        var mh$ = avio_get_dyn_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_get_dyn_buf", s, pbuffer);
            }
            return (int)mh$.invokeExact(s, pbuffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_close_dyn_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_close_dyn_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static FunctionDescriptor avio_close_dyn_buf$descriptor() {
        return avio_close_dyn_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MethodHandle avio_close_dyn_buf$handle() {
        return avio_close_dyn_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static MemorySegment avio_close_dyn_buf$address() {
        return avio_close_dyn_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_close_dyn_buf(AVIOContext *s, uint8_t **pbuffer)
     * }
     */
    public static int avio_close_dyn_buf(MemorySegment s, MemorySegment pbuffer) {
        var mh$ = avio_close_dyn_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_close_dyn_buf", s, pbuffer);
            }
            return (int)mh$.invokeExact(s, pbuffer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_enum_protocols {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_enum_protocols");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static FunctionDescriptor avio_enum_protocols$descriptor() {
        return avio_enum_protocols.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static MethodHandle avio_enum_protocols$handle() {
        return avio_enum_protocols.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static MemorySegment avio_enum_protocols$address() {
        return avio_enum_protocols.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avio_enum_protocols(void **opaque, int output)
     * }
     */
    public static MemorySegment avio_enum_protocols(MemorySegment opaque, int output) {
        var mh$ = avio_enum_protocols.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_enum_protocols", opaque, output);
            }
            return (MemorySegment)mh$.invokeExact(opaque, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_protocol_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_protocol_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static FunctionDescriptor avio_protocol_get_class$descriptor() {
        return avio_protocol_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static MethodHandle avio_protocol_get_class$handle() {
        return avio_protocol_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static MemorySegment avio_protocol_get_class$address() {
        return avio_protocol_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avio_protocol_get_class(const char *name)
     * }
     */
    public static MemorySegment avio_protocol_get_class(MemorySegment name) {
        var mh$ = avio_protocol_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_protocol_get_class", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static FunctionDescriptor avio_pause$descriptor() {
        return avio_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static MethodHandle avio_pause$handle() {
        return avio_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static MemorySegment avio_pause$address() {
        return avio_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_pause(AVIOContext *h, int pause)
     * }
     */
    public static int avio_pause(MemorySegment h, int pause) {
        var mh$ = avio_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_pause", h, pause);
            }
            return (int)mh$.invokeExact(h, pause);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_seek_time {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_seek_time");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor avio_seek_time$descriptor() {
        return avio_seek_time.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle avio_seek_time$handle() {
        return avio_seek_time.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment avio_seek_time$address() {
        return avio_seek_time.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t avio_seek_time(AVIOContext *h, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static long avio_seek_time(MemorySegment h, int stream_index, long timestamp, int flags) {
        var mh$ = avio_seek_time.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_seek_time", h, stream_index, timestamp, flags);
            }
            return (long)mh$.invokeExact(h, stream_index, timestamp, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_read_to_bprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_read_to_bprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static FunctionDescriptor avio_read_to_bprint$descriptor() {
        return avio_read_to_bprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static MethodHandle avio_read_to_bprint$handle() {
        return avio_read_to_bprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static MemorySegment avio_read_to_bprint$address() {
        return avio_read_to_bprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_read_to_bprint(AVIOContext *h, struct AVBPrint *pb, size_t max_size)
     * }
     */
    public static int avio_read_to_bprint(MemorySegment h, MemorySegment pb, long max_size) {
        var mh$ = avio_read_to_bprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_read_to_bprint", h, pb, max_size);
            }
            return (int)mh$.invokeExact(h, pb, max_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_accept {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_accept");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static FunctionDescriptor avio_accept$descriptor() {
        return avio_accept.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static MethodHandle avio_accept$handle() {
        return avio_accept.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static MemorySegment avio_accept$address() {
        return avio_accept.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_accept(AVIOContext *s, AVIOContext **c)
     * }
     */
    public static int avio_accept(MemorySegment s, MemorySegment c) {
        var mh$ = avio_accept.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_accept", s, c);
            }
            return (int)mh$.invokeExact(s, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avio_handshake {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avio_handshake");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static FunctionDescriptor avio_handshake$descriptor() {
        return avio_handshake.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static MethodHandle avio_handshake$handle() {
        return avio_handshake.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static MemorySegment avio_handshake$address() {
        return avio_handshake.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avio_handshake(AVIOContext *c)
     * }
     */
    public static int avio_handshake(MemorySegment c) {
        var mh$ = avio_handshake.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avio_handshake", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_FRAME_DATA_PANSCAN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_PANSCAN = 0
     * }
     */
    public static int AV_FRAME_DATA_PANSCAN() {
        return AV_FRAME_DATA_PANSCAN;
    }
    private static final int AV_FRAME_DATA_A53_CC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_A53_CC = 1
     * }
     */
    public static int AV_FRAME_DATA_A53_CC() {
        return AV_FRAME_DATA_A53_CC;
    }
    private static final int AV_FRAME_DATA_STEREO3D = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_STEREO3D = 2
     * }
     */
    public static int AV_FRAME_DATA_STEREO3D() {
        return AV_FRAME_DATA_STEREO3D;
    }
    private static final int AV_FRAME_DATA_MATRIXENCODING = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MATRIXENCODING = 3
     * }
     */
    public static int AV_FRAME_DATA_MATRIXENCODING() {
        return AV_FRAME_DATA_MATRIXENCODING;
    }
    private static final int AV_FRAME_DATA_DOWNMIX_INFO = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOWNMIX_INFO = 4
     * }
     */
    public static int AV_FRAME_DATA_DOWNMIX_INFO() {
        return AV_FRAME_DATA_DOWNMIX_INFO;
    }
    private static final int AV_FRAME_DATA_REPLAYGAIN = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_REPLAYGAIN = 5
     * }
     */
    public static int AV_FRAME_DATA_REPLAYGAIN() {
        return AV_FRAME_DATA_REPLAYGAIN;
    }
    private static final int AV_FRAME_DATA_DISPLAYMATRIX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DISPLAYMATRIX = 6
     * }
     */
    public static int AV_FRAME_DATA_DISPLAYMATRIX() {
        return AV_FRAME_DATA_DISPLAYMATRIX;
    }
    private static final int AV_FRAME_DATA_AFD = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AFD = 7
     * }
     */
    public static int AV_FRAME_DATA_AFD() {
        return AV_FRAME_DATA_AFD;
    }
    private static final int AV_FRAME_DATA_MOTION_VECTORS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MOTION_VECTORS = 8
     * }
     */
    public static int AV_FRAME_DATA_MOTION_VECTORS() {
        return AV_FRAME_DATA_MOTION_VECTORS;
    }
    private static final int AV_FRAME_DATA_SKIP_SAMPLES = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SKIP_SAMPLES = 9
     * }
     */
    public static int AV_FRAME_DATA_SKIP_SAMPLES() {
        return AV_FRAME_DATA_SKIP_SAMPLES;
    }
    private static final int AV_FRAME_DATA_AUDIO_SERVICE_TYPE = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AUDIO_SERVICE_TYPE = 10
     * }
     */
    public static int AV_FRAME_DATA_AUDIO_SERVICE_TYPE() {
        return AV_FRAME_DATA_AUDIO_SERVICE_TYPE;
    }
    private static final int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_MASTERING_DISPLAY_METADATA = 11
     * }
     */
    public static int AV_FRAME_DATA_MASTERING_DISPLAY_METADATA() {
        return AV_FRAME_DATA_MASTERING_DISPLAY_METADATA;
    }
    private static final int AV_FRAME_DATA_GOP_TIMECODE = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_GOP_TIMECODE = 12
     * }
     */
    public static int AV_FRAME_DATA_GOP_TIMECODE() {
        return AV_FRAME_DATA_GOP_TIMECODE;
    }
    private static final int AV_FRAME_DATA_SPHERICAL = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SPHERICAL = 13
     * }
     */
    public static int AV_FRAME_DATA_SPHERICAL() {
        return AV_FRAME_DATA_SPHERICAL;
    }
    private static final int AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_CONTENT_LIGHT_LEVEL = 14
     * }
     */
    public static int AV_FRAME_DATA_CONTENT_LIGHT_LEVEL() {
        return AV_FRAME_DATA_CONTENT_LIGHT_LEVEL;
    }
    private static final int AV_FRAME_DATA_ICC_PROFILE = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_ICC_PROFILE = 15
     * }
     */
    public static int AV_FRAME_DATA_ICC_PROFILE() {
        return AV_FRAME_DATA_ICC_PROFILE;
    }
    private static final int AV_FRAME_DATA_S12M_TIMECODE = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_S12M_TIMECODE = 16
     * }
     */
    public static int AV_FRAME_DATA_S12M_TIMECODE() {
        return AV_FRAME_DATA_S12M_TIMECODE;
    }
    private static final int AV_FRAME_DATA_DYNAMIC_HDR_PLUS = (int)17L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DYNAMIC_HDR_PLUS = 17
     * }
     */
    public static int AV_FRAME_DATA_DYNAMIC_HDR_PLUS() {
        return AV_FRAME_DATA_DYNAMIC_HDR_PLUS;
    }
    private static final int AV_FRAME_DATA_REGIONS_OF_INTEREST = (int)18L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_REGIONS_OF_INTEREST = 18
     * }
     */
    public static int AV_FRAME_DATA_REGIONS_OF_INTEREST() {
        return AV_FRAME_DATA_REGIONS_OF_INTEREST;
    }
    private static final int AV_FRAME_DATA_VIDEO_ENC_PARAMS = (int)19L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_VIDEO_ENC_PARAMS = 19
     * }
     */
    public static int AV_FRAME_DATA_VIDEO_ENC_PARAMS() {
        return AV_FRAME_DATA_VIDEO_ENC_PARAMS;
    }
    private static final int AV_FRAME_DATA_SEI_UNREGISTERED = (int)20L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_SEI_UNREGISTERED = 20
     * }
     */
    public static int AV_FRAME_DATA_SEI_UNREGISTERED() {
        return AV_FRAME_DATA_SEI_UNREGISTERED;
    }
    private static final int AV_FRAME_DATA_FILM_GRAIN_PARAMS = (int)21L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_FILM_GRAIN_PARAMS = 21
     * }
     */
    public static int AV_FRAME_DATA_FILM_GRAIN_PARAMS() {
        return AV_FRAME_DATA_FILM_GRAIN_PARAMS;
    }
    private static final int AV_FRAME_DATA_DETECTION_BBOXES = (int)22L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DETECTION_BBOXES = 22
     * }
     */
    public static int AV_FRAME_DATA_DETECTION_BBOXES() {
        return AV_FRAME_DATA_DETECTION_BBOXES;
    }
    private static final int AV_FRAME_DATA_DOVI_RPU_BUFFER = (int)23L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOVI_RPU_BUFFER = 23
     * }
     */
    public static int AV_FRAME_DATA_DOVI_RPU_BUFFER() {
        return AV_FRAME_DATA_DOVI_RPU_BUFFER;
    }
    private static final int AV_FRAME_DATA_DOVI_METADATA = (int)24L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DOVI_METADATA = 24
     * }
     */
    public static int AV_FRAME_DATA_DOVI_METADATA() {
        return AV_FRAME_DATA_DOVI_METADATA;
    }
    private static final int AV_FRAME_DATA_DYNAMIC_HDR_VIVID = (int)25L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_DYNAMIC_HDR_VIVID = 25
     * }
     */
    public static int AV_FRAME_DATA_DYNAMIC_HDR_VIVID() {
        return AV_FRAME_DATA_DYNAMIC_HDR_VIVID;
    }
    private static final int AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT = (int)26L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT = 26
     * }
     */
    public static int AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT() {
        return AV_FRAME_DATA_AMBIENT_VIEWING_ENVIRONMENT;
    }
    private static final int AV_FRAME_DATA_VIDEO_HINT = (int)27L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_VIDEO_HINT = 27
     * }
     */
    public static int AV_FRAME_DATA_VIDEO_HINT() {
        return AV_FRAME_DATA_VIDEO_HINT;
    }
    private static final int AV_FRAME_DATA_LCEVC = (int)28L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_LCEVC = 28
     * }
     */
    public static int AV_FRAME_DATA_LCEVC() {
        return AV_FRAME_DATA_LCEVC;
    }
    private static final int AV_FRAME_DATA_VIEW_ID = (int)29L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_VIEW_ID = 29
     * }
     */
    public static int AV_FRAME_DATA_VIEW_ID() {
        return AV_FRAME_DATA_VIEW_ID;
    }
    private static final int AV_FRAME_DATA_3D_REFERENCE_DISPLAYS = (int)30L;
    /**
     * {@snippet lang=c :
     * enum AVFrameSideDataType.AV_FRAME_DATA_3D_REFERENCE_DISPLAYS = 30
     * }
     */
    public static int AV_FRAME_DATA_3D_REFERENCE_DISPLAYS() {
        return AV_FRAME_DATA_3D_REFERENCE_DISPLAYS;
    }
    private static final int AV_AFD_SAME = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_SAME = 8
     * }
     */
    public static int AV_AFD_SAME() {
        return AV_AFD_SAME;
    }
    private static final int AV_AFD_4_3 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_4_3 = 9
     * }
     */
    public static int AV_AFD_4_3() {
        return AV_AFD_4_3;
    }
    private static final int AV_AFD_16_9 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_16_9 = 10
     * }
     */
    public static int AV_AFD_16_9() {
        return AV_AFD_16_9;
    }
    private static final int AV_AFD_14_9 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_14_9 = 11
     * }
     */
    public static int AV_AFD_14_9() {
        return AV_AFD_14_9;
    }
    private static final int AV_AFD_4_3_SP_14_9 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_4_3_SP_14_9 = 13
     * }
     */
    public static int AV_AFD_4_3_SP_14_9() {
        return AV_AFD_4_3_SP_14_9;
    }
    private static final int AV_AFD_16_9_SP_14_9 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_16_9_SP_14_9 = 14
     * }
     */
    public static int AV_AFD_16_9_SP_14_9() {
        return AV_AFD_16_9_SP_14_9;
    }
    private static final int AV_AFD_SP_4_3 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum AVActiveFormatDescription.AV_AFD_SP_4_3 = 15
     * }
     */
    public static int AV_AFD_SP_4_3() {
        return AV_AFD_SP_4_3;
    }
    private static final int AV_SIDE_DATA_PROP_GLOBAL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_GLOBAL = 1
     * }
     */
    public static int AV_SIDE_DATA_PROP_GLOBAL() {
        return AV_SIDE_DATA_PROP_GLOBAL;
    }
    private static final int AV_SIDE_DATA_PROP_MULTI = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_MULTI = 2
     * }
     */
    public static int AV_SIDE_DATA_PROP_MULTI() {
        return AV_SIDE_DATA_PROP_MULTI;
    }
    private static final int AV_SIDE_DATA_PROP_SIZE_DEPENDENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_SIZE_DEPENDENT = 4
     * }
     */
    public static int AV_SIDE_DATA_PROP_SIZE_DEPENDENT() {
        return AV_SIDE_DATA_PROP_SIZE_DEPENDENT;
    }
    private static final int AV_SIDE_DATA_PROP_COLOR_DEPENDENT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_COLOR_DEPENDENT = 8
     * }
     */
    public static int AV_SIDE_DATA_PROP_COLOR_DEPENDENT() {
        return AV_SIDE_DATA_PROP_COLOR_DEPENDENT;
    }
    private static final int AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum AVSideDataProps.AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT = 16
     * }
     */
    public static int AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT() {
        return AV_SIDE_DATA_PROP_CHANNEL_DEPENDENT;
    }

    private static class av_frame_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static FunctionDescriptor av_frame_alloc$descriptor() {
        return av_frame_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MethodHandle av_frame_alloc$handle() {
        return av_frame_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MemorySegment av_frame_alloc$address() {
        return av_frame_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_alloc()
     * }
     */
    public static MemorySegment av_frame_alloc() {
        var mh$ = av_frame_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static FunctionDescriptor av_frame_free$descriptor() {
        return av_frame_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static MethodHandle av_frame_free$handle() {
        return av_frame_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static MemorySegment av_frame_free$address() {
        return av_frame_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_free(AVFrame **frame)
     * }
     */
    public static void av_frame_free(MemorySegment frame) {
        var mh$ = av_frame_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_free", frame);
            }
            mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_ref$descriptor() {
        return av_frame_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_ref$handle() {
        return av_frame_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_ref$address() {
        return av_frame_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_ref(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_ref", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_replace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_replace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_replace$descriptor() {
        return av_frame_replace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_replace$handle() {
        return av_frame_replace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_replace$address() {
        return av_frame_replace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_replace(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_replace(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_replace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_replace", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_clone$descriptor() {
        return av_frame_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_clone$handle() {
        return av_frame_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_clone$address() {
        return av_frame_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrame *av_frame_clone(const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_clone(MemorySegment src) {
        var mh$ = av_frame_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_clone", src);
            }
            return (MemorySegment)mh$.invokeExact(src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_unref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_unref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_unref$descriptor() {
        return av_frame_unref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_unref$handle() {
        return av_frame_unref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_unref$address() {
        return av_frame_unref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_unref(AVFrame *frame)
     * }
     */
    public static void av_frame_unref(MemorySegment frame) {
        var mh$ = av_frame_unref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_unref", frame);
            }
            mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_move_ref {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_move_ref");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_move_ref$descriptor() {
        return av_frame_move_ref.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_move_ref$handle() {
        return av_frame_move_ref.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_move_ref$address() {
        return av_frame_move_ref.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_move_ref(AVFrame *dst, AVFrame *src)
     * }
     */
    public static void av_frame_move_ref(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_move_ref.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_move_ref", dst, src);
            }
            mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static FunctionDescriptor av_frame_get_buffer$descriptor() {
        return av_frame_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static MethodHandle av_frame_get_buffer$handle() {
        return av_frame_get_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static MemorySegment av_frame_get_buffer$address() {
        return av_frame_get_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_get_buffer(AVFrame *frame, int align)
     * }
     */
    public static int av_frame_get_buffer(MemorySegment frame, int align) {
        var mh$ = av_frame_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_buffer", frame, align);
            }
            return (int)mh$.invokeExact(frame, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_is_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_is_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_is_writable$descriptor() {
        return av_frame_is_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_is_writable$handle() {
        return av_frame_is_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_is_writable$address() {
        return av_frame_is_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_is_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_is_writable(MemorySegment frame) {
        var mh$ = av_frame_is_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_is_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_make_writable {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_make_writable");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_frame_make_writable$descriptor() {
        return av_frame_make_writable.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static MethodHandle av_frame_make_writable$handle() {
        return av_frame_make_writable.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static MemorySegment av_frame_make_writable$address() {
        return av_frame_make_writable.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_make_writable(AVFrame *frame)
     * }
     */
    public static int av_frame_make_writable(MemorySegment frame) {
        var mh$ = av_frame_make_writable.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_make_writable", frame);
            }
            return (int)mh$.invokeExact(frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy$descriptor() {
        return av_frame_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy$handle() {
        return av_frame_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_copy$address() {
        return av_frame_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_copy(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_copy_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_copy_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor av_frame_copy_props$descriptor() {
        return av_frame_copy_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle av_frame_copy_props$handle() {
        return av_frame_copy_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment av_frame_copy_props$address() {
        return av_frame_copy_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_copy_props(AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int av_frame_copy_props(MemorySegment dst, MemorySegment src) {
        var mh$ = av_frame_copy_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_copy_props", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_plane_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_plane_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static FunctionDescriptor av_frame_get_plane_buffer$descriptor() {
        return av_frame_get_plane_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MethodHandle av_frame_get_plane_buffer$handle() {
        return av_frame_get_plane_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MemorySegment av_frame_get_plane_buffer$address() {
        return av_frame_get_plane_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_frame_get_plane_buffer(const AVFrame *frame, int plane)
     * }
     */
    public static MemorySegment av_frame_get_plane_buffer(MemorySegment frame, int plane) {
        var mh$ = av_frame_get_plane_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_plane_buffer", frame, plane);
            }
            return (MemorySegment)mh$.invokeExact(frame, plane);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_new_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data$descriptor() {
        return av_frame_new_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MethodHandle av_frame_new_side_data$handle() {
        return av_frame_new_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_frame_new_side_data$address() {
        return av_frame_new_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data(AVFrame *frame, enum AVFrameSideDataType type, size_t size)
     * }
     */
    public static MemorySegment av_frame_new_side_data(MemorySegment frame, int type, long size) {
        var mh$ = av_frame_new_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data", frame, type, size);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_new_side_data_from_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_new_side_data_from_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static FunctionDescriptor av_frame_new_side_data_from_buf$descriptor() {
        return av_frame_new_side_data_from_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MethodHandle av_frame_new_side_data_from_buf$handle() {
        return av_frame_new_side_data_from_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_frame_new_side_data_from_buf$address() {
        return av_frame_new_side_data_from_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_new_side_data_from_buf(AVFrame *frame, enum AVFrameSideDataType type, AVBufferRef *buf)
     * }
     */
    public static MemorySegment av_frame_new_side_data_from_buf(MemorySegment frame, int type, MemorySegment buf) {
        var mh$ = av_frame_new_side_data_from_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_new_side_data_from_buf", frame, type, buf);
            }
            return (MemorySegment)mh$.invokeExact(frame, type, buf);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_get_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_get_side_data$descriptor() {
        return av_frame_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_get_side_data$handle() {
        return av_frame_get_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_get_side_data$address() {
        return av_frame_get_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_get_side_data(const AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_get_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_get_side_data", frame, type);
            }
            return (MemorySegment)mh$.invokeExact(frame, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_remove_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_remove_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_remove_side_data$descriptor() {
        return av_frame_remove_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_remove_side_data$handle() {
        return av_frame_remove_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_remove_side_data$address() {
        return av_frame_remove_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_remove_side_data(AVFrame *frame, enum AVFrameSideDataType type)
     * }
     */
    public static void av_frame_remove_side_data(MemorySegment frame, int type) {
        var mh$ = av_frame_remove_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_remove_side_data", frame, type);
            }
            mh$.invokeExact(frame, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_FRAME_CROP_UNALIGNED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_FRAME_CROP_UNALIGNED = 1
     * }
     */
    public static int AV_FRAME_CROP_UNALIGNED() {
        return AV_FRAME_CROP_UNALIGNED;
    }

    private static class av_frame_apply_cropping {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_apply_cropping");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_frame_apply_cropping$descriptor() {
        return av_frame_apply_cropping.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_frame_apply_cropping$handle() {
        return av_frame_apply_cropping.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment av_frame_apply_cropping$address() {
        return av_frame_apply_cropping.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_apply_cropping(AVFrame *frame, int flags)
     * }
     */
    public static int av_frame_apply_cropping(MemorySegment frame, int flags) {
        var mh$ = av_frame_apply_cropping.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_apply_cropping", frame, flags);
            }
            return (int)mh$.invokeExact(frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_name$descriptor() {
        return av_frame_side_data_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_name$handle() {
        return av_frame_side_data_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_name$address() {
        return av_frame_side_data_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_frame_side_data_name(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_name(int type) {
        var mh$ = av_frame_side_data_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_desc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_desc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_desc$descriptor() {
        return av_frame_side_data_desc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_desc$handle() {
        return av_frame_side_data_desc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_desc$address() {
        return av_frame_side_data_desc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVSideDataDescriptor *av_frame_side_data_desc(enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_desc(int type) {
        var mh$ = av_frame_side_data_desc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_desc", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_free$descriptor() {
        return av_frame_side_data_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static MethodHandle av_frame_side_data_free$handle() {
        return av_frame_side_data_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static MemorySegment av_frame_side_data_free$address() {
        return av_frame_side_data_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_free(AVFrameSideData ***sd, int *nb_sd)
     * }
     */
    public static void av_frame_side_data_free(MemorySegment sd, MemorySegment nb_sd) {
        var mh$ = av_frame_side_data_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_free", sd, nb_sd);
            }
            mh$.invokeExact(sd, nb_sd);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_new {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_new");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_new$descriptor() {
        return av_frame_side_data_new.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_new$handle() {
        return av_frame_side_data_new.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_new$address() {
        return av_frame_side_data_new.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_new(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, size_t size, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_new(MemorySegment sd, MemorySegment nb_sd, int type, long size, int flags) {
        var mh$ = av_frame_side_data_new.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_new", sd, nb_sd, type, size, flags);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type, size, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_add$descriptor() {
        return av_frame_side_data_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_add$handle() {
        return av_frame_side_data_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_add$address() {
        return av_frame_side_data_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFrameSideData *av_frame_side_data_add(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type, AVBufferRef **buf, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_add(MemorySegment sd, MemorySegment nb_sd, int type, MemorySegment buf, int flags) {
        var mh$ = av_frame_side_data_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_add", sd, nb_sd, type, buf, flags);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type, buf, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_clone {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_clone");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_clone$descriptor() {
        return av_frame_side_data_clone.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static MethodHandle av_frame_side_data_clone$handle() {
        return av_frame_side_data_clone.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static MemorySegment av_frame_side_data_clone$address() {
        return av_frame_side_data_clone.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_frame_side_data_clone(AVFrameSideData ***sd, int *nb_sd, const AVFrameSideData *src, unsigned int flags)
     * }
     */
    public static int av_frame_side_data_clone(MemorySegment sd, MemorySegment nb_sd, MemorySegment src, int flags) {
        var mh$ = av_frame_side_data_clone.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_clone", sd, nb_sd, src, flags);
            }
            return (int)mh$.invokeExact(sd, nb_sd, src, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_get_c {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_get_c");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_get_c$descriptor() {
        return av_frame_side_data_get_c.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_get_c$handle() {
        return av_frame_side_data_get_c.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_get_c$address() {
        return av_frame_side_data_get_c.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVFrameSideData *av_frame_side_data_get_c(const AVFrameSideData *const *sd, const int nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_get_c(MemorySegment sd, int nb_sd, int type) {
        var mh$ = av_frame_side_data_get_c.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_get_c", sd, nb_sd, type);
            }
            return (MemorySegment)mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_remove$descriptor() {
        return av_frame_side_data_remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MethodHandle av_frame_side_data_remove$handle() {
        return av_frame_side_data_remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static MemorySegment av_frame_side_data_remove$address() {
        return av_frame_side_data_remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_remove(AVFrameSideData ***sd, int *nb_sd, enum AVFrameSideDataType type)
     * }
     */
    public static void av_frame_side_data_remove(MemorySegment sd, MemorySegment nb_sd, int type) {
        var mh$ = av_frame_side_data_remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_remove", sd, nb_sd, type);
            }
            mh$.invokeExact(sd, nb_sd, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_frame_side_data_remove_by_props {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_frame_side_data_remove_by_props");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static FunctionDescriptor av_frame_side_data_remove_by_props$descriptor() {
        return av_frame_side_data_remove_by_props.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static MethodHandle av_frame_side_data_remove_by_props$handle() {
        return av_frame_side_data_remove_by_props.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static MemorySegment av_frame_side_data_remove_by_props$address() {
        return av_frame_side_data_remove_by_props.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_frame_side_data_remove_by_props(AVFrameSideData ***sd, int *nb_sd, int props)
     * }
     */
    public static void av_frame_side_data_remove_by_props(MemorySegment sd, MemorySegment nb_sd, int props) {
        var mh$ = av_frame_side_data_remove_by_props.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_frame_side_data_remove_by_props", sd, nb_sd, props);
            }
            mh$.invokeExact(sd, nb_sd, props);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_HWDEVICE_TYPE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_NONE = 0
     * }
     */
    public static int AV_HWDEVICE_TYPE_NONE() {
        return AV_HWDEVICE_TYPE_NONE;
    }
    private static final int AV_HWDEVICE_TYPE_VDPAU = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_VDPAU = 1
     * }
     */
    public static int AV_HWDEVICE_TYPE_VDPAU() {
        return AV_HWDEVICE_TYPE_VDPAU;
    }
    private static final int AV_HWDEVICE_TYPE_CUDA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_CUDA = 2
     * }
     */
    public static int AV_HWDEVICE_TYPE_CUDA() {
        return AV_HWDEVICE_TYPE_CUDA;
    }
    private static final int AV_HWDEVICE_TYPE_VAAPI = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_VAAPI = 3
     * }
     */
    public static int AV_HWDEVICE_TYPE_VAAPI() {
        return AV_HWDEVICE_TYPE_VAAPI;
    }
    private static final int AV_HWDEVICE_TYPE_DXVA2 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_DXVA2 = 4
     * }
     */
    public static int AV_HWDEVICE_TYPE_DXVA2() {
        return AV_HWDEVICE_TYPE_DXVA2;
    }
    private static final int AV_HWDEVICE_TYPE_QSV = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_QSV = 5
     * }
     */
    public static int AV_HWDEVICE_TYPE_QSV() {
        return AV_HWDEVICE_TYPE_QSV;
    }
    private static final int AV_HWDEVICE_TYPE_VIDEOTOOLBOX = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_VIDEOTOOLBOX = 6
     * }
     */
    public static int AV_HWDEVICE_TYPE_VIDEOTOOLBOX() {
        return AV_HWDEVICE_TYPE_VIDEOTOOLBOX;
    }
    private static final int AV_HWDEVICE_TYPE_D3D11VA = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_D3D11VA = 7
     * }
     */
    public static int AV_HWDEVICE_TYPE_D3D11VA() {
        return AV_HWDEVICE_TYPE_D3D11VA;
    }
    private static final int AV_HWDEVICE_TYPE_DRM = (int)8L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_DRM = 8
     * }
     */
    public static int AV_HWDEVICE_TYPE_DRM() {
        return AV_HWDEVICE_TYPE_DRM;
    }
    private static final int AV_HWDEVICE_TYPE_OPENCL = (int)9L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_OPENCL = 9
     * }
     */
    public static int AV_HWDEVICE_TYPE_OPENCL() {
        return AV_HWDEVICE_TYPE_OPENCL;
    }
    private static final int AV_HWDEVICE_TYPE_MEDIACODEC = (int)10L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_MEDIACODEC = 10
     * }
     */
    public static int AV_HWDEVICE_TYPE_MEDIACODEC() {
        return AV_HWDEVICE_TYPE_MEDIACODEC;
    }
    private static final int AV_HWDEVICE_TYPE_VULKAN = (int)11L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_VULKAN = 11
     * }
     */
    public static int AV_HWDEVICE_TYPE_VULKAN() {
        return AV_HWDEVICE_TYPE_VULKAN;
    }
    private static final int AV_HWDEVICE_TYPE_D3D12VA = (int)12L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_D3D12VA = 12
     * }
     */
    public static int AV_HWDEVICE_TYPE_D3D12VA() {
        return AV_HWDEVICE_TYPE_D3D12VA;
    }
    private static final int AV_HWDEVICE_TYPE_AMF = (int)13L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_AMF = 13
     * }
     */
    public static int AV_HWDEVICE_TYPE_AMF() {
        return AV_HWDEVICE_TYPE_AMF;
    }
    private static final int AV_HWDEVICE_TYPE_OHCODEC = (int)14L;
    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType.AV_HWDEVICE_TYPE_OHCODEC = 14
     * }
     */
    public static int AV_HWDEVICE_TYPE_OHCODEC() {
        return AV_HWDEVICE_TYPE_OHCODEC;
    }

    private static class av_hwdevice_find_type_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_find_type_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_hwdevice_find_type_by_name$descriptor() {
        return av_hwdevice_find_type_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name)
     * }
     */
    public static MethodHandle av_hwdevice_find_type_by_name$handle() {
        return av_hwdevice_find_type_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name)
     * }
     */
    public static MemorySegment av_hwdevice_find_type_by_name$address() {
        return av_hwdevice_find_type_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_find_type_by_name(const char *name)
     * }
     */
    public static int av_hwdevice_find_type_by_name(MemorySegment name) {
        var mh$ = av_hwdevice_find_type_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_find_type_by_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_get_type_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_get_type_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_hwdevice_get_type_name(enum AVHWDeviceType type)
     * }
     */
    public static FunctionDescriptor av_hwdevice_get_type_name$descriptor() {
        return av_hwdevice_get_type_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_hwdevice_get_type_name(enum AVHWDeviceType type)
     * }
     */
    public static MethodHandle av_hwdevice_get_type_name$handle() {
        return av_hwdevice_get_type_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_hwdevice_get_type_name(enum AVHWDeviceType type)
     * }
     */
    public static MemorySegment av_hwdevice_get_type_name$address() {
        return av_hwdevice_get_type_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_hwdevice_get_type_name(enum AVHWDeviceType type)
     * }
     */
    public static MemorySegment av_hwdevice_get_type_name(int type) {
        var mh$ = av_hwdevice_get_type_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_get_type_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_iterate_types {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_iterate_types");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)
     * }
     */
    public static FunctionDescriptor av_hwdevice_iterate_types$descriptor() {
        return av_hwdevice_iterate_types.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)
     * }
     */
    public static MethodHandle av_hwdevice_iterate_types$handle() {
        return av_hwdevice_iterate_types.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)
     * }
     */
    public static MemorySegment av_hwdevice_iterate_types$address() {
        return av_hwdevice_iterate_types.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVHWDeviceType av_hwdevice_iterate_types(enum AVHWDeviceType prev)
     * }
     */
    public static int av_hwdevice_iterate_types(int prev) {
        var mh$ = av_hwdevice_iterate_types.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_iterate_types", prev);
            }
            return (int)mh$.invokeExact(prev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_ctx_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_alloc$descriptor() {
        return av_hwdevice_ctx_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_alloc$handle() {
        return av_hwdevice_ctx_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_alloc$address() {
        return av_hwdevice_ctx_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_hwdevice_ctx_alloc(enum AVHWDeviceType type)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_alloc(int type) {
        var mh$ = av_hwdevice_ctx_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_alloc", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_ctx_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_init$descriptor() {
        return av_hwdevice_ctx_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_init$handle() {
        return av_hwdevice_ctx_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_init$address() {
        return av_hwdevice_ctx_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_init(AVBufferRef *ref)
     * }
     */
    public static int av_hwdevice_ctx_init(MemorySegment ref) {
        var mh$ = av_hwdevice_ctx_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_init", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_ctx_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_create$descriptor() {
        return av_hwdevice_ctx_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_create$handle() {
        return av_hwdevice_ctx_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_create$address() {
        return av_hwdevice_ctx_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create(AVBufferRef **device_ctx, enum AVHWDeviceType type, const char *device, AVDictionary *opts, int flags)
     * }
     */
    public static int av_hwdevice_ctx_create(MemorySegment device_ctx, int type, MemorySegment device, MemorySegment opts, int flags) {
        var mh$ = av_hwdevice_ctx_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_create", device_ctx, type, device, opts, flags);
            }
            return (int)mh$.invokeExact(device_ctx, type, device, opts, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_create_derived {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_ctx_create_derived");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_create_derived$descriptor() {
        return av_hwdevice_ctx_create_derived.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_create_derived$handle() {
        return av_hwdevice_ctx_create_derived.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_create_derived$address() {
        return av_hwdevice_ctx_create_derived.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, int flags)
     * }
     */
    public static int av_hwdevice_ctx_create_derived(MemorySegment dst_ctx, int type, MemorySegment src_ctx, int flags) {
        var mh$ = av_hwdevice_ctx_create_derived.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_create_derived", dst_ctx, type, src_ctx, flags);
            }
            return (int)mh$.invokeExact(dst_ctx, type, src_ctx, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_ctx_create_derived_opts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_ctx_create_derived_opts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static FunctionDescriptor av_hwdevice_ctx_create_derived_opts$descriptor() {
        return av_hwdevice_ctx_create_derived_opts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static MethodHandle av_hwdevice_ctx_create_derived_opts$handle() {
        return av_hwdevice_ctx_create_derived_opts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static MemorySegment av_hwdevice_ctx_create_derived_opts$address() {
        return av_hwdevice_ctx_create_derived_opts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwdevice_ctx_create_derived_opts(AVBufferRef **dst_ctx, enum AVHWDeviceType type, AVBufferRef *src_ctx, AVDictionary *options, int flags)
     * }
     */
    public static int av_hwdevice_ctx_create_derived_opts(MemorySegment dst_ctx, int type, MemorySegment src_ctx, MemorySegment options, int flags) {
        var mh$ = av_hwdevice_ctx_create_derived_opts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_ctx_create_derived_opts", dst_ctx, type, src_ctx, options, flags);
            }
            return (int)mh$.invokeExact(dst_ctx, type, src_ctx, options, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_ctx_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_ctx_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static FunctionDescriptor av_hwframe_ctx_alloc$descriptor() {
        return av_hwframe_ctx_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MethodHandle av_hwframe_ctx_alloc$handle() {
        return av_hwframe_ctx_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwframe_ctx_alloc$address() {
        return av_hwframe_ctx_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_hwframe_ctx_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwframe_ctx_alloc(MemorySegment device_ctx) {
        var mh$ = av_hwframe_ctx_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_ctx_alloc", device_ctx);
            }
            return (MemorySegment)mh$.invokeExact(device_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_ctx_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_ctx_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static FunctionDescriptor av_hwframe_ctx_init$descriptor() {
        return av_hwframe_ctx_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MethodHandle av_hwframe_ctx_init$handle() {
        return av_hwframe_ctx_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static MemorySegment av_hwframe_ctx_init$address() {
        return av_hwframe_ctx_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_ctx_init(AVBufferRef *ref)
     * }
     */
    public static int av_hwframe_ctx_init(MemorySegment ref) {
        var mh$ = av_hwframe_ctx_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_ctx_init", ref);
            }
            return (int)mh$.invokeExact(ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_get_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_get_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_get_buffer$descriptor() {
        return av_hwframe_get_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_hwframe_get_buffer$handle() {
        return av_hwframe_get_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment av_hwframe_get_buffer$address() {
        return av_hwframe_get_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_get_buffer(AVBufferRef *hwframe_ctx, AVFrame *frame, int flags)
     * }
     */
    public static int av_hwframe_get_buffer(MemorySegment hwframe_ctx, MemorySegment frame, int flags) {
        var mh$ = av_hwframe_get_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_get_buffer", hwframe_ctx, frame, flags);
            }
            return (int)mh$.invokeExact(hwframe_ctx, frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_transfer_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_transfer_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_transfer_data$descriptor() {
        return av_hwframe_transfer_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MethodHandle av_hwframe_transfer_data$handle() {
        return av_hwframe_transfer_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MemorySegment av_hwframe_transfer_data$address() {
        return av_hwframe_transfer_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_transfer_data(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static int av_hwframe_transfer_data(MemorySegment dst, MemorySegment src, int flags) {
        var mh$ = av_hwframe_transfer_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_transfer_data", dst, src, flags);
            }
            return (int)mh$.invokeExact(dst, src, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_HWFRAME_TRANSFER_DIRECTION_FROM = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVHWFrameTransferDirection.AV_HWFRAME_TRANSFER_DIRECTION_FROM = 0
     * }
     */
    public static int AV_HWFRAME_TRANSFER_DIRECTION_FROM() {
        return AV_HWFRAME_TRANSFER_DIRECTION_FROM;
    }
    private static final int AV_HWFRAME_TRANSFER_DIRECTION_TO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVHWFrameTransferDirection.AV_HWFRAME_TRANSFER_DIRECTION_TO = 1
     * }
     */
    public static int AV_HWFRAME_TRANSFER_DIRECTION_TO() {
        return AV_HWFRAME_TRANSFER_DIRECTION_TO;
    }

    private static class av_hwframe_transfer_get_formats {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_transfer_get_formats");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_transfer_get_formats$descriptor() {
        return av_hwframe_transfer_get_formats.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static MethodHandle av_hwframe_transfer_get_formats$handle() {
        return av_hwframe_transfer_get_formats.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static MemorySegment av_hwframe_transfer_get_formats$address() {
        return av_hwframe_transfer_get_formats.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_transfer_get_formats(AVBufferRef *hwframe_ctx, enum AVHWFrameTransferDirection dir, enum AVPixelFormat **formats, int flags)
     * }
     */
    public static int av_hwframe_transfer_get_formats(MemorySegment hwframe_ctx, int dir, MemorySegment formats, int flags) {
        var mh$ = av_hwframe_transfer_get_formats.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_transfer_get_formats", hwframe_ctx, dir, formats, flags);
            }
            return (int)mh$.invokeExact(hwframe_ctx, dir, formats, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_hwconfig_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_hwconfig_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static FunctionDescriptor av_hwdevice_hwconfig_alloc$descriptor() {
        return av_hwdevice_hwconfig_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MethodHandle av_hwdevice_hwconfig_alloc$handle() {
        return av_hwdevice_hwconfig_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwdevice_hwconfig_alloc$address() {
        return av_hwdevice_hwconfig_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void *av_hwdevice_hwconfig_alloc(AVBufferRef *device_ctx)
     * }
     */
    public static MemorySegment av_hwdevice_hwconfig_alloc(MemorySegment device_ctx) {
        var mh$ = av_hwdevice_hwconfig_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_hwconfig_alloc", device_ctx);
            }
            return (MemorySegment)mh$.invokeExact(device_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwdevice_get_hwframe_constraints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwdevice_get_hwframe_constraints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static FunctionDescriptor av_hwdevice_get_hwframe_constraints$descriptor() {
        return av_hwdevice_get_hwframe_constraints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static MethodHandle av_hwdevice_get_hwframe_constraints$handle() {
        return av_hwdevice_get_hwframe_constraints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static MemorySegment av_hwdevice_get_hwframe_constraints$address() {
        return av_hwdevice_get_hwframe_constraints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVHWFramesConstraints *av_hwdevice_get_hwframe_constraints(AVBufferRef *ref, const void *hwconfig)
     * }
     */
    public static MemorySegment av_hwdevice_get_hwframe_constraints(MemorySegment ref, MemorySegment hwconfig) {
        var mh$ = av_hwdevice_get_hwframe_constraints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwdevice_get_hwframe_constraints", ref, hwconfig);
            }
            return (MemorySegment)mh$.invokeExact(ref, hwconfig);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_constraints_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_constraints_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static FunctionDescriptor av_hwframe_constraints_free$descriptor() {
        return av_hwframe_constraints_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static MethodHandle av_hwframe_constraints_free$handle() {
        return av_hwframe_constraints_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static MemorySegment av_hwframe_constraints_free$address() {
        return av_hwframe_constraints_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hwframe_constraints_free(AVHWFramesConstraints **constraints)
     * }
     */
    public static void av_hwframe_constraints_free(MemorySegment constraints) {
        var mh$ = av_hwframe_constraints_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_constraints_free", constraints);
            }
            mh$.invokeExact(constraints);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_HWFRAME_MAP_READ = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_READ = 1
     * }
     */
    public static int AV_HWFRAME_MAP_READ() {
        return AV_HWFRAME_MAP_READ;
    }
    private static final int AV_HWFRAME_MAP_WRITE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_WRITE = 2
     * }
     */
    public static int AV_HWFRAME_MAP_WRITE() {
        return AV_HWFRAME_MAP_WRITE;
    }
    private static final int AV_HWFRAME_MAP_OVERWRITE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_OVERWRITE = 4
     * }
     */
    public static int AV_HWFRAME_MAP_OVERWRITE() {
        return AV_HWFRAME_MAP_OVERWRITE;
    }
    private static final int AV_HWFRAME_MAP_DIRECT = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_HWFRAME_MAP_DIRECT = 8
     * }
     */
    public static int AV_HWFRAME_MAP_DIRECT() {
        return AV_HWFRAME_MAP_DIRECT;
    }

    private static class av_hwframe_map {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_map");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_map$descriptor() {
        return av_hwframe_map.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MethodHandle av_hwframe_map$handle() {
        return av_hwframe_map.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static MemorySegment av_hwframe_map$address() {
        return av_hwframe_map.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_map(AVFrame *dst, const AVFrame *src, int flags)
     * }
     */
    public static int av_hwframe_map(MemorySegment dst, MemorySegment src, int flags) {
        var mh$ = av_hwframe_map.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_map", dst, src, flags);
            }
            return (int)mh$.invokeExact(dst, src, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hwframe_ctx_create_derived {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hwframe_ctx_create_derived");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static FunctionDescriptor av_hwframe_ctx_create_derived$descriptor() {
        return av_hwframe_ctx_create_derived.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static MethodHandle av_hwframe_ctx_create_derived$handle() {
        return av_hwframe_ctx_create_derived.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static MemorySegment av_hwframe_ctx_create_derived$address() {
        return av_hwframe_ctx_create_derived.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_hwframe_ctx_create_derived(AVBufferRef **derived_frame_ctx, enum AVPixelFormat format, AVBufferRef *derived_device_ctx, AVBufferRef *source_frame_ctx, int flags)
     * }
     */
    public static int av_hwframe_ctx_create_derived(MemorySegment derived_frame_ctx, int format, MemorySegment derived_device_ctx, MemorySegment source_frame_ctx, int flags) {
        var mh$ = av_hwframe_ctx_create_derived.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hwframe_ctx_create_derived", derived_frame_ctx, format, derived_device_ctx, source_frame_ctx, flags);
            }
            return (int)mh$.invokeExact(derived_frame_ctx, format, derived_device_ctx, source_frame_ctx, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_codec_iterate$descriptor() {
        return av_codec_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_codec_iterate$handle() {
        return av_codec_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_codec_iterate$address() {
        return av_codec_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *av_codec_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_codec_iterate(MemorySegment opaque) {
        var mh$ = av_codec_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_find_decoder$descriptor() {
        return avcodec_find_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_find_decoder$handle() {
        return avcodec_find_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_decoder$address() {
        return avcodec_find_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_decoder(int id) {
        var mh$ = avcodec_find_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_decoder", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_decoder_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_decoder_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_find_decoder_by_name$descriptor() {
        return avcodec_find_decoder_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_find_decoder_by_name$handle() {
        return avcodec_find_decoder_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_decoder_by_name$address() {
        return avcodec_find_decoder_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_decoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_decoder_by_name(MemorySegment name) {
        var mh$ = avcodec_find_decoder_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_decoder_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_find_encoder$descriptor() {
        return avcodec_find_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_find_encoder$handle() {
        return avcodec_find_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_encoder$address() {
        return avcodec_find_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_find_encoder(int id) {
        var mh$ = avcodec_find_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_encoder", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_encoder_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_encoder_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_find_encoder_by_name$descriptor() {
        return avcodec_find_encoder_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_find_encoder_by_name$handle() {
        return avcodec_find_encoder_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_encoder_by_name$address() {
        return avcodec_find_encoder_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodec *avcodec_find_encoder_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_find_encoder_by_name(MemorySegment name) {
        var mh$ = avcodec_find_encoder_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_encoder_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_is_encoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_is_encoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor av_codec_is_encoder$descriptor() {
        return av_codec_is_encoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static MethodHandle av_codec_is_encoder$handle() {
        return av_codec_is_encoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static MemorySegment av_codec_is_encoder$address() {
        return av_codec_is_encoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_is_encoder(const AVCodec *codec)
     * }
     */
    public static int av_codec_is_encoder(MemorySegment codec) {
        var mh$ = av_codec_is_encoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_is_encoder", codec);
            }
            return (int)mh$.invokeExact(codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_is_decoder {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_is_decoder");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor av_codec_is_decoder$descriptor() {
        return av_codec_is_decoder.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static MethodHandle av_codec_is_decoder$handle() {
        return av_codec_is_decoder.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static MemorySegment av_codec_is_decoder$address() {
        return av_codec_is_decoder.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_is_decoder(const AVCodec *codec)
     * }
     */
    public static int av_codec_is_decoder(MemorySegment codec) {
        var mh$ = av_codec_is_decoder.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_is_decoder", codec);
            }
            return (int)mh$.invokeExact(codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_profile_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_profile_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static FunctionDescriptor av_get_profile_name$descriptor() {
        return av_get_profile_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MethodHandle av_get_profile_name$handle() {
        return av_get_profile_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MemorySegment av_get_profile_name$address() {
        return av_get_profile_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_profile_name(const AVCodec *codec, int profile)
     * }
     */
    public static MemorySegment av_get_profile_name(MemorySegment codec, int profile) {
        var mh$ = av_get_profile_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_profile_name", codec, profile);
            }
            return (MemorySegment)mh$.invokeExact(codec, profile);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX = 1
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX() {
        return AV_CODEC_HW_CONFIG_METHOD_HW_DEVICE_CTX;
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX = 2
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX() {
        return AV_CODEC_HW_CONFIG_METHOD_HW_FRAMES_CTX;
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_INTERNAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_INTERNAL = 4
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_INTERNAL() {
        return AV_CODEC_HW_CONFIG_METHOD_INTERNAL;
    }
    private static final int AV_CODEC_HW_CONFIG_METHOD_AD_HOC = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_CODEC_HW_CONFIG_METHOD_AD_HOC = 8
     * }
     */
    public static int AV_CODEC_HW_CONFIG_METHOD_AD_HOC() {
        return AV_CODEC_HW_CONFIG_METHOD_AD_HOC;
    }

    private static class avcodec_get_hw_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_hw_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static FunctionDescriptor avcodec_get_hw_config$descriptor() {
        return avcodec_get_hw_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MethodHandle avcodec_get_hw_config$handle() {
        return avcodec_get_hw_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MemorySegment avcodec_get_hw_config$address() {
        return avcodec_get_hw_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecHWConfig *avcodec_get_hw_config(const AVCodec *codec, int index)
     * }
     */
    public static MemorySegment avcodec_get_hw_config(MemorySegment codec, int index) {
        var mh$ = avcodec_get_hw_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_hw_config", codec, index);
            }
            return (MemorySegment)mh$.invokeExact(codec, index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_get_packet$descriptor() {
        return av_get_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_get_packet$handle() {
        return av_get_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_get_packet$address() {
        return av_get_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static int av_get_packet(MemorySegment s, MemorySegment pkt, int size) {
        var mh$ = av_get_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_packet", s, pkt, size);
            }
            return (int)mh$.invokeExact(s, pkt, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_append_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_append_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static FunctionDescriptor av_append_packet$descriptor() {
        return av_append_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MethodHandle av_append_packet$handle() {
        return av_append_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static MemorySegment av_append_packet$address() {
        return av_append_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_append_packet(AVIOContext *s, AVPacket *pkt, int size)
     * }
     */
    public static int av_append_packet(MemorySegment s, MemorySegment pkt, int size) {
        var mh$ = av_append_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_append_packet", s, pkt, size);
            }
            return (int)mh$.invokeExact(s, pkt, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVSTREAM_PARSE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_NONE = 0
     * }
     */
    public static int AVSTREAM_PARSE_NONE() {
        return AVSTREAM_PARSE_NONE;
    }
    private static final int AVSTREAM_PARSE_FULL = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_FULL = 1
     * }
     */
    public static int AVSTREAM_PARSE_FULL() {
        return AVSTREAM_PARSE_FULL;
    }
    private static final int AVSTREAM_PARSE_HEADERS = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_HEADERS = 2
     * }
     */
    public static int AVSTREAM_PARSE_HEADERS() {
        return AVSTREAM_PARSE_HEADERS;
    }
    private static final int AVSTREAM_PARSE_TIMESTAMPS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_TIMESTAMPS = 3
     * }
     */
    public static int AVSTREAM_PARSE_TIMESTAMPS() {
        return AVSTREAM_PARSE_TIMESTAMPS;
    }
    private static final int AVSTREAM_PARSE_FULL_ONCE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_FULL_ONCE = 4
     * }
     */
    public static int AVSTREAM_PARSE_FULL_ONCE() {
        return AVSTREAM_PARSE_FULL_ONCE;
    }
    private static final int AVSTREAM_PARSE_FULL_RAW = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVStreamParseType.AVSTREAM_PARSE_FULL_RAW = 5
     * }
     */
    public static int AVSTREAM_PARSE_FULL_RAW() {
        return AVSTREAM_PARSE_FULL_RAW;
    }

    private static class av_disposition_from_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_disposition_from_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static FunctionDescriptor av_disposition_from_string$descriptor() {
        return av_disposition_from_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static MethodHandle av_disposition_from_string$handle() {
        return av_disposition_from_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static MemorySegment av_disposition_from_string$address() {
        return av_disposition_from_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_disposition_from_string(const char *disp)
     * }
     */
    public static int av_disposition_from_string(MemorySegment disp) {
        var mh$ = av_disposition_from_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_disposition_from_string", disp);
            }
            return (int)mh$.invokeExact(disp);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_disposition_to_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_disposition_to_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static FunctionDescriptor av_disposition_to_string$descriptor() {
        return av_disposition_to_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MethodHandle av_disposition_to_string$handle() {
        return av_disposition_to_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MemorySegment av_disposition_to_string$address() {
        return av_disposition_to_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_disposition_to_string(int disposition)
     * }
     */
    public static MemorySegment av_disposition_to_string(int disposition) {
        var mh$ = av_disposition_to_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_disposition_to_string", disposition);
            }
            return (MemorySegment)mh$.invokeExact(disposition);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_STREAM_GROUP_PARAMS_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVStreamGroupParamsType.AV_STREAM_GROUP_PARAMS_NONE = 0
     * }
     */
    public static int AV_STREAM_GROUP_PARAMS_NONE() {
        return AV_STREAM_GROUP_PARAMS_NONE;
    }
    private static final int AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVStreamGroupParamsType.AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT = 1
     * }
     */
    public static int AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT() {
        return AV_STREAM_GROUP_PARAMS_IAMF_AUDIO_ELEMENT;
    }
    private static final int AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVStreamGroupParamsType.AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION = 2
     * }
     */
    public static int AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION() {
        return AV_STREAM_GROUP_PARAMS_IAMF_MIX_PRESENTATION;
    }
    private static final int AV_STREAM_GROUP_PARAMS_TILE_GRID = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVStreamGroupParamsType.AV_STREAM_GROUP_PARAMS_TILE_GRID = 3
     * }
     */
    public static int AV_STREAM_GROUP_PARAMS_TILE_GRID() {
        return AV_STREAM_GROUP_PARAMS_TILE_GRID;
    }
    private static final int AV_STREAM_GROUP_PARAMS_LCEVC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVStreamGroupParamsType.AV_STREAM_GROUP_PARAMS_LCEVC = 4
     * }
     */
    public static int AV_STREAM_GROUP_PARAMS_LCEVC() {
        return AV_STREAM_GROUP_PARAMS_LCEVC;
    }

    private static class av_stream_get_parser {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_get_parser");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static FunctionDescriptor av_stream_get_parser$descriptor() {
        return av_stream_get_parser.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MethodHandle av_stream_get_parser$handle() {
        return av_stream_get_parser.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MemorySegment av_stream_get_parser$address() {
        return av_stream_get_parser.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct AVCodecParserContext *av_stream_get_parser(const AVStream *s)
     * }
     */
    public static MemorySegment av_stream_get_parser(MemorySegment s) {
        var mh$ = av_stream_get_parser.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_parser", s);
            }
            return (MemorySegment)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_first_dts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_get_first_dts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int64_t av_stream_get_first_dts(const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_stream_get_first_dts$descriptor() {
        return av_stream_get_first_dts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int64_t av_stream_get_first_dts(const AVStream *st)
     * }
     */
    public static MethodHandle av_stream_get_first_dts$handle() {
        return av_stream_get_first_dts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int64_t av_stream_get_first_dts(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_first_dts$address() {
        return av_stream_get_first_dts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int64_t av_stream_get_first_dts(const AVStream *st)
     * }
     */
    public static long av_stream_get_first_dts(MemorySegment st) {
        var mh$ = av_stream_get_first_dts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_first_dts", st);
            }
            return (long)mh$.invokeExact(st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVFMT_DURATION_FROM_PTS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod.AVFMT_DURATION_FROM_PTS = 0
     * }
     */
    public static int AVFMT_DURATION_FROM_PTS() {
        return AVFMT_DURATION_FROM_PTS;
    }
    private static final int AVFMT_DURATION_FROM_STREAM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod.AVFMT_DURATION_FROM_STREAM = 1
     * }
     */
    public static int AVFMT_DURATION_FROM_STREAM() {
        return AVFMT_DURATION_FROM_STREAM;
    }
    private static final int AVFMT_DURATION_FROM_BITRATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVDurationEstimationMethod.AVFMT_DURATION_FROM_BITRATE = 2
     * }
     */
    public static int AVFMT_DURATION_FROM_BITRATE() {
        return AVFMT_DURATION_FROM_BITRATE;
    }

    private static class avformat_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static FunctionDescriptor avformat_version$descriptor() {
        return avformat_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static MethodHandle avformat_version$handle() {
        return avformat_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static MemorySegment avformat_version$address() {
        return avformat_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avformat_version()
     * }
     */
    public static int avformat_version() {
        var mh$ = avformat_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static FunctionDescriptor avformat_configuration$descriptor() {
        return avformat_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MethodHandle avformat_configuration$handle() {
        return avformat_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MemorySegment avformat_configuration$address() {
        return avformat_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_configuration()
     * }
     */
    public static MemorySegment avformat_configuration() {
        var mh$ = avformat_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static FunctionDescriptor avformat_license$descriptor() {
        return avformat_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MethodHandle avformat_license$handle() {
        return avformat_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MemorySegment avformat_license$address() {
        return avformat_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_license()
     * }
     */
    public static MemorySegment avformat_license() {
        var mh$ = avformat_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_network_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_network_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static FunctionDescriptor avformat_network_init$descriptor() {
        return avformat_network_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static MethodHandle avformat_network_init$handle() {
        return avformat_network_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static MemorySegment avformat_network_init$address() {
        return avformat_network_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_network_init()
     * }
     */
    public static int avformat_network_init() {
        var mh$ = avformat_network_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_network_init");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_network_deinit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_network_deinit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static FunctionDescriptor avformat_network_deinit$descriptor() {
        return avformat_network_deinit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static MethodHandle avformat_network_deinit$handle() {
        return avformat_network_deinit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static MemorySegment avformat_network_deinit$address() {
        return avformat_network_deinit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_network_deinit()
     * }
     */
    public static int avformat_network_deinit() {
        var mh$ = avformat_network_deinit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_network_deinit");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_muxer_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_muxer_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_muxer_iterate$descriptor() {
        return av_muxer_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_muxer_iterate$handle() {
        return av_muxer_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_muxer_iterate$address() {
        return av_muxer_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVOutputFormat *av_muxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_muxer_iterate(MemorySegment opaque) {
        var mh$ = av_muxer_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_muxer_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_demuxer_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_demuxer_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_demuxer_iterate$descriptor() {
        return av_demuxer_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_demuxer_iterate$handle() {
        return av_demuxer_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_demuxer_iterate$address() {
        return av_demuxer_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_demuxer_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_demuxer_iterate(MemorySegment opaque) {
        var mh$ = av_demuxer_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_demuxer_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static FunctionDescriptor avformat_alloc_context$descriptor() {
        return avformat_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MethodHandle avformat_alloc_context$handle() {
        return avformat_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MemorySegment avformat_alloc_context$address() {
        return avformat_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFormatContext *avformat_alloc_context()
     * }
     */
    public static MemorySegment avformat_alloc_context() {
        var mh$ = avformat_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_alloc_context");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_free_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_free_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_free_context$descriptor() {
        return avformat_free_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_free_context$handle() {
        return avformat_free_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_free_context$address() {
        return avformat_free_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avformat_free_context(AVFormatContext *s)
     * }
     */
    public static void avformat_free_context(MemorySegment s) {
        var mh$ = avformat_free_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_free_context", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static FunctionDescriptor avformat_get_class$descriptor() {
        return avformat_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MethodHandle avformat_get_class$handle() {
        return avformat_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MemorySegment avformat_get_class$address() {
        return avformat_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avformat_get_class()
     * }
     */
    public static MemorySegment avformat_get_class() {
        var mh$ = avformat_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static FunctionDescriptor av_stream_get_class$descriptor() {
        return av_stream_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MethodHandle av_stream_get_class$handle() {
        return av_stream_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MemorySegment av_stream_get_class$address() {
        return av_stream_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *av_stream_get_class()
     * }
     */
    public static MemorySegment av_stream_get_class() {
        var mh$ = av_stream_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_group_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_group_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static FunctionDescriptor av_stream_group_get_class$descriptor() {
        return av_stream_group_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static MethodHandle av_stream_group_get_class$handle() {
        return av_stream_group_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static MemorySegment av_stream_group_get_class$address() {
        return av_stream_group_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *av_stream_group_get_class()
     * }
     */
    public static MemorySegment av_stream_group_get_class() {
        var mh$ = av_stream_group_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_group_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_stream_group_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_stream_group_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static FunctionDescriptor avformat_stream_group_name$descriptor() {
        return avformat_stream_group_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static MethodHandle avformat_stream_group_name$handle() {
        return avformat_stream_group_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static MemorySegment avformat_stream_group_name$address() {
        return avformat_stream_group_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avformat_stream_group_name(enum AVStreamGroupParamsType type)
     * }
     */
    public static MemorySegment avformat_stream_group_name(int type) {
        var mh$ = avformat_stream_group_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_stream_group_name", type);
            }
            return (MemorySegment)mh$.invokeExact(type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_stream_group_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_stream_group_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_stream_group_create$descriptor() {
        return avformat_stream_group_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_stream_group_create$handle() {
        return avformat_stream_group_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_stream_group_create$address() {
        return avformat_stream_group_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVStreamGroup *avformat_stream_group_create(AVFormatContext *s, enum AVStreamGroupParamsType type, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_stream_group_create(MemorySegment s, int type, MemorySegment options) {
        var mh$ = avformat_stream_group_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_stream_group_create", s, type, options);
            }
            return (MemorySegment)mh$.invokeExact(s, type, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_new_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_new_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static FunctionDescriptor avformat_new_stream$descriptor() {
        return avformat_new_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static MethodHandle avformat_new_stream$handle() {
        return avformat_new_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static MemorySegment avformat_new_stream$address() {
        return avformat_new_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVStream *avformat_new_stream(AVFormatContext *s, const struct AVCodec *c)
     * }
     */
    public static MemorySegment avformat_new_stream(MemorySegment s, MemorySegment c) {
        var mh$ = avformat_new_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_new_stream", s, c);
            }
            return (MemorySegment)mh$.invokeExact(s, c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_stream_group_add_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_stream_group_add_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static FunctionDescriptor avformat_stream_group_add_stream$descriptor() {
        return avformat_stream_group_add_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static MethodHandle avformat_stream_group_add_stream$handle() {
        return avformat_stream_group_add_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static MemorySegment avformat_stream_group_add_stream$address() {
        return avformat_stream_group_add_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_stream_group_add_stream(AVStreamGroup *stg, AVStream *st)
     * }
     */
    public static int avformat_stream_group_add_stream(MemorySegment stg, MemorySegment st) {
        var mh$ = avformat_stream_group_add_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_stream_group_add_stream", stg, st);
            }
            return (int)mh$.invokeExact(stg, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_new_program {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_new_program");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static FunctionDescriptor av_new_program$descriptor() {
        return av_new_program.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MethodHandle av_new_program$handle() {
        return av_new_program.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MemorySegment av_new_program$address() {
        return av_new_program.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVProgram *av_new_program(AVFormatContext *s, int id)
     * }
     */
    public static MemorySegment av_new_program(MemorySegment s, int id) {
        var mh$ = av_new_program.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_new_program", s, id);
            }
            return (MemorySegment)mh$.invokeExact(s, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_alloc_output_context2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_alloc_output_context2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static FunctionDescriptor avformat_alloc_output_context2$descriptor() {
        return avformat_alloc_output_context2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static MethodHandle avformat_alloc_output_context2$handle() {
        return avformat_alloc_output_context2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static MemorySegment avformat_alloc_output_context2$address() {
        return avformat_alloc_output_context2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_alloc_output_context2(AVFormatContext **ctx, const AVOutputFormat *oformat, const char *format_name, const char *filename)
     * }
     */
    public static int avformat_alloc_output_context2(MemorySegment ctx, MemorySegment oformat, MemorySegment format_name, MemorySegment filename) {
        var mh$ = avformat_alloc_output_context2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_alloc_output_context2", ctx, oformat, format_name, filename);
            }
            return (int)mh$.invokeExact(ctx, oformat, format_name, filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_input_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_input_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static FunctionDescriptor av_find_input_format$descriptor() {
        return av_find_input_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MethodHandle av_find_input_format$handle() {
        return av_find_input_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MemorySegment av_find_input_format$address() {
        return av_find_input_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_find_input_format(const char *short_name)
     * }
     */
    public static MemorySegment av_find_input_format(MemorySegment short_name) {
        var mh$ = av_find_input_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_input_format", short_name);
            }
            return (MemorySegment)mh$.invokeExact(short_name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static FunctionDescriptor av_probe_input_format$descriptor() {
        return av_probe_input_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MethodHandle av_probe_input_format$handle() {
        return av_probe_input_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MemorySegment av_probe_input_format$address() {
        return av_probe_input_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format(const AVProbeData *pd, int is_opened)
     * }
     */
    public static MemorySegment av_probe_input_format(MemorySegment pd, int is_opened) {
        var mh$ = av_probe_input_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format", pd, is_opened);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_format2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static FunctionDescriptor av_probe_input_format2$descriptor() {
        return av_probe_input_format2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MethodHandle av_probe_input_format2$handle() {
        return av_probe_input_format2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MemorySegment av_probe_input_format2$address() {
        return av_probe_input_format2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format2(const AVProbeData *pd, int is_opened, int *score_max)
     * }
     */
    public static MemorySegment av_probe_input_format2(MemorySegment pd, int is_opened, MemorySegment score_max) {
        var mh$ = av_probe_input_format2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format2", pd, is_opened, score_max);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened, score_max);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_format3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_format3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static FunctionDescriptor av_probe_input_format3$descriptor() {
        return av_probe_input_format3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MethodHandle av_probe_input_format3$handle() {
        return av_probe_input_format3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MemorySegment av_probe_input_format3$address() {
        return av_probe_input_format3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVInputFormat *av_probe_input_format3(const AVProbeData *pd, int is_opened, int *score_ret)
     * }
     */
    public static MemorySegment av_probe_input_format3(MemorySegment pd, int is_opened, MemorySegment score_ret) {
        var mh$ = av_probe_input_format3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_format3", pd, is_opened, score_ret);
            }
            return (MemorySegment)mh$.invokeExact(pd, is_opened, score_ret);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_buffer2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_buffer2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static FunctionDescriptor av_probe_input_buffer2$descriptor() {
        return av_probe_input_buffer2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MethodHandle av_probe_input_buffer2$handle() {
        return av_probe_input_buffer2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MemorySegment av_probe_input_buffer2$address() {
        return av_probe_input_buffer2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_probe_input_buffer2(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static int av_probe_input_buffer2(MemorySegment pb, MemorySegment fmt, MemorySegment url, MemorySegment logctx, int offset, int max_probe_size) {
        var mh$ = av_probe_input_buffer2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_buffer2", pb, fmt, url, logctx, offset, max_probe_size);
            }
            return (int)mh$.invokeExact(pb, fmt, url, logctx, offset, max_probe_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_probe_input_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_probe_input_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static FunctionDescriptor av_probe_input_buffer$descriptor() {
        return av_probe_input_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MethodHandle av_probe_input_buffer$handle() {
        return av_probe_input_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static MemorySegment av_probe_input_buffer$address() {
        return av_probe_input_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_probe_input_buffer(AVIOContext *pb, const AVInputFormat **fmt, const char *url, void *logctx, unsigned int offset, unsigned int max_probe_size)
     * }
     */
    public static int av_probe_input_buffer(MemorySegment pb, MemorySegment fmt, MemorySegment url, MemorySegment logctx, int offset, int max_probe_size) {
        var mh$ = av_probe_input_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_probe_input_buffer", pb, fmt, url, logctx, offset, max_probe_size);
            }
            return (int)mh$.invokeExact(pb, fmt, url, logctx, offset, max_probe_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_open_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_open_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_open_input$descriptor() {
        return avformat_open_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_open_input$handle() {
        return avformat_open_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_open_input$address() {
        return avformat_open_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_open_input(AVFormatContext **ps, const char *url, const AVInputFormat *fmt, AVDictionary **options)
     * }
     */
    public static int avformat_open_input(MemorySegment ps, MemorySegment url, MemorySegment fmt, MemorySegment options) {
        var mh$ = avformat_open_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_open_input", ps, url, fmt, options);
            }
            return (int)mh$.invokeExact(ps, url, fmt, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_find_stream_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_find_stream_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_find_stream_info$descriptor() {
        return avformat_find_stream_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_find_stream_info$handle() {
        return avformat_find_stream_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_find_stream_info$address() {
        return avformat_find_stream_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_find_stream_info(AVFormatContext *ic, AVDictionary **options)
     * }
     */
    public static int avformat_find_stream_info(MemorySegment ic, MemorySegment options) {
        var mh$ = avformat_find_stream_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_find_stream_info", ic, options);
            }
            return (int)mh$.invokeExact(ic, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_program_from_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_program_from_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static FunctionDescriptor av_find_program_from_stream$descriptor() {
        return av_find_program_from_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MethodHandle av_find_program_from_stream$handle() {
        return av_find_program_from_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MemorySegment av_find_program_from_stream$address() {
        return av_find_program_from_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVProgram *av_find_program_from_stream(AVFormatContext *ic, AVProgram *last, int s)
     * }
     */
    public static MemorySegment av_find_program_from_stream(MemorySegment ic, MemorySegment last, int s) {
        var mh$ = av_find_program_from_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_program_from_stream", ic, last, s);
            }
            return (MemorySegment)mh$.invokeExact(ic, last, s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_program_add_stream_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_program_add_stream_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static FunctionDescriptor av_program_add_stream_index$descriptor() {
        return av_program_add_stream_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static MethodHandle av_program_add_stream_index$handle() {
        return av_program_add_stream_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static MemorySegment av_program_add_stream_index$address() {
        return av_program_add_stream_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_program_add_stream_index(AVFormatContext *ac, int progid, unsigned int idx)
     * }
     */
    public static void av_program_add_stream_index(MemorySegment ac, int progid, int idx) {
        var mh$ = av_program_add_stream_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_program_add_stream_index", ac, progid, idx);
            }
            mh$.invokeExact(ac, progid, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_best_stream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_best_stream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static FunctionDescriptor av_find_best_stream$descriptor() {
        return av_find_best_stream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static MethodHandle av_find_best_stream$handle() {
        return av_find_best_stream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static MemorySegment av_find_best_stream$address() {
        return av_find_best_stream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_best_stream(AVFormatContext *ic, enum AVMediaType type, int wanted_stream_nb, int related_stream, const struct AVCodec **decoder_ret, int flags)
     * }
     */
    public static int av_find_best_stream(MemorySegment ic, int type, int wanted_stream_nb, int related_stream, MemorySegment decoder_ret, int flags) {
        var mh$ = av_find_best_stream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_best_stream", ic, type, wanted_stream_nb, related_stream, decoder_ret, flags);
            }
            return (int)mh$.invokeExact(ic, type, wanted_stream_nb, related_stream, decoder_ret, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_read_frame$descriptor() {
        return av_read_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_read_frame$handle() {
        return av_read_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_read_frame$address() {
        return av_read_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_read_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_read_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_seek_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_seek_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor av_seek_frame$descriptor() {
        return av_seek_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle av_seek_frame$handle() {
        return av_seek_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment av_seek_frame$address() {
        return av_seek_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_seek_frame(AVFormatContext *s, int stream_index, int64_t timestamp, int flags)
     * }
     */
    public static int av_seek_frame(MemorySegment s, int stream_index, long timestamp, int flags) {
        var mh$ = av_seek_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_seek_frame", s, stream_index, timestamp, flags);
            }
            return (int)mh$.invokeExact(s, stream_index, timestamp, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_seek_file {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_seek_file");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static FunctionDescriptor avformat_seek_file$descriptor() {
        return avformat_seek_file.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static MethodHandle avformat_seek_file$handle() {
        return avformat_seek_file.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static MemorySegment avformat_seek_file$address() {
        return avformat_seek_file.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_seek_file(AVFormatContext *s, int stream_index, int64_t min_ts, int64_t ts, int64_t max_ts, int flags)
     * }
     */
    public static int avformat_seek_file(MemorySegment s, int stream_index, long min_ts, long ts, long max_ts, int flags) {
        var mh$ = avformat_seek_file.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_seek_file", s, stream_index, min_ts, ts, max_ts, flags);
            }
            return (int)mh$.invokeExact(s, stream_index, min_ts, ts, max_ts, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_flush$descriptor() {
        return avformat_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_flush$handle() {
        return avformat_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_flush$address() {
        return avformat_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_flush(AVFormatContext *s)
     * }
     */
    public static int avformat_flush(MemorySegment s) {
        var mh$ = avformat_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_flush", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_play {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_play");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_read_play$descriptor() {
        return av_read_play.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_read_play$handle() {
        return av_read_play.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_read_play$address() {
        return av_read_play.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_play(AVFormatContext *s)
     * }
     */
    public static int av_read_play(MemorySegment s) {
        var mh$ = av_read_play.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_play", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_pause {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_pause");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_read_pause$descriptor() {
        return av_read_pause.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_read_pause$handle() {
        return av_read_pause.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_read_pause$address() {
        return av_read_pause.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_read_pause(AVFormatContext *s)
     * }
     */
    public static int av_read_pause(MemorySegment s) {
        var mh$ = av_read_pause.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_pause", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_close_input {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_close_input");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static FunctionDescriptor avformat_close_input$descriptor() {
        return avformat_close_input.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static MethodHandle avformat_close_input$handle() {
        return avformat_close_input.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static MemorySegment avformat_close_input$address() {
        return avformat_close_input.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avformat_close_input(AVFormatContext **s)
     * }
     */
    public static void avformat_close_input(MemorySegment s) {
        var mh$ = avformat_close_input.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_close_input", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_write_header {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_write_header");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_write_header$descriptor() {
        return avformat_write_header.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_write_header$handle() {
        return avformat_write_header.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_write_header$address() {
        return avformat_write_header.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_write_header(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static int avformat_write_header(MemorySegment s, MemorySegment options) {
        var mh$ = avformat_write_header.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_write_header", s, options);
            }
            return (int)mh$.invokeExact(s, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_init_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_init_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avformat_init_output$descriptor() {
        return avformat_init_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MethodHandle avformat_init_output$handle() {
        return avformat_init_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static MemorySegment avformat_init_output$address() {
        return avformat_init_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_init_output(AVFormatContext *s, AVDictionary **options)
     * }
     */
    public static int avformat_init_output(MemorySegment s, MemorySegment options) {
        var mh$ = avformat_init_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_init_output", s, options);
            }
            return (int)mh$.invokeExact(s, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_write_frame$descriptor() {
        return av_write_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_write_frame$handle() {
        return av_write_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_write_frame$address() {
        return av_write_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_write_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_write_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_interleaved_write_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_interleaved_write_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static FunctionDescriptor av_interleaved_write_frame$descriptor() {
        return av_interleaved_write_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MethodHandle av_interleaved_write_frame$handle() {
        return av_interleaved_write_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static MemorySegment av_interleaved_write_frame$address() {
        return av_interleaved_write_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_interleaved_write_frame(AVFormatContext *s, AVPacket *pkt)
     * }
     */
    public static int av_interleaved_write_frame(MemorySegment s, MemorySegment pkt) {
        var mh$ = av_interleaved_write_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_interleaved_write_frame", s, pkt);
            }
            return (int)mh$.invokeExact(s, pkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_uncoded_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_uncoded_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_write_uncoded_frame$descriptor() {
        return av_write_uncoded_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_write_uncoded_frame$handle() {
        return av_write_uncoded_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_write_uncoded_frame$address() {
        return av_write_uncoded_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static int av_write_uncoded_frame(MemorySegment s, int stream_index, MemorySegment frame) {
        var mh$ = av_write_uncoded_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_uncoded_frame", s, stream_index, frame);
            }
            return (int)mh$.invokeExact(s, stream_index, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_interleaved_write_uncoded_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_interleaved_write_uncoded_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_interleaved_write_uncoded_frame$descriptor() {
        return av_interleaved_write_uncoded_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_interleaved_write_uncoded_frame$handle() {
        return av_interleaved_write_uncoded_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_interleaved_write_uncoded_frame$address() {
        return av_interleaved_write_uncoded_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_interleaved_write_uncoded_frame(AVFormatContext *s, int stream_index, struct AVFrame *frame)
     * }
     */
    public static int av_interleaved_write_uncoded_frame(MemorySegment s, int stream_index, MemorySegment frame) {
        var mh$ = av_interleaved_write_uncoded_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_interleaved_write_uncoded_frame", s, stream_index, frame);
            }
            return (int)mh$.invokeExact(s, stream_index, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_uncoded_frame_query {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_uncoded_frame_query");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static FunctionDescriptor av_write_uncoded_frame_query$descriptor() {
        return av_write_uncoded_frame_query.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static MethodHandle av_write_uncoded_frame_query$handle() {
        return av_write_uncoded_frame_query.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static MemorySegment av_write_uncoded_frame_query$address() {
        return av_write_uncoded_frame_query.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_uncoded_frame_query(AVFormatContext *s, int stream_index)
     * }
     */
    public static int av_write_uncoded_frame_query(MemorySegment s, int stream_index) {
        var mh$ = av_write_uncoded_frame_query.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_uncoded_frame_query", s, stream_index);
            }
            return (int)mh$.invokeExact(s, stream_index);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_trailer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_trailer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_write_trailer$descriptor() {
        return av_write_trailer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_write_trailer$handle() {
        return av_write_trailer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_write_trailer$address() {
        return av_write_trailer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_write_trailer(AVFormatContext *s)
     * }
     */
    public static int av_write_trailer(MemorySegment s) {
        var mh$ = av_write_trailer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_trailer", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static FunctionDescriptor av_guess_format$descriptor() {
        return av_guess_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MethodHandle av_guess_format$handle() {
        return av_guess_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MemorySegment av_guess_format$address() {
        return av_guess_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVOutputFormat *av_guess_format(const char *short_name, const char *filename, const char *mime_type)
     * }
     */
    public static MemorySegment av_guess_format(MemorySegment short_name, MemorySegment filename, MemorySegment mime_type) {
        var mh$ = av_guess_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_format", short_name, filename, mime_type);
            }
            return (MemorySegment)mh$.invokeExact(short_name, filename, mime_type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_codec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_codec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static FunctionDescriptor av_guess_codec$descriptor() {
        return av_guess_codec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static MethodHandle av_guess_codec$handle() {
        return av_guess_codec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static MemorySegment av_guess_codec$address() {
        return av_guess_codec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVCodecID av_guess_codec(const AVOutputFormat *fmt, const char *short_name, const char *filename, const char *mime_type, enum AVMediaType type)
     * }
     */
    public static int av_guess_codec(MemorySegment fmt, MemorySegment short_name, MemorySegment filename, MemorySegment mime_type, int type) {
        var mh$ = av_guess_codec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_codec", fmt, short_name, filename, mime_type, type);
            }
            return (int)mh$.invokeExact(fmt, short_name, filename, mime_type, type);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_output_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_output_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static FunctionDescriptor av_get_output_timestamp$descriptor() {
        return av_get_output_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static MethodHandle av_get_output_timestamp$handle() {
        return av_get_output_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static MemorySegment av_get_output_timestamp$address() {
        return av_get_output_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_output_timestamp(struct AVFormatContext *s, int stream, int64_t *dts, int64_t *wall)
     * }
     */
    public static int av_get_output_timestamp(MemorySegment s, int stream, MemorySegment dts, MemorySegment wall) {
        var mh$ = av_get_output_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_output_timestamp", s, stream, dts, wall);
            }
            return (int)mh$.invokeExact(s, stream, dts, wall);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hex_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hex_dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static FunctionDescriptor av_hex_dump$descriptor() {
        return av_hex_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static MethodHandle av_hex_dump$handle() {
        return av_hex_dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static MemorySegment av_hex_dump$address() {
        return av_hex_dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hex_dump(FILE *f, const uint8_t *buf, int size)
     * }
     */
    public static void av_hex_dump(MemorySegment f, MemorySegment buf, int size) {
        var mh$ = av_hex_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hex_dump", f, buf, size);
            }
            mh$.invokeExact(f, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_hex_dump_log {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_hex_dump_log");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static FunctionDescriptor av_hex_dump_log$descriptor() {
        return av_hex_dump_log.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static MethodHandle av_hex_dump_log$handle() {
        return av_hex_dump_log.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static MemorySegment av_hex_dump_log$address() {
        return av_hex_dump_log.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_hex_dump_log(void *avcl, int level, const uint8_t *buf, int size)
     * }
     */
    public static void av_hex_dump_log(MemorySegment avcl, int level, MemorySegment buf, int size) {
        var mh$ = av_hex_dump_log.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_hex_dump_log", avcl, level, buf, size);
            }
            mh$.invokeExact(avcl, level, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pkt_dump2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pkt_dump2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_pkt_dump2$descriptor() {
        return av_pkt_dump2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MethodHandle av_pkt_dump2$handle() {
        return av_pkt_dump2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MemorySegment av_pkt_dump2$address() {
        return av_pkt_dump2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_pkt_dump2(FILE *f, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static void av_pkt_dump2(MemorySegment f, MemorySegment pkt, int dump_payload, MemorySegment st) {
        var mh$ = av_pkt_dump2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pkt_dump2", f, pkt, dump_payload, st);
            }
            mh$.invokeExact(f, pkt, dump_payload, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pkt_dump_log2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pkt_dump_log2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_pkt_dump_log2$descriptor() {
        return av_pkt_dump_log2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MethodHandle av_pkt_dump_log2$handle() {
        return av_pkt_dump_log2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static MemorySegment av_pkt_dump_log2$address() {
        return av_pkt_dump_log2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_pkt_dump_log2(void *avcl, int level, const AVPacket *pkt, int dump_payload, const AVStream *st)
     * }
     */
    public static void av_pkt_dump_log2(MemorySegment avcl, int level, MemorySegment pkt, int dump_payload, MemorySegment st) {
        var mh$ = av_pkt_dump_log2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pkt_dump_log2", avcl, level, pkt, dump_payload, st);
            }
            mh$.invokeExact(avcl, level, pkt, dump_payload, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static FunctionDescriptor av_codec_get_id$descriptor() {
        return av_codec_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static MethodHandle av_codec_get_id$handle() {
        return av_codec_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static MemorySegment av_codec_get_id$address() {
        return av_codec_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVCodecID av_codec_get_id(const struct AVCodecTag *const *tags, unsigned int tag)
     * }
     */
    public static int av_codec_get_id(MemorySegment tags, int tag) {
        var mh$ = av_codec_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_id", tags, tag);
            }
            return (int)mh$.invokeExact(tags, tag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_get_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor av_codec_get_tag$descriptor() {
        return av_codec_get_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static MethodHandle av_codec_get_tag$handle() {
        return av_codec_get_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static MemorySegment av_codec_get_tag$address() {
        return av_codec_get_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_codec_get_tag(const struct AVCodecTag *const *tags, enum AVCodecID id)
     * }
     */
    public static int av_codec_get_tag(MemorySegment tags, int id) {
        var mh$ = av_codec_get_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_tag", tags, id);
            }
            return (int)mh$.invokeExact(tags, id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_codec_get_tag2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_codec_get_tag2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static FunctionDescriptor av_codec_get_tag2$descriptor() {
        return av_codec_get_tag2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static MethodHandle av_codec_get_tag2$handle() {
        return av_codec_get_tag2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static MemorySegment av_codec_get_tag2$address() {
        return av_codec_get_tag2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_codec_get_tag2(const struct AVCodecTag *const *tags, enum AVCodecID id, unsigned int *tag)
     * }
     */
    public static int av_codec_get_tag2(MemorySegment tags, int id, MemorySegment tag) {
        var mh$ = av_codec_get_tag2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_codec_get_tag2", tags, id, tag);
            }
            return (int)mh$.invokeExact(tags, id, tag);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_default_stream_index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_default_stream_index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor av_find_default_stream_index$descriptor() {
        return av_find_default_stream_index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static MethodHandle av_find_default_stream_index$handle() {
        return av_find_default_stream_index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static MemorySegment av_find_default_stream_index$address() {
        return av_find_default_stream_index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_find_default_stream_index(AVFormatContext *s)
     * }
     */
    public static int av_find_default_stream_index(MemorySegment s) {
        var mh$ = av_find_default_stream_index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_default_stream_index", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_index_search_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_index_search_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static FunctionDescriptor av_index_search_timestamp$descriptor() {
        return av_index_search_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static MethodHandle av_index_search_timestamp$handle() {
        return av_index_search_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static MemorySegment av_index_search_timestamp$address() {
        return av_index_search_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_index_search_timestamp(AVStream *st, int64_t timestamp, int flags)
     * }
     */
    public static int av_index_search_timestamp(MemorySegment st, long timestamp, int flags) {
        var mh$ = av_index_search_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_index_search_timestamp", st, timestamp, flags);
            }
            return (int)mh$.invokeExact(st, timestamp, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entries_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_index_get_entries_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entries_count$descriptor() {
        return avformat_index_get_entries_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static MethodHandle avformat_index_get_entries_count$handle() {
        return avformat_index_get_entries_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static MemorySegment avformat_index_get_entries_count$address() {
        return avformat_index_get_entries_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_index_get_entries_count(const AVStream *st)
     * }
     */
    public static int avformat_index_get_entries_count(MemorySegment st) {
        var mh$ = avformat_index_get_entries_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entries_count", st);
            }
            return (int)mh$.invokeExact(st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_index_get_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entry$descriptor() {
        return avformat_index_get_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MethodHandle avformat_index_get_entry$handle() {
        return avformat_index_get_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MemorySegment avformat_index_get_entry$address() {
        return avformat_index_get_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry(AVStream *st, int idx)
     * }
     */
    public static MemorySegment avformat_index_get_entry(MemorySegment st, int idx) {
        var mh$ = avformat_index_get_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entry", st, idx);
            }
            return (MemorySegment)mh$.invokeExact(st, idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_index_get_entry_from_timestamp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_index_get_entry_from_timestamp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static FunctionDescriptor avformat_index_get_entry_from_timestamp$descriptor() {
        return avformat_index_get_entry_from_timestamp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MethodHandle avformat_index_get_entry_from_timestamp$handle() {
        return avformat_index_get_entry_from_timestamp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MemorySegment avformat_index_get_entry_from_timestamp$address() {
        return avformat_index_get_entry_from_timestamp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVIndexEntry *avformat_index_get_entry_from_timestamp(AVStream *st, int64_t wanted_timestamp, int flags)
     * }
     */
    public static MemorySegment avformat_index_get_entry_from_timestamp(MemorySegment st, long wanted_timestamp, int flags) {
        var mh$ = avformat_index_get_entry_from_timestamp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_index_get_entry_from_timestamp", st, wanted_timestamp, flags);
            }
            return (MemorySegment)mh$.invokeExact(st, wanted_timestamp, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_add_index_entry {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_add_index_entry");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static FunctionDescriptor av_add_index_entry$descriptor() {
        return av_add_index_entry.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static MethodHandle av_add_index_entry$handle() {
        return av_add_index_entry.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static MemorySegment av_add_index_entry$address() {
        return av_add_index_entry.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_add_index_entry(AVStream *st, int64_t pos, int64_t timestamp, int size, int distance, int flags)
     * }
     */
    public static int av_add_index_entry(MemorySegment st, long pos, long timestamp, int size, int distance, int flags) {
        var mh$ = av_add_index_entry.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_add_index_entry", st, pos, timestamp, size, distance, flags);
            }
            return (int)mh$.invokeExact(st, pos, timestamp, size, distance, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_url_split {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_url_split");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static FunctionDescriptor av_url_split$descriptor() {
        return av_url_split.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static MethodHandle av_url_split$handle() {
        return av_url_split.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static MemorySegment av_url_split$address() {
        return av_url_split.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_url_split(char *proto, int proto_size, char *authorization, int authorization_size, char *hostname, int hostname_size, int *port_ptr, char *path, int path_size, const char *url)
     * }
     */
    public static void av_url_split(MemorySegment proto, int proto_size, MemorySegment authorization, int authorization_size, MemorySegment hostname, int hostname_size, MemorySegment port_ptr, MemorySegment path, int path_size, MemorySegment url) {
        var mh$ = av_url_split.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_url_split", proto, proto_size, authorization, authorization_size, hostname, hostname_size, port_ptr, path, path_size, url);
            }
            mh$.invokeExact(proto, proto_size, authorization, authorization_size, hostname, hostname_size, port_ptr, path, path_size, url);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_dump_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_dump_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static FunctionDescriptor av_dump_format$descriptor() {
        return av_dump_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static MethodHandle av_dump_format$handle() {
        return av_dump_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static MemorySegment av_dump_format$address() {
        return av_dump_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_dump_format(AVFormatContext *ic, int index, const char *url, int is_output)
     * }
     */
    public static void av_dump_format(MemorySegment ic, int index, MemorySegment url, int is_output) {
        var mh$ = av_dump_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_dump_format", ic, index, url, is_output);
            }
            mh$.invokeExact(ic, index, url, is_output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_frame_filename2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_frame_filename2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static FunctionDescriptor av_get_frame_filename2$descriptor() {
        return av_get_frame_filename2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static MethodHandle av_get_frame_filename2$handle() {
        return av_get_frame_filename2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static MemorySegment av_get_frame_filename2$address() {
        return av_get_frame_filename2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_frame_filename2(char *buf, int buf_size, const char *path, int number, int flags)
     * }
     */
    public static int av_get_frame_filename2(MemorySegment buf, int buf_size, MemorySegment path, int number, int flags) {
        var mh$ = av_get_frame_filename2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_frame_filename2", buf, buf_size, path, number, flags);
            }
            return (int)mh$.invokeExact(buf, buf_size, path, number, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_frame_filename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_frame_filename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static FunctionDescriptor av_get_frame_filename$descriptor() {
        return av_get_frame_filename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static MethodHandle av_get_frame_filename$handle() {
        return av_get_frame_filename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static MemorySegment av_get_frame_filename$address() {
        return av_get_frame_filename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_frame_filename(char *buf, int buf_size, const char *path, int number)
     * }
     */
    public static int av_get_frame_filename(MemorySegment buf, int buf_size, MemorySegment path, int number) {
        var mh$ = av_get_frame_filename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_frame_filename", buf, buf_size, path, number);
            }
            return (int)mh$.invokeExact(buf, buf_size, path, number);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_filename_number_test {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_filename_number_test");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static FunctionDescriptor av_filename_number_test$descriptor() {
        return av_filename_number_test.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static MethodHandle av_filename_number_test$handle() {
        return av_filename_number_test.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static MemorySegment av_filename_number_test$address() {
        return av_filename_number_test.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_filename_number_test(const char *filename)
     * }
     */
    public static int av_filename_number_test(MemorySegment filename) {
        var mh$ = av_filename_number_test.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_filename_number_test", filename);
            }
            return (int)mh$.invokeExact(filename);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_sdp_create {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_sdp_create");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static FunctionDescriptor av_sdp_create$descriptor() {
        return av_sdp_create.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static MethodHandle av_sdp_create$handle() {
        return av_sdp_create.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static MemorySegment av_sdp_create$address() {
        return av_sdp_create.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_sdp_create(AVFormatContext *ac[], int n_files, char *buf, int size)
     * }
     */
    public static int av_sdp_create(MemorySegment ac, int n_files, MemorySegment buf, int size) {
        var mh$ = av_sdp_create.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_sdp_create", ac, n_files, buf, size);
            }
            return (int)mh$.invokeExact(ac, n_files, buf, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_match_ext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_match_ext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static FunctionDescriptor av_match_ext$descriptor() {
        return av_match_ext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static MethodHandle av_match_ext$handle() {
        return av_match_ext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static MemorySegment av_match_ext$address() {
        return av_match_ext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_match_ext(const char *filename, const char *extensions)
     * }
     */
    public static int av_match_ext(MemorySegment filename, MemorySegment extensions) {
        var mh$ = av_match_ext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_match_ext", filename, extensions);
            }
            return (int)mh$.invokeExact(filename, extensions);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_query_codec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_query_codec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static FunctionDescriptor avformat_query_codec$descriptor() {
        return avformat_query_codec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static MethodHandle avformat_query_codec$handle() {
        return avformat_query_codec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static MemorySegment avformat_query_codec$address() {
        return avformat_query_codec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_query_codec(const AVOutputFormat *ofmt, enum AVCodecID codec_id, int std_compliance)
     * }
     */
    public static int avformat_query_codec(MemorySegment ofmt, int codec_id, int std_compliance) {
        var mh$ = avformat_query_codec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_query_codec", ofmt, codec_id, std_compliance);
            }
            return (int)mh$.invokeExact(ofmt, codec_id, std_compliance);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_riff_video_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_riff_video_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_riff_video_tags$descriptor() {
        return avformat_get_riff_video_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MethodHandle avformat_get_riff_video_tags$handle() {
        return avformat_get_riff_video_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_video_tags$address() {
        return avformat_get_riff_video_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_video_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_video_tags() {
        var mh$ = avformat_get_riff_video_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_riff_video_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_riff_audio_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_riff_audio_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_riff_audio_tags$descriptor() {
        return avformat_get_riff_audio_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MethodHandle avformat_get_riff_audio_tags$handle() {
        return avformat_get_riff_audio_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_audio_tags$address() {
        return avformat_get_riff_audio_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_riff_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_riff_audio_tags() {
        var mh$ = avformat_get_riff_audio_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_riff_audio_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_mov_video_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_mov_video_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_mov_video_tags$descriptor() {
        return avformat_get_mov_video_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MethodHandle avformat_get_mov_video_tags$handle() {
        return avformat_get_mov_video_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_video_tags$address() {
        return avformat_get_mov_video_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_video_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_video_tags() {
        var mh$ = avformat_get_mov_video_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_mov_video_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_get_mov_audio_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_get_mov_audio_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static FunctionDescriptor avformat_get_mov_audio_tags$descriptor() {
        return avformat_get_mov_audio_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MethodHandle avformat_get_mov_audio_tags$handle() {
        return avformat_get_mov_audio_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_audio_tags$address() {
        return avformat_get_mov_audio_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const struct AVCodecTag *avformat_get_mov_audio_tags()
     * }
     */
    public static MemorySegment avformat_get_mov_audio_tags() {
        var mh$ = avformat_get_mov_audio_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_get_mov_audio_tags");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_sample_aspect_ratio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_sample_aspect_ratio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_guess_sample_aspect_ratio$descriptor() {
        return av_guess_sample_aspect_ratio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_guess_sample_aspect_ratio$handle() {
        return av_guess_sample_aspect_ratio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_sample_aspect_ratio$address() {
        return av_guess_sample_aspect_ratio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_guess_sample_aspect_ratio(AVFormatContext *format, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_sample_aspect_ratio(SegmentAllocator allocator, MemorySegment format, MemorySegment stream, MemorySegment frame) {
        var mh$ = av_guess_sample_aspect_ratio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_sample_aspect_ratio", allocator, format, stream, frame);
            }
            return (MemorySegment)mh$.invokeExact(allocator, format, stream, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_guess_frame_rate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_guess_frame_rate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_guess_frame_rate$descriptor() {
        return av_guess_frame_rate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MethodHandle av_guess_frame_rate$handle() {
        return av_guess_frame_rate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_frame_rate$address() {
        return av_guess_frame_rate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_guess_frame_rate(AVFormatContext *ctx, AVStream *stream, struct AVFrame *frame)
     * }
     */
    public static MemorySegment av_guess_frame_rate(SegmentAllocator allocator, MemorySegment ctx, MemorySegment stream, MemorySegment frame) {
        var mh$ = av_guess_frame_rate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_guess_frame_rate", allocator, ctx, stream, frame);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx, stream, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_match_stream_specifier {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_match_stream_specifier");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static FunctionDescriptor avformat_match_stream_specifier$descriptor() {
        return avformat_match_stream_specifier.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static MethodHandle avformat_match_stream_specifier$handle() {
        return avformat_match_stream_specifier.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static MemorySegment avformat_match_stream_specifier$address() {
        return avformat_match_stream_specifier.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_match_stream_specifier(AVFormatContext *s, AVStream *st, const char *spec)
     * }
     */
    public static int avformat_match_stream_specifier(MemorySegment s, MemorySegment st, MemorySegment spec) {
        var mh$ = avformat_match_stream_specifier.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_match_stream_specifier", s, st, spec);
            }
            return (int)mh$.invokeExact(s, st, spec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avformat_queue_attached_pictures {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_queue_attached_pictures");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static FunctionDescriptor avformat_queue_attached_pictures$descriptor() {
        return avformat_queue_attached_pictures.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static MethodHandle avformat_queue_attached_pictures$handle() {
        return avformat_queue_attached_pictures.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static MemorySegment avformat_queue_attached_pictures$address() {
        return avformat_queue_attached_pictures.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_queue_attached_pictures(AVFormatContext *s)
     * }
     */
    public static int avformat_queue_attached_pictures(MemorySegment s) {
        var mh$ = avformat_queue_attached_pictures.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_queue_attached_pictures", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVFMT_TBCF_AUTO = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_AUTO = -1
     * }
     */
    public static int AVFMT_TBCF_AUTO() {
        return AVFMT_TBCF_AUTO;
    }
    private static final int AVFMT_TBCF_DECODER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_DECODER = 0
     * }
     */
    public static int AVFMT_TBCF_DECODER() {
        return AVFMT_TBCF_DECODER;
    }
    private static final int AVFMT_TBCF_DEMUXER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_DEMUXER = 1
     * }
     */
    public static int AVFMT_TBCF_DEMUXER() {
        return AVFMT_TBCF_DEMUXER;
    }
    private static final int AVFMT_TBCF_R_FRAMERATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVTimebaseSource.AVFMT_TBCF_R_FRAMERATE = 2
     * }
     */
    public static int AVFMT_TBCF_R_FRAMERATE() {
        return AVFMT_TBCF_R_FRAMERATE;
    }

    private static class avformat_transfer_internal_stream_timing_info {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avformat_transfer_internal_stream_timing_info");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static FunctionDescriptor avformat_transfer_internal_stream_timing_info$descriptor() {
        return avformat_transfer_internal_stream_timing_info.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static MethodHandle avformat_transfer_internal_stream_timing_info$handle() {
        return avformat_transfer_internal_stream_timing_info.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static MemorySegment avformat_transfer_internal_stream_timing_info$address() {
        return avformat_transfer_internal_stream_timing_info.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avformat_transfer_internal_stream_timing_info(const AVOutputFormat *ofmt, AVStream *ost, const AVStream *ist, enum AVTimebaseSource copy_tb)
     * }
     */
    public static int avformat_transfer_internal_stream_timing_info(MemorySegment ofmt, MemorySegment ost, MemorySegment ist, int copy_tb) {
        var mh$ = avformat_transfer_internal_stream_timing_info.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avformat_transfer_internal_stream_timing_info", ofmt, ost, ist, copy_tb);
            }
            return (int)mh$.invokeExact(ofmt, ost, ist, copy_tb);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_stream_get_codec_timebase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_stream_get_codec_timebase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static FunctionDescriptor av_stream_get_codec_timebase$descriptor() {
        return av_stream_get_codec_timebase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MethodHandle av_stream_get_codec_timebase$handle() {
        return av_stream_get_codec_timebase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_codec_timebase$address() {
        return av_stream_get_codec_timebase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_stream_get_codec_timebase(const AVStream *st)
     * }
     */
    public static MemorySegment av_stream_get_codec_timebase(SegmentAllocator allocator, MemorySegment st) {
        var mh$ = av_stream_get_codec_timebase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_stream_get_codec_timebase", allocator, st);
            }
            return (MemorySegment)mh$.invokeExact(allocator, st);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_descriptor_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_descriptor_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static FunctionDescriptor avcodec_descriptor_get$descriptor() {
        return avcodec_descriptor_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static MethodHandle avcodec_descriptor_get$handle() {
        return avcodec_descriptor_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_descriptor_get$address() {
        return avcodec_descriptor_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get(enum AVCodecID id)
     * }
     */
    public static MemorySegment avcodec_descriptor_get(int id) {
        var mh$ = avcodec_descriptor_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_descriptor_get", id);
            }
            return (MemorySegment)mh$.invokeExact(id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_descriptor_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_descriptor_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static FunctionDescriptor avcodec_descriptor_next$descriptor() {
        return avcodec_descriptor_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static MethodHandle avcodec_descriptor_next$handle() {
        return avcodec_descriptor_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static MemorySegment avcodec_descriptor_next$address() {
        return avcodec_descriptor_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_next(const AVCodecDescriptor *prev)
     * }
     */
    public static MemorySegment avcodec_descriptor_next(MemorySegment prev) {
        var mh$ = avcodec_descriptor_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_descriptor_next", prev);
            }
            return (MemorySegment)mh$.invokeExact(prev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_descriptor_get_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_descriptor_get_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avcodec_descriptor_get_by_name$descriptor() {
        return avcodec_descriptor_get_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static MethodHandle avcodec_descriptor_get_by_name$handle() {
        return avcodec_descriptor_get_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_descriptor_get_by_name$address() {
        return avcodec_descriptor_get_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecDescriptor *avcodec_descriptor_get_by_name(const char *name)
     * }
     */
    public static MemorySegment avcodec_descriptor_get_by_name(MemorySegment name) {
        var mh$ = avcodec_descriptor_get_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_descriptor_get_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SUBTITLE_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_NONE = 0
     * }
     */
    public static int SUBTITLE_NONE() {
        return SUBTITLE_NONE;
    }
    private static final int SUBTITLE_BITMAP = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_BITMAP = 1
     * }
     */
    public static int SUBTITLE_BITMAP() {
        return SUBTITLE_BITMAP;
    }
    private static final int SUBTITLE_TEXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_TEXT = 2
     * }
     */
    public static int SUBTITLE_TEXT() {
        return SUBTITLE_TEXT;
    }
    private static final int SUBTITLE_ASS = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVSubtitleType.SUBTITLE_ASS = 3
     * }
     */
    public static int SUBTITLE_ASS() {
        return SUBTITLE_ASS;
    }

    private static class avcodec_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static FunctionDescriptor avcodec_version$descriptor() {
        return avcodec_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static MethodHandle avcodec_version$handle() {
        return avcodec_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static MemorySegment avcodec_version$address() {
        return avcodec_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avcodec_version()
     * }
     */
    public static int avcodec_version() {
        var mh$ = avcodec_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static FunctionDescriptor avcodec_configuration$descriptor() {
        return avcodec_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MethodHandle avcodec_configuration$handle() {
        return avcodec_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MemorySegment avcodec_configuration$address() {
        return avcodec_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_configuration()
     * }
     */
    public static MemorySegment avcodec_configuration() {
        var mh$ = avcodec_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static FunctionDescriptor avcodec_license$descriptor() {
        return avcodec_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MethodHandle avcodec_license$handle() {
        return avcodec_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MemorySegment avcodec_license$address() {
        return avcodec_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avcodec_license()
     * }
     */
    public static MemorySegment avcodec_license() {
        var mh$ = avcodec_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_alloc_context3 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_alloc_context3");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static FunctionDescriptor avcodec_alloc_context3$descriptor() {
        return avcodec_alloc_context3.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MethodHandle avcodec_alloc_context3$handle() {
        return avcodec_alloc_context3.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MemorySegment avcodec_alloc_context3$address() {
        return avcodec_alloc_context3.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecContext *avcodec_alloc_context3(const AVCodec *codec)
     * }
     */
    public static MemorySegment avcodec_alloc_context3(MemorySegment codec) {
        var mh$ = avcodec_alloc_context3.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_alloc_context3", codec);
            }
            return (MemorySegment)mh$.invokeExact(codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_free_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_free_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static FunctionDescriptor avcodec_free_context$descriptor() {
        return avcodec_free_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static MethodHandle avcodec_free_context$handle() {
        return avcodec_free_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static MemorySegment avcodec_free_context$address() {
        return avcodec_free_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_free_context(AVCodecContext **avctx)
     * }
     */
    public static void avcodec_free_context(MemorySegment avctx) {
        var mh$ = avcodec_free_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_free_context", avctx);
            }
            mh$.invokeExact(avctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static FunctionDescriptor avcodec_get_class$descriptor() {
        return avcodec_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MethodHandle avcodec_get_class$handle() {
        return avcodec_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MemorySegment avcodec_get_class$address() {
        return avcodec_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avcodec_get_class()
     * }
     */
    public static MemorySegment avcodec_get_class() {
        var mh$ = avcodec_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_subtitle_rect_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_subtitle_rect_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static FunctionDescriptor avcodec_get_subtitle_rect_class$descriptor() {
        return avcodec_get_subtitle_rect_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MethodHandle avcodec_get_subtitle_rect_class$handle() {
        return avcodec_get_subtitle_rect_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MemorySegment avcodec_get_subtitle_rect_class$address() {
        return avcodec_get_subtitle_rect_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avcodec_get_subtitle_rect_class()
     * }
     */
    public static MemorySegment avcodec_get_subtitle_rect_class() {
        var mh$ = avcodec_get_subtitle_rect_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_subtitle_rect_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_from_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_parameters_from_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_from_context$descriptor() {
        return avcodec_parameters_from_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static MethodHandle avcodec_parameters_from_context$handle() {
        return avcodec_parameters_from_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static MemorySegment avcodec_parameters_from_context$address() {
        return avcodec_parameters_from_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_from_context(struct AVCodecParameters *par, const AVCodecContext *codec)
     * }
     */
    public static int avcodec_parameters_from_context(MemorySegment par, MemorySegment codec) {
        var mh$ = avcodec_parameters_from_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_from_context", par, codec);
            }
            return (int)mh$.invokeExact(par, codec);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_parameters_to_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_parameters_to_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static FunctionDescriptor avcodec_parameters_to_context$descriptor() {
        return avcodec_parameters_to_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static MethodHandle avcodec_parameters_to_context$handle() {
        return avcodec_parameters_to_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static MemorySegment avcodec_parameters_to_context$address() {
        return avcodec_parameters_to_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_parameters_to_context(AVCodecContext *codec, const struct AVCodecParameters *par)
     * }
     */
    public static int avcodec_parameters_to_context(MemorySegment codec, MemorySegment par) {
        var mh$ = avcodec_parameters_to_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_parameters_to_context", codec, par);
            }
            return (int)mh$.invokeExact(codec, par);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_open2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_open2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avcodec_open2$descriptor() {
        return avcodec_open2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static MethodHandle avcodec_open2$handle() {
        return avcodec_open2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static MemorySegment avcodec_open2$address() {
        return avcodec_open2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_open2(AVCodecContext *avctx, const AVCodec *codec, AVDictionary **options)
     * }
     */
    public static int avcodec_open2(MemorySegment avctx, MemorySegment codec, MemorySegment options) {
        var mh$ = avcodec_open2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_open2", avctx, codec, options);
            }
            return (int)mh$.invokeExact(avctx, codec, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avsubtitle_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avsubtitle_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static FunctionDescriptor avsubtitle_free$descriptor() {
        return avsubtitle_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static MethodHandle avsubtitle_free$handle() {
        return avsubtitle_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static MemorySegment avsubtitle_free$address() {
        return avsubtitle_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avsubtitle_free(AVSubtitle *sub)
     * }
     */
    public static void avsubtitle_free(MemorySegment sub) {
        var mh$ = avsubtitle_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avsubtitle_free", sub);
            }
            mh$.invokeExact(sub);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_buffer2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_get_buffer2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_buffer2$descriptor() {
        return avcodec_default_get_buffer2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle avcodec_default_get_buffer2$handle() {
        return avcodec_default_get_buffer2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment avcodec_default_get_buffer2$address() {
        return avcodec_default_get_buffer2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_get_buffer2(AVCodecContext *s, AVFrame *frame, int flags)
     * }
     */
    public static int avcodec_default_get_buffer2(MemorySegment s, MemorySegment frame, int flags) {
        var mh$ = avcodec_default_get_buffer2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_buffer2", s, frame, flags);
            }
            return (int)mh$.invokeExact(s, frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_encode_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_get_encode_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_encode_buffer$descriptor() {
        return avcodec_default_get_encode_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static MethodHandle avcodec_default_get_encode_buffer$handle() {
        return avcodec_default_get_encode_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static MemorySegment avcodec_default_get_encode_buffer$address() {
        return avcodec_default_get_encode_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_get_encode_buffer(AVCodecContext *s, AVPacket *pkt, int flags)
     * }
     */
    public static int avcodec_default_get_encode_buffer(MemorySegment s, MemorySegment pkt, int flags) {
        var mh$ = avcodec_default_get_encode_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_encode_buffer", s, pkt, flags);
            }
            return (int)mh$.invokeExact(s, pkt, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_align_dimensions {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_align_dimensions");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static FunctionDescriptor avcodec_align_dimensions$descriptor() {
        return avcodec_align_dimensions.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static MethodHandle avcodec_align_dimensions$handle() {
        return avcodec_align_dimensions.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static MemorySegment avcodec_align_dimensions$address() {
        return avcodec_align_dimensions.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_align_dimensions(AVCodecContext *s, int *width, int *height)
     * }
     */
    public static void avcodec_align_dimensions(MemorySegment s, MemorySegment width, MemorySegment height) {
        var mh$ = avcodec_align_dimensions.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_align_dimensions", s, width, height);
            }
            mh$.invokeExact(s, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_align_dimensions2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_align_dimensions2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static FunctionDescriptor avcodec_align_dimensions2$descriptor() {
        return avcodec_align_dimensions2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static MethodHandle avcodec_align_dimensions2$handle() {
        return avcodec_align_dimensions2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static MemorySegment avcodec_align_dimensions2$address() {
        return avcodec_align_dimensions2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_align_dimensions2(AVCodecContext *s, int *width, int *height, int linesize_align[8])
     * }
     */
    public static void avcodec_align_dimensions2(MemorySegment s, MemorySegment width, MemorySegment height, MemorySegment linesize_align) {
        var mh$ = avcodec_align_dimensions2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_align_dimensions2", s, width, height, linesize_align);
            }
            mh$.invokeExact(s, width, height, linesize_align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_decode_subtitle2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_decode_subtitle2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_decode_subtitle2$descriptor() {
        return avcodec_decode_subtitle2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_decode_subtitle2$handle() {
        return avcodec_decode_subtitle2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_decode_subtitle2$address() {
        return avcodec_decode_subtitle2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub, int *got_sub_ptr, const AVPacket *avpkt)
     * }
     */
    public static int avcodec_decode_subtitle2(MemorySegment avctx, MemorySegment sub, MemorySegment got_sub_ptr, MemorySegment avpkt) {
        var mh$ = avcodec_decode_subtitle2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_decode_subtitle2", avctx, sub, got_sub_ptr, avpkt);
            }
            return (int)mh$.invokeExact(avctx, sub, got_sub_ptr, avpkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_send_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_send_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_send_packet$descriptor() {
        return avcodec_send_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_send_packet$handle() {
        return avcodec_send_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_send_packet$address() {
        return avcodec_send_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_send_packet(AVCodecContext *avctx, const AVPacket *avpkt)
     * }
     */
    public static int avcodec_send_packet(MemorySegment avctx, MemorySegment avpkt) {
        var mh$ = avcodec_send_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_send_packet", avctx, avpkt);
            }
            return (int)mh$.invokeExact(avctx, avpkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_receive_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_receive_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor avcodec_receive_frame$descriptor() {
        return avcodec_receive_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static MethodHandle avcodec_receive_frame$handle() {
        return avcodec_receive_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static MemorySegment avcodec_receive_frame$address() {
        return avcodec_receive_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame)
     * }
     */
    public static int avcodec_receive_frame(MemorySegment avctx, MemorySegment frame) {
        var mh$ = avcodec_receive_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_receive_frame", avctx, frame);
            }
            return (int)mh$.invokeExact(avctx, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_send_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_send_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static FunctionDescriptor avcodec_send_frame$descriptor() {
        return avcodec_send_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static MethodHandle avcodec_send_frame$handle() {
        return avcodec_send_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static MemorySegment avcodec_send_frame$address() {
        return avcodec_send_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_send_frame(AVCodecContext *avctx, const AVFrame *frame)
     * }
     */
    public static int avcodec_send_frame(MemorySegment avctx, MemorySegment frame) {
        var mh$ = avcodec_send_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_send_frame", avctx, frame);
            }
            return (int)mh$.invokeExact(avctx, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_receive_packet {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_receive_packet");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static FunctionDescriptor avcodec_receive_packet$descriptor() {
        return avcodec_receive_packet.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static MethodHandle avcodec_receive_packet$handle() {
        return avcodec_receive_packet.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static MemorySegment avcodec_receive_packet$address() {
        return avcodec_receive_packet.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_receive_packet(AVCodecContext *avctx, AVPacket *avpkt)
     * }
     */
    public static int avcodec_receive_packet(MemorySegment avctx, MemorySegment avpkt) {
        var mh$ = avcodec_receive_packet.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_receive_packet", avctx, avpkt);
            }
            return (int)mh$.invokeExact(avctx, avpkt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_get_hw_frames_parameters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_hw_frames_parameters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static FunctionDescriptor avcodec_get_hw_frames_parameters$descriptor() {
        return avcodec_get_hw_frames_parameters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static MethodHandle avcodec_get_hw_frames_parameters$handle() {
        return avcodec_get_hw_frames_parameters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static MemorySegment avcodec_get_hw_frames_parameters$address() {
        return avcodec_get_hw_frames_parameters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_get_hw_frames_parameters(AVCodecContext *avctx, AVBufferRef *device_ref, enum AVPixelFormat hw_pix_fmt, AVBufferRef **out_frames_ref)
     * }
     */
    public static int avcodec_get_hw_frames_parameters(MemorySegment avctx, MemorySegment device_ref, int hw_pix_fmt, MemorySegment out_frames_ref) {
        var mh$ = avcodec_get_hw_frames_parameters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_hw_frames_parameters", avctx, device_ref, hw_pix_fmt, out_frames_ref);
            }
            return (int)mh$.invokeExact(avctx, device_ref, hw_pix_fmt, out_frames_ref);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_CODEC_CONFIG_PIX_FORMAT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVCodecConfig.AV_CODEC_CONFIG_PIX_FORMAT = 0
     * }
     */
    public static int AV_CODEC_CONFIG_PIX_FORMAT() {
        return AV_CODEC_CONFIG_PIX_FORMAT;
    }
    private static final int AV_CODEC_CONFIG_FRAME_RATE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVCodecConfig.AV_CODEC_CONFIG_FRAME_RATE = 1
     * }
     */
    public static int AV_CODEC_CONFIG_FRAME_RATE() {
        return AV_CODEC_CONFIG_FRAME_RATE;
    }
    private static final int AV_CODEC_CONFIG_SAMPLE_RATE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVCodecConfig.AV_CODEC_CONFIG_SAMPLE_RATE = 2
     * }
     */
    public static int AV_CODEC_CONFIG_SAMPLE_RATE() {
        return AV_CODEC_CONFIG_SAMPLE_RATE;
    }
    private static final int AV_CODEC_CONFIG_SAMPLE_FORMAT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVCodecConfig.AV_CODEC_CONFIG_SAMPLE_FORMAT = 3
     * }
     */
    public static int AV_CODEC_CONFIG_SAMPLE_FORMAT() {
        return AV_CODEC_CONFIG_SAMPLE_FORMAT;
    }
    private static final int AV_CODEC_CONFIG_CHANNEL_LAYOUT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AVCodecConfig.AV_CODEC_CONFIG_CHANNEL_LAYOUT = 4
     * }
     */
    public static int AV_CODEC_CONFIG_CHANNEL_LAYOUT() {
        return AV_CODEC_CONFIG_CHANNEL_LAYOUT;
    }
    private static final int AV_CODEC_CONFIG_COLOR_RANGE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AVCodecConfig.AV_CODEC_CONFIG_COLOR_RANGE = 5
     * }
     */
    public static int AV_CODEC_CONFIG_COLOR_RANGE() {
        return AV_CODEC_CONFIG_COLOR_RANGE;
    }
    private static final int AV_CODEC_CONFIG_COLOR_SPACE = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AVCodecConfig.AV_CODEC_CONFIG_COLOR_SPACE = 6
     * }
     */
    public static int AV_CODEC_CONFIG_COLOR_SPACE() {
        return AV_CODEC_CONFIG_COLOR_SPACE;
    }

    private static class avcodec_get_supported_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_get_supported_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static FunctionDescriptor avcodec_get_supported_config$descriptor() {
        return avcodec_get_supported_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static MethodHandle avcodec_get_supported_config$handle() {
        return avcodec_get_supported_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static MemorySegment avcodec_get_supported_config$address() {
        return avcodec_get_supported_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_get_supported_config(const AVCodecContext *avctx, const AVCodec *codec, enum AVCodecConfig config, unsigned int flags, const void **out_configs, int *out_num_configs)
     * }
     */
    public static int avcodec_get_supported_config(MemorySegment avctx, MemorySegment codec, int config, int flags, MemorySegment out_configs, MemorySegment out_num_configs) {
        var mh$ = avcodec_get_supported_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_get_supported_config", avctx, codec, config, flags, out_configs, out_num_configs);
            }
            return (int)mh$.invokeExact(avctx, codec, config, flags, out_configs, out_num_configs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_PICTURE_STRUCTURE_UNKNOWN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_UNKNOWN = 0
     * }
     */
    public static int AV_PICTURE_STRUCTURE_UNKNOWN() {
        return AV_PICTURE_STRUCTURE_UNKNOWN;
    }
    private static final int AV_PICTURE_STRUCTURE_TOP_FIELD = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_TOP_FIELD = 1
     * }
     */
    public static int AV_PICTURE_STRUCTURE_TOP_FIELD() {
        return AV_PICTURE_STRUCTURE_TOP_FIELD;
    }
    private static final int AV_PICTURE_STRUCTURE_BOTTOM_FIELD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_BOTTOM_FIELD = 2
     * }
     */
    public static int AV_PICTURE_STRUCTURE_BOTTOM_FIELD() {
        return AV_PICTURE_STRUCTURE_BOTTOM_FIELD;
    }
    private static final int AV_PICTURE_STRUCTURE_FRAME = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AVPictureStructure.AV_PICTURE_STRUCTURE_FRAME = 3
     * }
     */
    public static int AV_PICTURE_STRUCTURE_FRAME() {
        return AV_PICTURE_STRUCTURE_FRAME;
    }

    private static class av_parser_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_parser_iterate$descriptor() {
        return av_parser_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_parser_iterate$handle() {
        return av_parser_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_parser_iterate$address() {
        return av_parser_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVCodecParser *av_parser_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_parser_iterate(MemorySegment opaque) {
        var mh$ = av_parser_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static FunctionDescriptor av_parser_init$descriptor() {
        return av_parser_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MethodHandle av_parser_init$handle() {
        return av_parser_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MemorySegment av_parser_init$address() {
        return av_parser_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVCodecParserContext *av_parser_init(int codec_id)
     * }
     */
    public static MemorySegment av_parser_init(int codec_id) {
        var mh$ = av_parser_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_init", codec_id);
            }
            return (MemorySegment)mh$.invokeExact(codec_id);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_parse2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_LONG_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_parse2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static FunctionDescriptor av_parser_parse2$descriptor() {
        return av_parser_parse2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static MethodHandle av_parser_parse2$handle() {
        return av_parser_parse2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static MemorySegment av_parser_parse2$address() {
        return av_parser_parse2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx, uint8_t **poutbuf, int *poutbuf_size, const uint8_t *buf, int buf_size, int64_t pts, int64_t dts, int64_t pos)
     * }
     */
    public static int av_parser_parse2(MemorySegment s, MemorySegment avctx, MemorySegment poutbuf, MemorySegment poutbuf_size, MemorySegment buf, int buf_size, long pts, long dts, long pos) {
        var mh$ = av_parser_parse2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_parse2", s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
            }
            return (int)mh$.invokeExact(s, avctx, poutbuf, poutbuf_size, buf, buf_size, pts, dts, pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_parser_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_parser_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static FunctionDescriptor av_parser_close$descriptor() {
        return av_parser_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static MethodHandle av_parser_close$handle() {
        return av_parser_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static MemorySegment av_parser_close$address() {
        return av_parser_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_parser_close(AVCodecParserContext *s)
     * }
     */
    public static void av_parser_close(MemorySegment s) {
        var mh$ = av_parser_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_parser_close", s);
            }
            mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_encode_subtitle {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_encode_subtitle");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static FunctionDescriptor avcodec_encode_subtitle$descriptor() {
        return avcodec_encode_subtitle.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static MethodHandle avcodec_encode_subtitle$handle() {
        return avcodec_encode_subtitle.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static MemorySegment avcodec_encode_subtitle$address() {
        return avcodec_encode_subtitle.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_encode_subtitle(AVCodecContext *avctx, uint8_t *buf, int buf_size, const AVSubtitle *sub)
     * }
     */
    public static int avcodec_encode_subtitle(MemorySegment avctx, MemorySegment buf, int buf_size, MemorySegment sub) {
        var mh$ = avcodec_encode_subtitle.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_encode_subtitle", avctx, buf, buf_size, sub);
            }
            return (int)mh$.invokeExact(avctx, buf, buf_size, sub);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_pix_fmt_to_codec_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_pix_fmt_to_codec_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor avcodec_pix_fmt_to_codec_tag$descriptor() {
        return avcodec_pix_fmt_to_codec_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle avcodec_pix_fmt_to_codec_tag$handle() {
        return avcodec_pix_fmt_to_codec_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment avcodec_pix_fmt_to_codec_tag$address() {
        return avcodec_pix_fmt_to_codec_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avcodec_pix_fmt_to_codec_tag(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int avcodec_pix_fmt_to_codec_tag(int pix_fmt) {
        var mh$ = avcodec_pix_fmt_to_codec_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_pix_fmt_to_codec_tag", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_find_best_pix_fmt_of_list {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_find_best_pix_fmt_of_list");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static FunctionDescriptor avcodec_find_best_pix_fmt_of_list$descriptor() {
        return avcodec_find_best_pix_fmt_of_list.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MethodHandle avcodec_find_best_pix_fmt_of_list$handle() {
        return avcodec_find_best_pix_fmt_of_list.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MemorySegment avcodec_find_best_pix_fmt_of_list$address() {
        return avcodec_find_best_pix_fmt_of_list.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_find_best_pix_fmt_of_list(const enum AVPixelFormat *pix_fmt_list, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static int avcodec_find_best_pix_fmt_of_list(MemorySegment pix_fmt_list, int src_pix_fmt, int has_alpha, MemorySegment loss_ptr) {
        var mh$ = avcodec_find_best_pix_fmt_of_list.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_find_best_pix_fmt_of_list", pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr);
            }
            return (int)mh$.invokeExact(pix_fmt_list, src_pix_fmt, has_alpha, loss_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_get_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_get_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static FunctionDescriptor avcodec_default_get_format$descriptor() {
        return avcodec_default_get_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static MethodHandle avcodec_default_get_format$handle() {
        return avcodec_default_get_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static MemorySegment avcodec_default_get_format$address() {
        return avcodec_default_get_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat avcodec_default_get_format(struct AVCodecContext *s, const enum AVPixelFormat *fmt)
     * }
     */
    public static int avcodec_default_get_format(MemorySegment s, MemorySegment fmt) {
        var mh$ = avcodec_default_get_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_get_format", s, fmt);
            }
            return (int)mh$.invokeExact(s, fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static FunctionDescriptor avcodec_string$descriptor() {
        return avcodec_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static MethodHandle avcodec_string$handle() {
        return avcodec_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static MemorySegment avcodec_string$address() {
        return avcodec_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_string(char *buf, int buf_size, AVCodecContext *enc, int encode)
     * }
     */
    public static void avcodec_string(MemorySegment buf, int buf_size, MemorySegment enc, int encode) {
        var mh$ = avcodec_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_string", buf, buf_size, enc, encode);
            }
            mh$.invokeExact(buf, buf_size, enc, encode);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_execute {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_execute");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static FunctionDescriptor avcodec_default_execute$descriptor() {
        return avcodec_default_execute.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static MethodHandle avcodec_default_execute$handle() {
        return avcodec_default_execute.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static MemorySegment avcodec_default_execute$address() {
        return avcodec_default_execute.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_execute(AVCodecContext *c, int (*func)(AVCodecContext *, void *), void *arg, int *ret, int count, int size)
     * }
     */
    public static int avcodec_default_execute(MemorySegment c, MemorySegment func, MemorySegment arg, MemorySegment ret, int count, int size) {
        var mh$ = avcodec_default_execute.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_execute", c, func, arg, ret, count, size);
            }
            return (int)mh$.invokeExact(c, func, arg, ret, count, size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_default_execute2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_default_execute2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static FunctionDescriptor avcodec_default_execute2$descriptor() {
        return avcodec_default_execute2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static MethodHandle avcodec_default_execute2$handle() {
        return avcodec_default_execute2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static MemorySegment avcodec_default_execute2$address() {
        return avcodec_default_execute2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_default_execute2(AVCodecContext *c, int (*func)(AVCodecContext *, void *, int, int), void *arg, int *ret, int count)
     * }
     */
    public static int avcodec_default_execute2(MemorySegment c, MemorySegment func, MemorySegment arg, MemorySegment ret, int count) {
        var mh$ = avcodec_default_execute2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_default_execute2", c, func, arg, ret, count);
            }
            return (int)mh$.invokeExact(c, func, arg, ret, count);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_fill_audio_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_fill_audio_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static FunctionDescriptor avcodec_fill_audio_frame$descriptor() {
        return avcodec_fill_audio_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static MethodHandle avcodec_fill_audio_frame$handle() {
        return avcodec_fill_audio_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static MemorySegment avcodec_fill_audio_frame$address() {
        return avcodec_fill_audio_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_fill_audio_frame(AVFrame *frame, int nb_channels, enum AVSampleFormat sample_fmt, const uint8_t *buf, int buf_size, int align)
     * }
     */
    public static int avcodec_fill_audio_frame(MemorySegment frame, int nb_channels, int sample_fmt, MemorySegment buf, int buf_size, int align) {
        var mh$ = avcodec_fill_audio_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_fill_audio_frame", frame, nb_channels, sample_fmt, buf, buf_size, align);
            }
            return (int)mh$.invokeExact(frame, nb_channels, sample_fmt, buf, buf_size, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_flush_buffers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_flush_buffers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static FunctionDescriptor avcodec_flush_buffers$descriptor() {
        return avcodec_flush_buffers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static MethodHandle avcodec_flush_buffers$handle() {
        return avcodec_flush_buffers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static MemorySegment avcodec_flush_buffers$address() {
        return avcodec_flush_buffers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avcodec_flush_buffers(AVCodecContext *avctx)
     * }
     */
    public static void avcodec_flush_buffers(MemorySegment avctx) {
        var mh$ = avcodec_flush_buffers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_flush_buffers", avctx);
            }
            mh$.invokeExact(avctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_audio_frame_duration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_audio_frame_duration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static FunctionDescriptor av_get_audio_frame_duration$descriptor() {
        return av_get_audio_frame_duration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static MethodHandle av_get_audio_frame_duration$handle() {
        return av_get_audio_frame_duration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static MemorySegment av_get_audio_frame_duration$address() {
        return av_get_audio_frame_duration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_audio_frame_duration(AVCodecContext *avctx, int frame_bytes)
     * }
     */
    public static int av_get_audio_frame_duration(MemorySegment avctx, int frame_bytes) {
        var mh$ = av_get_audio_frame_duration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_audio_frame_duration", avctx, frame_bytes);
            }
            return (int)mh$.invokeExact(avctx, frame_bytes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_padded_malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_padded_malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_padded_malloc$descriptor() {
        return av_fast_padded_malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_padded_malloc$handle() {
        return av_fast_padded_malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_padded_malloc$address() {
        return av_fast_padded_malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_padded_malloc(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_padded_malloc(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_padded_malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_padded_malloc", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_fast_padded_mallocz {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_fast_padded_mallocz");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static FunctionDescriptor av_fast_padded_mallocz$descriptor() {
        return av_fast_padded_mallocz.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MethodHandle av_fast_padded_mallocz$handle() {
        return av_fast_padded_mallocz.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static MemorySegment av_fast_padded_mallocz$address() {
        return av_fast_padded_mallocz.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_fast_padded_mallocz(void *ptr, unsigned int *size, size_t min_size)
     * }
     */
    public static void av_fast_padded_mallocz(MemorySegment ptr, MemorySegment size, long min_size) {
        var mh$ = av_fast_padded_mallocz.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_fast_padded_mallocz", ptr, size, min_size);
            }
            mh$.invokeExact(ptr, size, min_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avcodec_is_open {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avcodec_is_open");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static FunctionDescriptor avcodec_is_open$descriptor() {
        return avcodec_is_open.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static MethodHandle avcodec_is_open$handle() {
        return avcodec_is_open.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static MemorySegment avcodec_is_open$address() {
        return avcodec_is_open.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avcodec_is_open(AVCodecContext *s)
     * }
     */
    public static int avcodec_is_open(MemorySegment s) {
        var mh$ = avcodec_is_open.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avcodec_is_open", s);
            }
            return (int)mh$.invokeExact(s);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_bits_per_pixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_bits_per_pixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static FunctionDescriptor av_get_bits_per_pixel$descriptor() {
        return av_get_bits_per_pixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MethodHandle av_get_bits_per_pixel$handle() {
        return av_get_bits_per_pixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MemorySegment av_get_bits_per_pixel$address() {
        return av_get_bits_per_pixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static int av_get_bits_per_pixel(MemorySegment pixdesc) {
        var mh$ = av_get_bits_per_pixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_bits_per_pixel", pixdesc);
            }
            return (int)mh$.invokeExact(pixdesc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_padded_bits_per_pixel {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_padded_bits_per_pixel");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static FunctionDescriptor av_get_padded_bits_per_pixel$descriptor() {
        return av_get_padded_bits_per_pixel.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MethodHandle av_get_padded_bits_per_pixel$handle() {
        return av_get_padded_bits_per_pixel.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MemorySegment av_get_padded_bits_per_pixel$address() {
        return av_get_padded_bits_per_pixel.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_padded_bits_per_pixel(const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static int av_get_padded_bits_per_pixel(MemorySegment pixdesc) {
        var mh$ = av_get_padded_bits_per_pixel.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_padded_bits_per_pixel", pixdesc);
            }
            return (int)mh$.invokeExact(pixdesc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_desc_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pix_fmt_desc_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_desc_get$descriptor() {
        return av_pix_fmt_desc_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_pix_fmt_desc_get$handle() {
        return av_pix_fmt_desc_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_get$address() {
        return av_pix_fmt_desc_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_get(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_get(int pix_fmt) {
        var mh$ = av_pix_fmt_desc_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_desc_get", pix_fmt);
            }
            return (MemorySegment)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_desc_next {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pix_fmt_desc_next");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_desc_next$descriptor() {
        return av_pix_fmt_desc_next.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static MethodHandle av_pix_fmt_desc_next$handle() {
        return av_pix_fmt_desc_next.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_next$address() {
        return av_pix_fmt_desc_next.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVPixFmtDescriptor *av_pix_fmt_desc_next(const AVPixFmtDescriptor *prev)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_next(MemorySegment prev) {
        var mh$ = av_pix_fmt_desc_next.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_desc_next", prev);
            }
            return (MemorySegment)mh$.invokeExact(prev);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_desc_get_id {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pix_fmt_desc_get_id");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_desc_get_id$descriptor() {
        return av_pix_fmt_desc_get_id.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static MethodHandle av_pix_fmt_desc_get_id$handle() {
        return av_pix_fmt_desc_get_id.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static MemorySegment av_pix_fmt_desc_get_id$address() {
        return av_pix_fmt_desc_get_id.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_desc_get_id(const AVPixFmtDescriptor *desc)
     * }
     */
    public static int av_pix_fmt_desc_get_id(MemorySegment desc) {
        var mh$ = av_pix_fmt_desc_get_id.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_desc_get_id", desc);
            }
            return (int)mh$.invokeExact(desc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_get_chroma_sub_sample {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pix_fmt_get_chroma_sub_sample");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_get_chroma_sub_sample$descriptor() {
        return av_pix_fmt_get_chroma_sub_sample.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static MethodHandle av_pix_fmt_get_chroma_sub_sample$handle() {
        return av_pix_fmt_get_chroma_sub_sample.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static MemorySegment av_pix_fmt_get_chroma_sub_sample$address() {
        return av_pix_fmt_get_chroma_sub_sample.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_pix_fmt_get_chroma_sub_sample(enum AVPixelFormat pix_fmt, int *h_shift, int *v_shift)
     * }
     */
    public static int av_pix_fmt_get_chroma_sub_sample(int pix_fmt, MemorySegment h_shift, MemorySegment v_shift) {
        var mh$ = av_pix_fmt_get_chroma_sub_sample.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_get_chroma_sub_sample", pix_fmt, h_shift, v_shift);
            }
            return (int)mh$.invokeExact(pix_fmt, h_shift, v_shift);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_count_planes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pix_fmt_count_planes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_count_planes$descriptor() {
        return av_pix_fmt_count_planes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_pix_fmt_count_planes$handle() {
        return av_pix_fmt_count_planes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_count_planes$address() {
        return av_pix_fmt_count_planes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_pix_fmt_count_planes(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int av_pix_fmt_count_planes(int pix_fmt) {
        var mh$ = av_pix_fmt_count_planes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_count_planes", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_range_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_range_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static FunctionDescriptor av_color_range_name$descriptor() {
        return av_color_range_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static MethodHandle av_color_range_name$handle() {
        return av_color_range_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static MemorySegment av_color_range_name$address() {
        return av_color_range_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_range_name(enum AVColorRange range)
     * }
     */
    public static MemorySegment av_color_range_name(int range) {
        var mh$ = av_color_range_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_range_name", range);
            }
            return (MemorySegment)mh$.invokeExact(range);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_range_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_range_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_range_from_name$descriptor() {
        return av_color_range_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_range_from_name$handle() {
        return av_color_range_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_range_from_name$address() {
        return av_color_range_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_range_from_name(const char *name)
     * }
     */
    public static int av_color_range_from_name(MemorySegment name) {
        var mh$ = av_color_range_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_range_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_primaries_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_primaries_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static FunctionDescriptor av_color_primaries_name$descriptor() {
        return av_color_primaries_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static MethodHandle av_color_primaries_name$handle() {
        return av_color_primaries_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static MemorySegment av_color_primaries_name$address() {
        return av_color_primaries_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_primaries_name(enum AVColorPrimaries primaries)
     * }
     */
    public static MemorySegment av_color_primaries_name(int primaries) {
        var mh$ = av_color_primaries_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_primaries_name", primaries);
            }
            return (MemorySegment)mh$.invokeExact(primaries);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_primaries_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_primaries_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_primaries_from_name$descriptor() {
        return av_color_primaries_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_primaries_from_name$handle() {
        return av_color_primaries_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_primaries_from_name$address() {
        return av_color_primaries_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_primaries_from_name(const char *name)
     * }
     */
    public static int av_color_primaries_from_name(MemorySegment name) {
        var mh$ = av_color_primaries_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_primaries_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_transfer_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_transfer_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static FunctionDescriptor av_color_transfer_name$descriptor() {
        return av_color_transfer_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static MethodHandle av_color_transfer_name$handle() {
        return av_color_transfer_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static MemorySegment av_color_transfer_name$address() {
        return av_color_transfer_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_transfer_name(enum AVColorTransferCharacteristic transfer)
     * }
     */
    public static MemorySegment av_color_transfer_name(int transfer) {
        var mh$ = av_color_transfer_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_transfer_name", transfer);
            }
            return (MemorySegment)mh$.invokeExact(transfer);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_transfer_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_transfer_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_transfer_from_name$descriptor() {
        return av_color_transfer_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_transfer_from_name$handle() {
        return av_color_transfer_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_transfer_from_name$address() {
        return av_color_transfer_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_transfer_from_name(const char *name)
     * }
     */
    public static int av_color_transfer_from_name(MemorySegment name) {
        var mh$ = av_color_transfer_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_transfer_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_space_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_space_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static FunctionDescriptor av_color_space_name$descriptor() {
        return av_color_space_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static MethodHandle av_color_space_name$handle() {
        return av_color_space_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static MemorySegment av_color_space_name$address() {
        return av_color_space_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_color_space_name(enum AVColorSpace space)
     * }
     */
    public static MemorySegment av_color_space_name(int space) {
        var mh$ = av_color_space_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_space_name", space);
            }
            return (MemorySegment)mh$.invokeExact(space);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_color_space_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_color_space_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_color_space_from_name$descriptor() {
        return av_color_space_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static MethodHandle av_color_space_from_name$handle() {
        return av_color_space_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static MemorySegment av_color_space_from_name$address() {
        return av_color_space_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_color_space_from_name(const char *name)
     * }
     */
    public static int av_color_space_from_name(MemorySegment name) {
        var mh$ = av_color_space_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_color_space_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_chroma_location_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_chroma_location_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static FunctionDescriptor av_chroma_location_name$descriptor() {
        return av_chroma_location_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static MethodHandle av_chroma_location_name$handle() {
        return av_chroma_location_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static MemorySegment av_chroma_location_name$address() {
        return av_chroma_location_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_chroma_location_name(enum AVChromaLocation location)
     * }
     */
    public static MemorySegment av_chroma_location_name(int location) {
        var mh$ = av_chroma_location_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_chroma_location_name", location);
            }
            return (MemorySegment)mh$.invokeExact(location);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_chroma_location_from_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_chroma_location_from_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static FunctionDescriptor av_chroma_location_from_name$descriptor() {
        return av_chroma_location_from_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static MethodHandle av_chroma_location_from_name$handle() {
        return av_chroma_location_from_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static MemorySegment av_chroma_location_from_name$address() {
        return av_chroma_location_from_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_chroma_location_from_name(const char *name)
     * }
     */
    public static int av_chroma_location_from_name(MemorySegment name) {
        var mh$ = av_chroma_location_from_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_chroma_location_from_name", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_chroma_location_enum_to_pos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_chroma_location_enum_to_pos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static FunctionDescriptor av_chroma_location_enum_to_pos$descriptor() {
        return av_chroma_location_enum_to_pos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static MethodHandle av_chroma_location_enum_to_pos$handle() {
        return av_chroma_location_enum_to_pos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static MemorySegment av_chroma_location_enum_to_pos$address() {
        return av_chroma_location_enum_to_pos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_chroma_location_enum_to_pos(int *xpos, int *ypos, enum AVChromaLocation pos)
     * }
     */
    public static int av_chroma_location_enum_to_pos(MemorySegment xpos, MemorySegment ypos, int pos) {
        var mh$ = av_chroma_location_enum_to_pos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_chroma_location_enum_to_pos", xpos, ypos, pos);
            }
            return (int)mh$.invokeExact(xpos, ypos, pos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_chroma_location_pos_to_enum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_chroma_location_pos_to_enum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static FunctionDescriptor av_chroma_location_pos_to_enum$descriptor() {
        return av_chroma_location_pos_to_enum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static MethodHandle av_chroma_location_pos_to_enum$handle() {
        return av_chroma_location_pos_to_enum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static MemorySegment av_chroma_location_pos_to_enum$address() {
        return av_chroma_location_pos_to_enum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVChromaLocation av_chroma_location_pos_to_enum(int xpos, int ypos)
     * }
     */
    public static int av_chroma_location_pos_to_enum(int xpos, int ypos) {
        var mh$ = av_chroma_location_pos_to_enum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_chroma_location_pos_to_enum", xpos, ypos);
            }
            return (int)mh$.invokeExact(xpos, ypos);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_pix_fmt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt$descriptor() {
        return av_get_pix_fmt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static MethodHandle av_get_pix_fmt$handle() {
        return av_get_pix_fmt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static MemorySegment av_get_pix_fmt$address() {
        return av_get_pix_fmt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_get_pix_fmt(const char *name)
     * }
     */
    public static int av_get_pix_fmt(MemorySegment name) {
        var mh$ = av_get_pix_fmt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt", name);
            }
            return (int)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_pix_fmt_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt_name$descriptor() {
        return av_get_pix_fmt_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_get_pix_fmt_name$handle() {
        return av_get_pix_fmt_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_name$address() {
        return av_get_pix_fmt_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *av_get_pix_fmt_name(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_name(int pix_fmt) {
        var mh$ = av_get_pix_fmt_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt_name", pix_fmt);
            }
            return (MemorySegment)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_pix_fmt_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt_string$descriptor() {
        return av_get_pix_fmt_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_get_pix_fmt_string$handle() {
        return av_get_pix_fmt_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_string$address() {
        return av_get_pix_fmt_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *av_get_pix_fmt_string(char *buf, int buf_size, enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_get_pix_fmt_string(MemorySegment buf, int buf_size, int pix_fmt) {
        var mh$ = av_get_pix_fmt_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt_string", buf, buf_size, pix_fmt);
            }
            return (MemorySegment)mh$.invokeExact(buf, buf_size, pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_image_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_image_line2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static FunctionDescriptor av_read_image_line2$descriptor() {
        return av_read_image_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static MethodHandle av_read_image_line2$handle() {
        return av_read_image_line2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static MemorySegment av_read_image_line2$address() {
        return av_read_image_line2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_read_image_line2(void *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size)
     * }
     */
    public static void av_read_image_line2(MemorySegment dst, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w, int read_pal_component, int dst_element_size) {
        var mh$ = av_read_image_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_image_line2", dst, data, linesize, desc, x, y, c, w, read_pal_component, dst_element_size);
            }
            mh$.invokeExact(dst, data, linesize, desc, x, y, c, w, read_pal_component, dst_element_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_read_image_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_read_image_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static FunctionDescriptor av_read_image_line$descriptor() {
        return av_read_image_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static MethodHandle av_read_image_line$handle() {
        return av_read_image_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static MemorySegment av_read_image_line$address() {
        return av_read_image_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_read_image_line(uint16_t *dst, const uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int read_pal_component)
     * }
     */
    public static void av_read_image_line(MemorySegment dst, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w, int read_pal_component) {
        var mh$ = av_read_image_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_read_image_line", dst, data, linesize, desc, x, y, c, w, read_pal_component);
            }
            mh$.invokeExact(dst, data, linesize, desc, x, y, c, w, read_pal_component);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_image_line2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_image_line2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static FunctionDescriptor av_write_image_line2$descriptor() {
        return av_write_image_line2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static MethodHandle av_write_image_line2$handle() {
        return av_write_image_line2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static MemorySegment av_write_image_line2$address() {
        return av_write_image_line2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_write_image_line2(const void *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w, int src_element_size)
     * }
     */
    public static void av_write_image_line2(MemorySegment src, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w, int src_element_size) {
        var mh$ = av_write_image_line2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_image_line2", src, data, linesize, desc, x, y, c, w, src_element_size);
            }
            mh$.invokeExact(src, data, linesize, desc, x, y, c, w, src_element_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_write_image_line {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_write_image_line");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static FunctionDescriptor av_write_image_line$descriptor() {
        return av_write_image_line.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static MethodHandle av_write_image_line$handle() {
        return av_write_image_line.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static MemorySegment av_write_image_line$address() {
        return av_write_image_line.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_write_image_line(const uint16_t *src, uint8_t *data[4], const int linesize[4], const AVPixFmtDescriptor *desc, int x, int y, int c, int w)
     * }
     */
    public static void av_write_image_line(MemorySegment src, MemorySegment data, MemorySegment linesize, MemorySegment desc, int x, int y, int c, int w) {
        var mh$ = av_write_image_line.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_write_image_line", src, data, linesize, desc, x, y, c, w);
            }
            mh$.invokeExact(src, data, linesize, desc, x, y, c, w);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_pix_fmt_swap_endianness {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_pix_fmt_swap_endianness");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor av_pix_fmt_swap_endianness$descriptor() {
        return av_pix_fmt_swap_endianness.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle av_pix_fmt_swap_endianness$handle() {
        return av_pix_fmt_swap_endianness.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment av_pix_fmt_swap_endianness$address() {
        return av_pix_fmt_swap_endianness.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_pix_fmt_swap_endianness(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int av_pix_fmt_swap_endianness(int pix_fmt) {
        var mh$ = av_pix_fmt_swap_endianness.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_pix_fmt_swap_endianness", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_get_pix_fmt_loss {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_get_pix_fmt_loss");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static FunctionDescriptor av_get_pix_fmt_loss$descriptor() {
        return av_get_pix_fmt_loss.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static MethodHandle av_get_pix_fmt_loss$handle() {
        return av_get_pix_fmt_loss.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static MemorySegment av_get_pix_fmt_loss$address() {
        return av_get_pix_fmt_loss.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_get_pix_fmt_loss(enum AVPixelFormat dst_pix_fmt, enum AVPixelFormat src_pix_fmt, int has_alpha)
     * }
     */
    public static int av_get_pix_fmt_loss(int dst_pix_fmt, int src_pix_fmt, int has_alpha) {
        var mh$ = av_get_pix_fmt_loss.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_get_pix_fmt_loss", dst_pix_fmt, src_pix_fmt, has_alpha);
            }
            return (int)mh$.invokeExact(dst_pix_fmt, src_pix_fmt, has_alpha);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_find_best_pix_fmt_of_2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_find_best_pix_fmt_of_2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static FunctionDescriptor av_find_best_pix_fmt_of_2$descriptor() {
        return av_find_best_pix_fmt_of_2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MethodHandle av_find_best_pix_fmt_of_2$handle() {
        return av_find_best_pix_fmt_of_2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static MemorySegment av_find_best_pix_fmt_of_2$address() {
        return av_find_best_pix_fmt_of_2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVPixelFormat av_find_best_pix_fmt_of_2(enum AVPixelFormat dst_pix_fmt1, enum AVPixelFormat dst_pix_fmt2, enum AVPixelFormat src_pix_fmt, int has_alpha, int *loss_ptr)
     * }
     */
    public static int av_find_best_pix_fmt_of_2(int dst_pix_fmt1, int dst_pix_fmt2, int src_pix_fmt, int has_alpha, MemorySegment loss_ptr) {
        var mh$ = av_find_best_pix_fmt_of_2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_find_best_pix_fmt_of_2", dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr);
            }
            return (int)mh$.invokeExact(dst_pix_fmt1, dst_pix_fmt2, src_pix_fmt, has_alpha, loss_ptr);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_max_pixsteps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_max_pixsteps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static FunctionDescriptor av_image_fill_max_pixsteps$descriptor() {
        return av_image_fill_max_pixsteps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MethodHandle av_image_fill_max_pixsteps$handle() {
        return av_image_fill_max_pixsteps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static MemorySegment av_image_fill_max_pixsteps$address() {
        return av_image_fill_max_pixsteps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_fill_max_pixsteps(int max_pixsteps[4], int max_pixstep_comps[4], const AVPixFmtDescriptor *pixdesc)
     * }
     */
    public static void av_image_fill_max_pixsteps(MemorySegment max_pixsteps, MemorySegment max_pixstep_comps, MemorySegment pixdesc) {
        var mh$ = av_image_fill_max_pixsteps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_max_pixsteps", max_pixsteps, max_pixstep_comps, pixdesc);
            }
            mh$.invokeExact(max_pixsteps, max_pixstep_comps, pixdesc);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_get_linesize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_get_linesize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static FunctionDescriptor av_image_get_linesize$descriptor() {
        return av_image_get_linesize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static MethodHandle av_image_get_linesize$handle() {
        return av_image_get_linesize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static MemorySegment av_image_get_linesize$address() {
        return av_image_get_linesize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_get_linesize(enum AVPixelFormat pix_fmt, int width, int plane)
     * }
     */
    public static int av_image_get_linesize(int pix_fmt, int width, int plane) {
        var mh$ = av_image_get_linesize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_get_linesize", pix_fmt, width, plane);
            }
            return (int)mh$.invokeExact(pix_fmt, width, plane);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_linesizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_linesizes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static FunctionDescriptor av_image_fill_linesizes$descriptor() {
        return av_image_fill_linesizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static MethodHandle av_image_fill_linesizes$handle() {
        return av_image_fill_linesizes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static MemorySegment av_image_fill_linesizes$address() {
        return av_image_fill_linesizes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_linesizes(int linesizes[4], enum AVPixelFormat pix_fmt, int width)
     * }
     */
    public static int av_image_fill_linesizes(MemorySegment linesizes, int pix_fmt, int width) {
        var mh$ = av_image_fill_linesizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_linesizes", linesizes, pix_fmt, width);
            }
            return (int)mh$.invokeExact(linesizes, pix_fmt, width);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_plane_sizes {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_plane_sizes");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static FunctionDescriptor av_image_fill_plane_sizes$descriptor() {
        return av_image_fill_plane_sizes.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static MethodHandle av_image_fill_plane_sizes$handle() {
        return av_image_fill_plane_sizes.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static MemorySegment av_image_fill_plane_sizes$address() {
        return av_image_fill_plane_sizes.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_plane_sizes(size_t size[4], enum AVPixelFormat pix_fmt, int height, const ptrdiff_t linesizes[4])
     * }
     */
    public static int av_image_fill_plane_sizes(MemorySegment size, int pix_fmt, int height, MemorySegment linesizes) {
        var mh$ = av_image_fill_plane_sizes.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_plane_sizes", size, pix_fmt, height, linesizes);
            }
            return (int)mh$.invokeExact(size, pix_fmt, height, linesizes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_pointers {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_pointers");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static FunctionDescriptor av_image_fill_pointers$descriptor() {
        return av_image_fill_pointers.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static MethodHandle av_image_fill_pointers$handle() {
        return av_image_fill_pointers.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static MemorySegment av_image_fill_pointers$address() {
        return av_image_fill_pointers.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_pointers(uint8_t *data[4], enum AVPixelFormat pix_fmt, int height, uint8_t *ptr, const int linesizes[4])
     * }
     */
    public static int av_image_fill_pointers(MemorySegment data, int pix_fmt, int height, MemorySegment ptr, MemorySegment linesizes) {
        var mh$ = av_image_fill_pointers.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_pointers", data, pix_fmt, height, ptr, linesizes);
            }
            return (int)mh$.invokeExact(data, pix_fmt, height, ptr, linesizes);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static FunctionDescriptor av_image_alloc$descriptor() {
        return av_image_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static MethodHandle av_image_alloc$handle() {
        return av_image_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static MemorySegment av_image_alloc$address() {
        return av_image_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_alloc(uint8_t *pointers[4], int linesizes[4], int w, int h, enum AVPixelFormat pix_fmt, int align)
     * }
     */
    public static int av_image_alloc(MemorySegment pointers, MemorySegment linesizes, int w, int h, int pix_fmt, int align) {
        var mh$ = av_image_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_alloc", pointers, linesizes, w, h, pix_fmt, align);
            }
            return (int)mh$.invokeExact(pointers, linesizes, w, h, pix_fmt, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_plane {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_plane");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_plane$descriptor() {
        return av_image_copy_plane.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static MethodHandle av_image_copy_plane$handle() {
        return av_image_copy_plane.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static MemorySegment av_image_copy_plane$address() {
        return av_image_copy_plane.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_plane(uint8_t *dst, int dst_linesize, const uint8_t *src, int src_linesize, int bytewidth, int height)
     * }
     */
    public static void av_image_copy_plane(MemorySegment dst, int dst_linesize, MemorySegment src, int src_linesize, int bytewidth, int height) {
        var mh$ = av_image_copy_plane.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_plane", dst, dst_linesize, src, src_linesize, bytewidth, height);
            }
            mh$.invokeExact(dst, dst_linesize, src, src_linesize, bytewidth, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_plane_uc_from {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG,
            FFmpeg.C_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_plane_uc_from");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_plane_uc_from$descriptor() {
        return av_image_copy_plane_uc_from.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static MethodHandle av_image_copy_plane_uc_from$handle() {
        return av_image_copy_plane_uc_from.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static MemorySegment av_image_copy_plane_uc_from$address() {
        return av_image_copy_plane_uc_from.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_plane_uc_from(uint8_t *dst, ptrdiff_t dst_linesize, const uint8_t *src, ptrdiff_t src_linesize, ptrdiff_t bytewidth, int height)
     * }
     */
    public static void av_image_copy_plane_uc_from(MemorySegment dst, long dst_linesize, MemorySegment src, long src_linesize, long bytewidth, int height) {
        var mh$ = av_image_copy_plane_uc_from.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_plane_uc_from", dst, dst_linesize, src, src_linesize, bytewidth, height);
            }
            mh$.invokeExact(dst, dst_linesize, src, src_linesize, bytewidth, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy$descriptor() {
        return av_image_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MethodHandle av_image_copy$handle() {
        return av_image_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MemorySegment av_image_copy$address() {
        return av_image_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy(uint8_t *const dst_data[4], const int dst_linesizes[4], const uint8_t *const src_data[4], const int src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static void av_image_copy(MemorySegment dst_data, MemorySegment dst_linesizes, MemorySegment src_data, MemorySegment src_linesizes, int pix_fmt, int width, int height) {
        var mh$ = av_image_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy", dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
            }
            mh$.invokeExact(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_uc_from {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_uc_from");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_copy_uc_from$descriptor() {
        return av_image_copy_uc_from.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MethodHandle av_image_copy_uc_from$handle() {
        return av_image_copy_uc_from.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static MemorySegment av_image_copy_uc_from$address() {
        return av_image_copy_uc_from.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_image_copy_uc_from(uint8_t *const dst_data[4], const ptrdiff_t dst_linesizes[4], const uint8_t *const src_data[4], const ptrdiff_t src_linesizes[4], enum AVPixelFormat pix_fmt, int width, int height)
     * }
     */
    public static void av_image_copy_uc_from(MemorySegment dst_data, MemorySegment dst_linesizes, MemorySegment src_data, MemorySegment src_linesizes, int pix_fmt, int width, int height) {
        var mh$ = av_image_copy_uc_from.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_uc_from", dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
            }
            mh$.invokeExact(dst_data, dst_linesizes, src_data, src_linesizes, pix_fmt, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_arrays {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_arrays");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_fill_arrays$descriptor() {
        return av_image_fill_arrays.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_fill_arrays$handle() {
        return av_image_fill_arrays.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_fill_arrays$address() {
        return av_image_fill_arrays.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_arrays(uint8_t *dst_data[4], int dst_linesize[4], const uint8_t *src, enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_fill_arrays(MemorySegment dst_data, MemorySegment dst_linesize, MemorySegment src, int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_fill_arrays.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_arrays", dst_data, dst_linesize, src, pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, src, pix_fmt, width, height, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_get_buffer_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_get_buffer_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_get_buffer_size$descriptor() {
        return av_image_get_buffer_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_get_buffer_size$handle() {
        return av_image_get_buffer_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_get_buffer_size$address() {
        return av_image_get_buffer_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_get_buffer_size(enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_get_buffer_size(int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_get_buffer_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_get_buffer_size", pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(pix_fmt, width, height, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_copy_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_copy_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static FunctionDescriptor av_image_copy_to_buffer$descriptor() {
        return av_image_copy_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MethodHandle av_image_copy_to_buffer$handle() {
        return av_image_copy_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static MemorySegment av_image_copy_to_buffer$address() {
        return av_image_copy_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_copy_to_buffer(uint8_t *dst, int dst_size, const uint8_t *const src_data[4], const int src_linesize[4], enum AVPixelFormat pix_fmt, int width, int height, int align)
     * }
     */
    public static int av_image_copy_to_buffer(MemorySegment dst, int dst_size, MemorySegment src_data, MemorySegment src_linesize, int pix_fmt, int width, int height, int align) {
        var mh$ = av_image_copy_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_copy_to_buffer", dst, dst_size, src_data, src_linesize, pix_fmt, width, height, align);
            }
            return (int)mh$.invokeExact(dst, dst_size, src_data, src_linesize, pix_fmt, width, height, align);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_check_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static FunctionDescriptor av_image_check_size$descriptor() {
        return av_image_check_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static MethodHandle av_image_check_size$handle() {
        return av_image_check_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static MemorySegment av_image_check_size$address() {
        return av_image_check_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_size(unsigned int w, unsigned int h, int log_offset, void *log_ctx)
     * }
     */
    public static int av_image_check_size(int w, int h, int log_offset, MemorySegment log_ctx) {
        var mh$ = av_image_check_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_size", w, h, log_offset, log_ctx);
            }
            return (int)mh$.invokeExact(w, h, log_offset, log_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_size2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_check_size2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static FunctionDescriptor av_image_check_size2$descriptor() {
        return av_image_check_size2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static MethodHandle av_image_check_size2$handle() {
        return av_image_check_size2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static MemorySegment av_image_check_size2$address() {
        return av_image_check_size2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_size2(unsigned int w, unsigned int h, int64_t max_pixels, enum AVPixelFormat pix_fmt, int log_offset, void *log_ctx)
     * }
     */
    public static int av_image_check_size2(int w, int h, long max_pixels, int pix_fmt, int log_offset, MemorySegment log_ctx) {
        var mh$ = av_image_check_size2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_size2", w, h, max_pixels, pix_fmt, log_offset, log_ctx);
            }
            return (int)mh$.invokeExact(w, h, max_pixels, pix_fmt, log_offset, log_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_check_sar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            AVRational.layout()
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_check_sar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static FunctionDescriptor av_image_check_sar$descriptor() {
        return av_image_check_sar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static MethodHandle av_image_check_sar$handle() {
        return av_image_check_sar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static MemorySegment av_image_check_sar$address() {
        return av_image_check_sar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)
     * }
     */
    public static int av_image_check_sar(int w, int h, MemorySegment sar) {
        var mh$ = av_image_check_sar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_check_sar", w, h, sar);
            }
            return (int)mh$.invokeExact(w, h, sar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_black {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_black");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static FunctionDescriptor av_image_fill_black$descriptor() {
        return av_image_fill_black.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static MethodHandle av_image_fill_black$handle() {
        return av_image_fill_black.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static MemorySegment av_image_fill_black$address() {
        return av_image_fill_black.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_black(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, enum AVColorRange range, int width, int height)
     * }
     */
    public static int av_image_fill_black(MemorySegment dst_data, MemorySegment dst_linesize, int pix_fmt, int range, int width, int height) {
        var mh$ = av_image_fill_black.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_black", dst_data, dst_linesize, pix_fmt, range, width, height);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, pix_fmt, range, width, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_image_fill_color {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_image_fill_color");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static FunctionDescriptor av_image_fill_color$descriptor() {
        return av_image_fill_color.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static MethodHandle av_image_fill_color$handle() {
        return av_image_fill_color.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static MemorySegment av_image_fill_color$address() {
        return av_image_fill_color.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_image_fill_color(uint8_t *const dst_data[4], const ptrdiff_t dst_linesize[4], enum AVPixelFormat pix_fmt, const uint32_t color[4], int width, int height, int flags)
     * }
     */
    public static int av_image_fill_color(MemorySegment dst_data, MemorySegment dst_linesize, int pix_fmt, MemorySegment color, int width, int height, int flags) {
        var mh$ = av_image_fill_color.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_image_fill_color", dst_data, dst_linesize, pix_fmt, color, width, height, flags);
            }
            return (int)mh$.invokeExact(dst_data, dst_linesize, pix_fmt, color, width, height, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swscale_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static FunctionDescriptor swscale_version$descriptor() {
        return swscale_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static MethodHandle swscale_version$handle() {
        return swscale_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static MemorySegment swscale_version$address() {
        return swscale_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int swscale_version()
     * }
     */
    public static int swscale_version() {
        var mh$ = swscale_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swscale_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static FunctionDescriptor swscale_configuration$descriptor() {
        return swscale_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MethodHandle swscale_configuration$handle() {
        return swscale_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MemorySegment swscale_configuration$address() {
        return swscale_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *swscale_configuration()
     * }
     */
    public static MemorySegment swscale_configuration() {
        var mh$ = swscale_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class swscale_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("swscale_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static FunctionDescriptor swscale_license$descriptor() {
        return swscale_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MethodHandle swscale_license$handle() {
        return swscale_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MemorySegment swscale_license$address() {
        return swscale_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *swscale_license()
     * }
     */
    public static MemorySegment swscale_license() {
        var mh$ = swscale_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("swscale_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static FunctionDescriptor sws_get_class$descriptor() {
        return sws_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MethodHandle sws_get_class$handle() {
        return sws_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MemorySegment sws_get_class$address() {
        return sws_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *sws_get_class()
     * }
     */
    public static MemorySegment sws_get_class() {
        var mh$ = sws_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SWS_DITHER_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SwsDither.SWS_DITHER_NONE = 0
     * }
     */
    public static int SWS_DITHER_NONE() {
        return SWS_DITHER_NONE;
    }
    private static final int SWS_DITHER_AUTO = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SwsDither.SWS_DITHER_AUTO = 1
     * }
     */
    public static int SWS_DITHER_AUTO() {
        return SWS_DITHER_AUTO;
    }
    private static final int SWS_DITHER_BAYER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SwsDither.SWS_DITHER_BAYER = 2
     * }
     */
    public static int SWS_DITHER_BAYER() {
        return SWS_DITHER_BAYER;
    }
    private static final int SWS_DITHER_ED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SwsDither.SWS_DITHER_ED = 3
     * }
     */
    public static int SWS_DITHER_ED() {
        return SWS_DITHER_ED;
    }
    private static final int SWS_DITHER_A_DITHER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SwsDither.SWS_DITHER_A_DITHER = 4
     * }
     */
    public static int SWS_DITHER_A_DITHER() {
        return SWS_DITHER_A_DITHER;
    }
    private static final int SWS_DITHER_X_DITHER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SwsDither.SWS_DITHER_X_DITHER = 5
     * }
     */
    public static int SWS_DITHER_X_DITHER() {
        return SWS_DITHER_X_DITHER;
    }
    private static final int SWS_DITHER_NB = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SwsDither.SWS_DITHER_NB = 6
     * }
     */
    public static int SWS_DITHER_NB() {
        return SWS_DITHER_NB;
    }
    private static final int SWS_ALPHA_BLEND_NONE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SwsAlphaBlend.SWS_ALPHA_BLEND_NONE = 0
     * }
     */
    public static int SWS_ALPHA_BLEND_NONE() {
        return SWS_ALPHA_BLEND_NONE;
    }
    private static final int SWS_ALPHA_BLEND_UNIFORM = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SwsAlphaBlend.SWS_ALPHA_BLEND_UNIFORM = 1
     * }
     */
    public static int SWS_ALPHA_BLEND_UNIFORM() {
        return SWS_ALPHA_BLEND_UNIFORM;
    }
    private static final int SWS_ALPHA_BLEND_CHECKERBOARD = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SwsAlphaBlend.SWS_ALPHA_BLEND_CHECKERBOARD = 2
     * }
     */
    public static int SWS_ALPHA_BLEND_CHECKERBOARD() {
        return SWS_ALPHA_BLEND_CHECKERBOARD;
    }
    private static final int SWS_ALPHA_BLEND_NB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SwsAlphaBlend.SWS_ALPHA_BLEND_NB = 3
     * }
     */
    public static int SWS_ALPHA_BLEND_NB() {
        return SWS_ALPHA_BLEND_NB;
    }
    private static final int SWS_FAST_BILINEAR = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_FAST_BILINEAR = 1
     * }
     */
    public static int SWS_FAST_BILINEAR() {
        return SWS_FAST_BILINEAR;
    }
    private static final int SWS_BILINEAR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BILINEAR = 2
     * }
     */
    public static int SWS_BILINEAR() {
        return SWS_BILINEAR;
    }
    private static final int SWS_BICUBIC = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BICUBIC = 4
     * }
     */
    public static int SWS_BICUBIC() {
        return SWS_BICUBIC;
    }
    private static final int SWS_X = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_X = 8
     * }
     */
    public static int SWS_X() {
        return SWS_X;
    }
    private static final int SWS_POINT = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_POINT = 16
     * }
     */
    public static int SWS_POINT() {
        return SWS_POINT;
    }
    private static final int SWS_AREA = (int)32L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_AREA = 32
     * }
     */
    public static int SWS_AREA() {
        return SWS_AREA;
    }
    private static final int SWS_BICUBLIN = (int)64L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BICUBLIN = 64
     * }
     */
    public static int SWS_BICUBLIN() {
        return SWS_BICUBLIN;
    }
    private static final int SWS_GAUSS = (int)128L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_GAUSS = 128
     * }
     */
    public static int SWS_GAUSS() {
        return SWS_GAUSS;
    }
    private static final int SWS_SINC = (int)256L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_SINC = 256
     * }
     */
    public static int SWS_SINC() {
        return SWS_SINC;
    }
    private static final int SWS_LANCZOS = (int)512L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_LANCZOS = 512
     * }
     */
    public static int SWS_LANCZOS() {
        return SWS_LANCZOS;
    }
    private static final int SWS_SPLINE = (int)1024L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_SPLINE = 1024
     * }
     */
    public static int SWS_SPLINE() {
        return SWS_SPLINE;
    }
    private static final int SWS_STRICT = (int)2048L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_STRICT = 2048
     * }
     */
    public static int SWS_STRICT() {
        return SWS_STRICT;
    }
    private static final int SWS_PRINT_INFO = (int)4096L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_PRINT_INFO = 4096
     * }
     */
    public static int SWS_PRINT_INFO() {
        return SWS_PRINT_INFO;
    }
    private static final int SWS_FULL_CHR_H_INT = (int)8192L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_FULL_CHR_H_INT = 8192
     * }
     */
    public static int SWS_FULL_CHR_H_INT() {
        return SWS_FULL_CHR_H_INT;
    }
    private static final int SWS_FULL_CHR_H_INP = (int)16384L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_FULL_CHR_H_INP = 16384
     * }
     */
    public static int SWS_FULL_CHR_H_INP() {
        return SWS_FULL_CHR_H_INP;
    }
    private static final int SWS_ACCURATE_RND = (int)262144L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_ACCURATE_RND = 262144
     * }
     */
    public static int SWS_ACCURATE_RND() {
        return SWS_ACCURATE_RND;
    }
    private static final int SWS_BITEXACT = (int)524288L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_BITEXACT = 524288
     * }
     */
    public static int SWS_BITEXACT() {
        return SWS_BITEXACT;
    }
    private static final int SWS_DIRECT_BGR = (int)32768L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_DIRECT_BGR = 32768
     * }
     */
    public static int SWS_DIRECT_BGR() {
        return SWS_DIRECT_BGR;
    }
    private static final int SWS_ERROR_DIFFUSION = (int)8388608L;
    /**
     * {@snippet lang=c :
     * enum SwsFlags.SWS_ERROR_DIFFUSION = 8388608
     * }
     */
    public static int SWS_ERROR_DIFFUSION() {
        return SWS_ERROR_DIFFUSION;
    }
    private static final int SWS_INTENT_PERCEPTUAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SwsIntent.SWS_INTENT_PERCEPTUAL = 0
     * }
     */
    public static int SWS_INTENT_PERCEPTUAL() {
        return SWS_INTENT_PERCEPTUAL;
    }
    private static final int SWS_INTENT_RELATIVE_COLORIMETRIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SwsIntent.SWS_INTENT_RELATIVE_COLORIMETRIC = 1
     * }
     */
    public static int SWS_INTENT_RELATIVE_COLORIMETRIC() {
        return SWS_INTENT_RELATIVE_COLORIMETRIC;
    }
    private static final int SWS_INTENT_SATURATION = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SwsIntent.SWS_INTENT_SATURATION = 2
     * }
     */
    public static int SWS_INTENT_SATURATION() {
        return SWS_INTENT_SATURATION;
    }
    private static final int SWS_INTENT_ABSOLUTE_COLORIMETRIC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SwsIntent.SWS_INTENT_ABSOLUTE_COLORIMETRIC = 3
     * }
     */
    public static int SWS_INTENT_ABSOLUTE_COLORIMETRIC() {
        return SWS_INTENT_ABSOLUTE_COLORIMETRIC;
    }
    private static final int SWS_INTENT_NB = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SwsIntent.SWS_INTENT_NB = 4
     * }
     */
    public static int SWS_INTENT_NB() {
        return SWS_INTENT_NB;
    }

    private static class sws_alloc_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_alloc_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static FunctionDescriptor sws_alloc_context$descriptor() {
        return sws_alloc_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static MethodHandle sws_alloc_context$handle() {
        return sws_alloc_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static MemorySegment sws_alloc_context$address() {
        return sws_alloc_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsContext *sws_alloc_context()
     * }
     */
    public static MemorySegment sws_alloc_context() {
        var mh$ = sws_alloc_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_alloc_context");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_free_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_free_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_free_context(SwsContext **ctx)
     * }
     */
    public static FunctionDescriptor sws_free_context$descriptor() {
        return sws_free_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_free_context(SwsContext **ctx)
     * }
     */
    public static MethodHandle sws_free_context$handle() {
        return sws_free_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_free_context(SwsContext **ctx)
     * }
     */
    public static MemorySegment sws_free_context$address() {
        return sws_free_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_free_context(SwsContext **ctx)
     * }
     */
    public static void sws_free_context(MemorySegment ctx) {
        var mh$ = sws_free_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_free_context", ctx);
            }
            mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_test_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_test_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_test_format(enum AVPixelFormat format, int output)
     * }
     */
    public static FunctionDescriptor sws_test_format$descriptor() {
        return sws_test_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_test_format(enum AVPixelFormat format, int output)
     * }
     */
    public static MethodHandle sws_test_format$handle() {
        return sws_test_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_test_format(enum AVPixelFormat format, int output)
     * }
     */
    public static MemorySegment sws_test_format$address() {
        return sws_test_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_test_format(enum AVPixelFormat format, int output)
     * }
     */
    public static int sws_test_format(int format, int output) {
        var mh$ = sws_test_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_test_format", format, output);
            }
            return (int)mh$.invokeExact(format, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_test_colorspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_test_colorspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_test_colorspace(enum AVColorSpace colorspace, int output)
     * }
     */
    public static FunctionDescriptor sws_test_colorspace$descriptor() {
        return sws_test_colorspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_test_colorspace(enum AVColorSpace colorspace, int output)
     * }
     */
    public static MethodHandle sws_test_colorspace$handle() {
        return sws_test_colorspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_test_colorspace(enum AVColorSpace colorspace, int output)
     * }
     */
    public static MemorySegment sws_test_colorspace$address() {
        return sws_test_colorspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_test_colorspace(enum AVColorSpace colorspace, int output)
     * }
     */
    public static int sws_test_colorspace(int colorspace, int output) {
        var mh$ = sws_test_colorspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_test_colorspace", colorspace, output);
            }
            return (int)mh$.invokeExact(colorspace, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_test_primaries {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_test_primaries");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_test_primaries(enum AVColorPrimaries primaries, int output)
     * }
     */
    public static FunctionDescriptor sws_test_primaries$descriptor() {
        return sws_test_primaries.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_test_primaries(enum AVColorPrimaries primaries, int output)
     * }
     */
    public static MethodHandle sws_test_primaries$handle() {
        return sws_test_primaries.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_test_primaries(enum AVColorPrimaries primaries, int output)
     * }
     */
    public static MemorySegment sws_test_primaries$address() {
        return sws_test_primaries.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_test_primaries(enum AVColorPrimaries primaries, int output)
     * }
     */
    public static int sws_test_primaries(int primaries, int output) {
        var mh$ = sws_test_primaries.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_test_primaries", primaries, output);
            }
            return (int)mh$.invokeExact(primaries, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_test_transfer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_test_transfer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_test_transfer(enum AVColorTransferCharacteristic trc, int output)
     * }
     */
    public static FunctionDescriptor sws_test_transfer$descriptor() {
        return sws_test_transfer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_test_transfer(enum AVColorTransferCharacteristic trc, int output)
     * }
     */
    public static MethodHandle sws_test_transfer$handle() {
        return sws_test_transfer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_test_transfer(enum AVColorTransferCharacteristic trc, int output)
     * }
     */
    public static MemorySegment sws_test_transfer$address() {
        return sws_test_transfer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_test_transfer(enum AVColorTransferCharacteristic trc, int output)
     * }
     */
    public static int sws_test_transfer(int trc, int output) {
        var mh$ = sws_test_transfer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_test_transfer", trc, output);
            }
            return (int)mh$.invokeExact(trc, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_test_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_test_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_test_frame(const AVFrame *frame, int output)
     * }
     */
    public static FunctionDescriptor sws_test_frame$descriptor() {
        return sws_test_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_test_frame(const AVFrame *frame, int output)
     * }
     */
    public static MethodHandle sws_test_frame$handle() {
        return sws_test_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_test_frame(const AVFrame *frame, int output)
     * }
     */
    public static MemorySegment sws_test_frame$address() {
        return sws_test_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_test_frame(const AVFrame *frame, int output)
     * }
     */
    public static int sws_test_frame(MemorySegment frame, int output) {
        var mh$ = sws_test_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_test_frame", frame, output);
            }
            return (int)mh$.invokeExact(frame, output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_frame_setup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_frame_setup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_frame_setup(SwsContext *ctx, const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_frame_setup$descriptor() {
        return sws_frame_setup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_frame_setup(SwsContext *ctx, const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_frame_setup$handle() {
        return sws_frame_setup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_frame_setup(SwsContext *ctx, const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_frame_setup$address() {
        return sws_frame_setup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_frame_setup(SwsContext *ctx, const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_frame_setup(MemorySegment ctx, MemorySegment dst, MemorySegment src) {
        var mh$ = sws_frame_setup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_frame_setup", ctx, dst, src);
            }
            return (int)mh$.invokeExact(ctx, dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_is_noop {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_is_noop");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_is_noop(const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_is_noop$descriptor() {
        return sws_is_noop.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_is_noop(const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_is_noop$handle() {
        return sws_is_noop.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_is_noop(const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_is_noop$address() {
        return sws_is_noop.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_is_noop(const AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_is_noop(MemorySegment dst, MemorySegment src) {
        var mh$ = sws_is_noop.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_is_noop", dst, src);
            }
            return (int)mh$.invokeExact(dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scale_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_scale_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_scale_frame$descriptor() {
        return sws_scale_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_scale_frame$handle() {
        return sws_scale_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_scale_frame$address() {
        return sws_scale_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_scale_frame(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_scale_frame(MemorySegment c, MemorySegment dst, MemorySegment src) {
        var mh$ = sws_scale_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scale_frame", c, dst, src);
            }
            return (int)mh$.invokeExact(c, dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getCoefficients {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getCoefficients");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static FunctionDescriptor sws_getCoefficients$descriptor() {
        return sws_getCoefficients.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MethodHandle sws_getCoefficients$handle() {
        return sws_getCoefficients.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MemorySegment sws_getCoefficients$address() {
        return sws_getCoefficients.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const int *sws_getCoefficients(int colorspace)
     * }
     */
    public static MemorySegment sws_getCoefficients(int colorspace) {
        var mh$ = sws_getCoefficients.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getCoefficients", colorspace);
            }
            return (MemorySegment)mh$.invokeExact(colorspace);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedInput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_isSupportedInput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedInput$descriptor() {
        return sws_isSupportedInput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedInput$handle() {
        return sws_isSupportedInput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedInput$address() {
        return sws_isSupportedInput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedInput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedInput(int pix_fmt) {
        var mh$ = sws_isSupportedInput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedInput", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedOutput {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_isSupportedOutput");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedOutput$descriptor() {
        return sws_isSupportedOutput.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedOutput$handle() {
        return sws_isSupportedOutput.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedOutput$address() {
        return sws_isSupportedOutput.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedOutput(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedOutput(int pix_fmt) {
        var mh$ = sws_isSupportedOutput.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedOutput", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_isSupportedEndiannessConversion {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_isSupportedEndiannessConversion");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static FunctionDescriptor sws_isSupportedEndiannessConversion$descriptor() {
        return sws_isSupportedEndiannessConversion.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MethodHandle sws_isSupportedEndiannessConversion$handle() {
        return sws_isSupportedEndiannessConversion.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static MemorySegment sws_isSupportedEndiannessConversion$address() {
        return sws_isSupportedEndiannessConversion.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_isSupportedEndiannessConversion(enum AVPixelFormat pix_fmt)
     * }
     */
    public static int sws_isSupportedEndiannessConversion(int pix_fmt) {
        var mh$ = sws_isSupportedEndiannessConversion.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_isSupportedEndiannessConversion", pix_fmt);
            }
            return (int)mh$.invokeExact(pix_fmt);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_init_context {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_init_context");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static FunctionDescriptor sws_init_context$descriptor() {
        return sws_init_context.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static MethodHandle sws_init_context$handle() {
        return sws_init_context.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static MemorySegment sws_init_context$address() {
        return sws_init_context.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_init_context(SwsContext *sws_context, SwsFilter *srcFilter, SwsFilter *dstFilter)
     * }
     */
    public static int sws_init_context(MemorySegment sws_context, MemorySegment srcFilter, MemorySegment dstFilter) {
        var mh$ = sws_init_context.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_init_context", sws_context, srcFilter, dstFilter);
            }
            return (int)mh$.invokeExact(sws_context, srcFilter, dstFilter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_freeContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static FunctionDescriptor sws_freeContext$descriptor() {
        return sws_freeContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static MethodHandle sws_freeContext$handle() {
        return sws_freeContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static MemorySegment sws_freeContext$address() {
        return sws_freeContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeContext(SwsContext *swsContext)
     * }
     */
    public static void sws_freeContext(MemorySegment swsContext) {
        var mh$ = sws_freeContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeContext", swsContext);
            }
            mh$.invokeExact(swsContext);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static FunctionDescriptor sws_getContext$descriptor() {
        return sws_getContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MethodHandle sws_getContext$handle() {
        return sws_getContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getContext$address() {
        return sws_getContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsContext *sws_getContext(int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getContext(int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, MemorySegment srcFilter, MemorySegment dstFilter, MemorySegment param) {
        var mh$ = sws_getContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getContext", srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
            }
            return (MemorySegment)mh$.invokeExact(srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scale {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_scale");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static FunctionDescriptor sws_scale$descriptor() {
        return sws_scale.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static MethodHandle sws_scale$handle() {
        return sws_scale.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static MemorySegment sws_scale$address() {
        return sws_scale.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_scale(SwsContext *c, const uint8_t *const srcSlice[], const int srcStride[], int srcSliceY, int srcSliceH, uint8_t *const dst[], const int dstStride[])
     * }
     */
    public static int sws_scale(MemorySegment c, MemorySegment srcSlice, MemorySegment srcStride, int srcSliceY, int srcSliceH, MemorySegment dst, MemorySegment dstStride) {
        var mh$ = sws_scale.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scale", c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride);
            }
            return (int)mh$.invokeExact(c, srcSlice, srcStride, srcSliceY, srcSliceH, dst, dstStride);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_frame_start {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_frame_start");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static FunctionDescriptor sws_frame_start$descriptor() {
        return sws_frame_start.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MethodHandle sws_frame_start$handle() {
        return sws_frame_start.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static MemorySegment sws_frame_start$address() {
        return sws_frame_start.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_frame_start(SwsContext *c, AVFrame *dst, const AVFrame *src)
     * }
     */
    public static int sws_frame_start(MemorySegment c, MemorySegment dst, MemorySegment src) {
        var mh$ = sws_frame_start.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_frame_start", c, dst, src);
            }
            return (int)mh$.invokeExact(c, dst, src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_frame_end {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_frame_end");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static FunctionDescriptor sws_frame_end$descriptor() {
        return sws_frame_end.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static MethodHandle sws_frame_end$handle() {
        return sws_frame_end.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static MemorySegment sws_frame_end$address() {
        return sws_frame_end.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_frame_end(SwsContext *c)
     * }
     */
    public static void sws_frame_end(MemorySegment c) {
        var mh$ = sws_frame_end.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_frame_end", c);
            }
            mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_send_slice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_send_slice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static FunctionDescriptor sws_send_slice$descriptor() {
        return sws_send_slice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MethodHandle sws_send_slice$handle() {
        return sws_send_slice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MemorySegment sws_send_slice$address() {
        return sws_send_slice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_send_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static int sws_send_slice(MemorySegment c, int slice_start, int slice_height) {
        var mh$ = sws_send_slice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_send_slice", c, slice_start, slice_height);
            }
            return (int)mh$.invokeExact(c, slice_start, slice_height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_receive_slice {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_receive_slice");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static FunctionDescriptor sws_receive_slice$descriptor() {
        return sws_receive_slice.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MethodHandle sws_receive_slice$handle() {
        return sws_receive_slice.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static MemorySegment sws_receive_slice$address() {
        return sws_receive_slice.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_receive_slice(SwsContext *c, unsigned int slice_start, unsigned int slice_height)
     * }
     */
    public static int sws_receive_slice(MemorySegment c, int slice_start, int slice_height) {
        var mh$ = sws_receive_slice.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_receive_slice", c, slice_start, slice_height);
            }
            return (int)mh$.invokeExact(c, slice_start, slice_height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_receive_slice_alignment {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_receive_slice_alignment");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static FunctionDescriptor sws_receive_slice_alignment$descriptor() {
        return sws_receive_slice_alignment.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static MethodHandle sws_receive_slice_alignment$handle() {
        return sws_receive_slice_alignment.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static MemorySegment sws_receive_slice_alignment$address() {
        return sws_receive_slice_alignment.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int sws_receive_slice_alignment(const SwsContext *c)
     * }
     */
    public static int sws_receive_slice_alignment(MemorySegment c) {
        var mh$ = sws_receive_slice_alignment.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_receive_slice_alignment", c);
            }
            return (int)mh$.invokeExact(c);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_setColorspaceDetails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_setColorspaceDetails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static FunctionDescriptor sws_setColorspaceDetails$descriptor() {
        return sws_setColorspaceDetails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static MethodHandle sws_setColorspaceDetails$handle() {
        return sws_setColorspaceDetails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static MemorySegment sws_setColorspaceDetails$address() {
        return sws_setColorspaceDetails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_setColorspaceDetails(SwsContext *c, const int inv_table[4], int srcRange, const int table[4], int dstRange, int brightness, int contrast, int saturation)
     * }
     */
    public static int sws_setColorspaceDetails(MemorySegment c, MemorySegment inv_table, int srcRange, MemorySegment table, int dstRange, int brightness, int contrast, int saturation) {
        var mh$ = sws_setColorspaceDetails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_setColorspaceDetails", c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
            }
            return (int)mh$.invokeExact(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getColorspaceDetails {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getColorspaceDetails");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static FunctionDescriptor sws_getColorspaceDetails$descriptor() {
        return sws_getColorspaceDetails.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static MethodHandle sws_getColorspaceDetails$handle() {
        return sws_getColorspaceDetails.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static MemorySegment sws_getColorspaceDetails$address() {
        return sws_getColorspaceDetails.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int sws_getColorspaceDetails(SwsContext *c, int **inv_table, int *srcRange, int **table, int *dstRange, int *brightness, int *contrast, int *saturation)
     * }
     */
    public static int sws_getColorspaceDetails(MemorySegment c, MemorySegment inv_table, MemorySegment srcRange, MemorySegment table, MemorySegment dstRange, MemorySegment brightness, MemorySegment contrast, MemorySegment saturation) {
        var mh$ = sws_getColorspaceDetails.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getColorspaceDetails", c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
            }
            return (int)mh$.invokeExact(c, inv_table, srcRange, table, dstRange, brightness, contrast, saturation);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_allocVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_allocVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static FunctionDescriptor sws_allocVec$descriptor() {
        return sws_allocVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MethodHandle sws_allocVec$handle() {
        return sws_allocVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MemorySegment sws_allocVec$address() {
        return sws_allocVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsVector *sws_allocVec(int length)
     * }
     */
    public static MemorySegment sws_allocVec(int length) {
        var mh$ = sws_allocVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_allocVec", length);
            }
            return (MemorySegment)mh$.invokeExact(length);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getGaussianVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getGaussianVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static FunctionDescriptor sws_getGaussianVec$descriptor() {
        return sws_getGaussianVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MethodHandle sws_getGaussianVec$handle() {
        return sws_getGaussianVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MemorySegment sws_getGaussianVec$address() {
        return sws_getGaussianVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsVector *sws_getGaussianVec(double variance, double quality)
     * }
     */
    public static MemorySegment sws_getGaussianVec(double variance, double quality) {
        var mh$ = sws_getGaussianVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getGaussianVec", variance, quality);
            }
            return (MemorySegment)mh$.invokeExact(variance, quality);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_scaleVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_scaleVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static FunctionDescriptor sws_scaleVec$descriptor() {
        return sws_scaleVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static MethodHandle sws_scaleVec$handle() {
        return sws_scaleVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static MemorySegment sws_scaleVec$address() {
        return sws_scaleVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_scaleVec(SwsVector *a, double scalar)
     * }
     */
    public static void sws_scaleVec(MemorySegment a, double scalar) {
        var mh$ = sws_scaleVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_scaleVec", a, scalar);
            }
            mh$.invokeExact(a, scalar);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_normalizeVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_normalizeVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static FunctionDescriptor sws_normalizeVec$descriptor() {
        return sws_normalizeVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static MethodHandle sws_normalizeVec$handle() {
        return sws_normalizeVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static MemorySegment sws_normalizeVec$address() {
        return sws_normalizeVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_normalizeVec(SwsVector *a, double height)
     * }
     */
    public static void sws_normalizeVec(MemorySegment a, double height) {
        var mh$ = sws_normalizeVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_normalizeVec", a, height);
            }
            mh$.invokeExact(a, height);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeVec {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_freeVec");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static FunctionDescriptor sws_freeVec$descriptor() {
        return sws_freeVec.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static MethodHandle sws_freeVec$handle() {
        return sws_freeVec.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static MemorySegment sws_freeVec$address() {
        return sws_freeVec.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeVec(SwsVector *a)
     * }
     */
    public static void sws_freeVec(MemorySegment a) {
        var mh$ = sws_freeVec.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeVec", a);
            }
            mh$.invokeExact(a);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getDefaultFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_FLOAT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getDefaultFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static FunctionDescriptor sws_getDefaultFilter$descriptor() {
        return sws_getDefaultFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MethodHandle sws_getDefaultFilter$handle() {
        return sws_getDefaultFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MemorySegment sws_getDefaultFilter$address() {
        return sws_getDefaultFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsFilter *sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose)
     * }
     */
    public static MemorySegment sws_getDefaultFilter(float lumaGBlur, float chromaGBlur, float lumaSharpen, float chromaSharpen, float chromaHShift, float chromaVShift, int verbose) {
        var mh$ = sws_getDefaultFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getDefaultFilter", lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose);
            }
            return (MemorySegment)mh$.invokeExact(lumaGBlur, chromaGBlur, lumaSharpen, chromaSharpen, chromaHShift, chromaVShift, verbose);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_freeFilter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_freeFilter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static FunctionDescriptor sws_freeFilter$descriptor() {
        return sws_freeFilter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static MethodHandle sws_freeFilter$handle() {
        return sws_freeFilter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static MemorySegment sws_freeFilter$address() {
        return sws_freeFilter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_freeFilter(SwsFilter *filter)
     * }
     */
    public static void sws_freeFilter(MemorySegment filter) {
        var mh$ = sws_freeFilter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_freeFilter", filter);
            }
            mh$.invokeExact(filter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_getCachedContext {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_getCachedContext");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static FunctionDescriptor sws_getCachedContext$descriptor() {
        return sws_getCachedContext.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MethodHandle sws_getCachedContext$handle() {
        return sws_getCachedContext.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getCachedContext$address() {
        return sws_getCachedContext.ADDR;
    }

    /**
     * {@snippet lang=c :
     * SwsContext *sws_getCachedContext(SwsContext *context, int srcW, int srcH, enum AVPixelFormat srcFormat, int dstW, int dstH, enum AVPixelFormat dstFormat, int flags, SwsFilter *srcFilter, SwsFilter *dstFilter, const double *param)
     * }
     */
    public static MemorySegment sws_getCachedContext(MemorySegment context, int srcW, int srcH, int srcFormat, int dstW, int dstH, int dstFormat, int flags, MemorySegment srcFilter, MemorySegment dstFilter, MemorySegment param) {
        var mh$ = sws_getCachedContext.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_getCachedContext", context, srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
            }
            return (MemorySegment)mh$.invokeExact(context, srcW, srcH, srcFormat, dstW, dstH, dstFormat, flags, srcFilter, dstFilter, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_convertPalette8ToPacked32 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_convertPalette8ToPacked32");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static FunctionDescriptor sws_convertPalette8ToPacked32$descriptor() {
        return sws_convertPalette8ToPacked32.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MethodHandle sws_convertPalette8ToPacked32$handle() {
        return sws_convertPalette8ToPacked32.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MemorySegment sws_convertPalette8ToPacked32$address() {
        return sws_convertPalette8ToPacked32.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked32(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static void sws_convertPalette8ToPacked32(MemorySegment src, MemorySegment dst, int num_pixels, MemorySegment palette) {
        var mh$ = sws_convertPalette8ToPacked32.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_convertPalette8ToPacked32", src, dst, num_pixels, palette);
            }
            mh$.invokeExact(src, dst, num_pixels, palette);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class sws_convertPalette8ToPacked24 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("sws_convertPalette8ToPacked24");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static FunctionDescriptor sws_convertPalette8ToPacked24$descriptor() {
        return sws_convertPalette8ToPacked24.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MethodHandle sws_convertPalette8ToPacked24$handle() {
        return sws_convertPalette8ToPacked24.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static MemorySegment sws_convertPalette8ToPacked24$address() {
        return sws_convertPalette8ToPacked24.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void sws_convertPalette8ToPacked24(const uint8_t *src, uint8_t *dst, int num_pixels, const uint8_t *palette)
     * }
     */
    public static void sws_convertPalette8ToPacked24(MemorySegment src, MemorySegment dst, int num_pixels, MemorySegment palette) {
        var mh$ = sws_convertPalette8ToPacked24.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("sws_convertPalette8ToPacked24", src, dst, num_pixels, palette);
            }
            mh$.invokeExact(src, dst, num_pixels, palette);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avfilter_version()
     * }
     */
    public static FunctionDescriptor avfilter_version$descriptor() {
        return avfilter_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avfilter_version()
     * }
     */
    public static MethodHandle avfilter_version$handle() {
        return avfilter_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avfilter_version()
     * }
     */
    public static MemorySegment avfilter_version$address() {
        return avfilter_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avfilter_version()
     * }
     */
    public static int avfilter_version() {
        var mh$ = avfilter_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_version");
            }
            return (int)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_configuration {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_configuration");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avfilter_configuration()
     * }
     */
    public static FunctionDescriptor avfilter_configuration$descriptor() {
        return avfilter_configuration.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avfilter_configuration()
     * }
     */
    public static MethodHandle avfilter_configuration$handle() {
        return avfilter_configuration.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avfilter_configuration()
     * }
     */
    public static MemorySegment avfilter_configuration$address() {
        return avfilter_configuration.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avfilter_configuration()
     * }
     */
    public static MemorySegment avfilter_configuration() {
        var mh$ = avfilter_configuration.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_configuration");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_license {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_license");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avfilter_license()
     * }
     */
    public static FunctionDescriptor avfilter_license$descriptor() {
        return avfilter_license.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avfilter_license()
     * }
     */
    public static MethodHandle avfilter_license$handle() {
        return avfilter_license.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avfilter_license()
     * }
     */
    public static MemorySegment avfilter_license$address() {
        return avfilter_license.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avfilter_license()
     * }
     */
    public static MemorySegment avfilter_license() {
        var mh$ = avfilter_license.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_license");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_pad_get_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_pad_get_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const char *avfilter_pad_get_name(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static FunctionDescriptor avfilter_pad_get_name$descriptor() {
        return avfilter_pad_get_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const char *avfilter_pad_get_name(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static MethodHandle avfilter_pad_get_name$handle() {
        return avfilter_pad_get_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const char *avfilter_pad_get_name(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static MemorySegment avfilter_pad_get_name$address() {
        return avfilter_pad_get_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const char *avfilter_pad_get_name(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static MemorySegment avfilter_pad_get_name(MemorySegment pads, int pad_idx) {
        var mh$ = avfilter_pad_get_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_pad_get_name", pads, pad_idx);
            }
            return (MemorySegment)mh$.invokeExact(pads, pad_idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_pad_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_pad_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVMediaType avfilter_pad_get_type(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static FunctionDescriptor avfilter_pad_get_type$descriptor() {
        return avfilter_pad_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVMediaType avfilter_pad_get_type(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static MethodHandle avfilter_pad_get_type$handle() {
        return avfilter_pad_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVMediaType avfilter_pad_get_type(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static MemorySegment avfilter_pad_get_type$address() {
        return avfilter_pad_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVMediaType avfilter_pad_get_type(const AVFilterPad *pads, int pad_idx)
     * }
     */
    public static int avfilter_pad_get_type(MemorySegment pads, int pad_idx) {
        var mh$ = avfilter_pad_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_pad_get_type", pads, pad_idx);
            }
            return (int)mh$.invokeExact(pads, pad_idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_link_get_hw_frames_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_link_get_hw_frames_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *avfilter_link_get_hw_frames_ctx(AVFilterLink *link)
     * }
     */
    public static FunctionDescriptor avfilter_link_get_hw_frames_ctx$descriptor() {
        return avfilter_link_get_hw_frames_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *avfilter_link_get_hw_frames_ctx(AVFilterLink *link)
     * }
     */
    public static MethodHandle avfilter_link_get_hw_frames_ctx$handle() {
        return avfilter_link_get_hw_frames_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *avfilter_link_get_hw_frames_ctx(AVFilterLink *link)
     * }
     */
    public static MemorySegment avfilter_link_get_hw_frames_ctx$address() {
        return avfilter_link_get_hw_frames_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *avfilter_link_get_hw_frames_ctx(AVFilterLink *link)
     * }
     */
    public static MemorySegment avfilter_link_get_hw_frames_ctx(MemorySegment link) {
        var mh$ = avfilter_link_get_hw_frames_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_link_get_hw_frames_ctx", link);
            }
            return (MemorySegment)mh$.invokeExact(link);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_filter_pad_count {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_filter_pad_count");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int avfilter_filter_pad_count(const AVFilter *filter, int is_output)
     * }
     */
    public static FunctionDescriptor avfilter_filter_pad_count$descriptor() {
        return avfilter_filter_pad_count.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int avfilter_filter_pad_count(const AVFilter *filter, int is_output)
     * }
     */
    public static MethodHandle avfilter_filter_pad_count$handle() {
        return avfilter_filter_pad_count.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int avfilter_filter_pad_count(const AVFilter *filter, int is_output)
     * }
     */
    public static MemorySegment avfilter_filter_pad_count$address() {
        return avfilter_filter_pad_count.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int avfilter_filter_pad_count(const AVFilter *filter, int is_output)
     * }
     */
    public static int avfilter_filter_pad_count(MemorySegment filter, int is_output) {
        var mh$ = avfilter_filter_pad_count.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_filter_pad_count", filter, is_output);
            }
            return (int)mh$.invokeExact(filter, is_output);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_link(AVFilterContext *src, unsigned int srcpad, AVFilterContext *dst, unsigned int dstpad)
     * }
     */
    public static FunctionDescriptor avfilter_link$descriptor() {
        return avfilter_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_link(AVFilterContext *src, unsigned int srcpad, AVFilterContext *dst, unsigned int dstpad)
     * }
     */
    public static MethodHandle avfilter_link$handle() {
        return avfilter_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_link(AVFilterContext *src, unsigned int srcpad, AVFilterContext *dst, unsigned int dstpad)
     * }
     */
    public static MemorySegment avfilter_link$address() {
        return avfilter_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_link(AVFilterContext *src, unsigned int srcpad, AVFilterContext *dst, unsigned int dstpad)
     * }
     */
    public static int avfilter_link(MemorySegment src, int srcpad, MemorySegment dst, int dstpad) {
        var mh$ = avfilter_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_link", src, srcpad, dst, dstpad);
            }
            return (int)mh$.invokeExact(src, srcpad, dst, dstpad);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_process_command {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_process_command");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_process_command(AVFilterContext *filter, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static FunctionDescriptor avfilter_process_command$descriptor() {
        return avfilter_process_command.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_process_command(AVFilterContext *filter, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static MethodHandle avfilter_process_command$handle() {
        return avfilter_process_command.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_process_command(AVFilterContext *filter, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static MemorySegment avfilter_process_command$address() {
        return avfilter_process_command.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_process_command(AVFilterContext *filter, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static int avfilter_process_command(MemorySegment filter, MemorySegment cmd, MemorySegment arg, MemorySegment res, int res_len, int flags) {
        var mh$ = avfilter_process_command.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_process_command", filter, cmd, arg, res, res_len, flags);
            }
            return (int)mh$.invokeExact(filter, cmd, arg, res, res_len, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_filter_iterate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_filter_iterate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVFilter *av_filter_iterate(void **opaque)
     * }
     */
    public static FunctionDescriptor av_filter_iterate$descriptor() {
        return av_filter_iterate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVFilter *av_filter_iterate(void **opaque)
     * }
     */
    public static MethodHandle av_filter_iterate$handle() {
        return av_filter_iterate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVFilter *av_filter_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_filter_iterate$address() {
        return av_filter_iterate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVFilter *av_filter_iterate(void **opaque)
     * }
     */
    public static MemorySegment av_filter_iterate(MemorySegment opaque) {
        var mh$ = av_filter_iterate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_filter_iterate", opaque);
            }
            return (MemorySegment)mh$.invokeExact(opaque);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_get_by_name {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_get_by_name");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVFilter *avfilter_get_by_name(const char *name)
     * }
     */
    public static FunctionDescriptor avfilter_get_by_name$descriptor() {
        return avfilter_get_by_name.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVFilter *avfilter_get_by_name(const char *name)
     * }
     */
    public static MethodHandle avfilter_get_by_name$handle() {
        return avfilter_get_by_name.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVFilter *avfilter_get_by_name(const char *name)
     * }
     */
    public static MemorySegment avfilter_get_by_name$address() {
        return avfilter_get_by_name.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVFilter *avfilter_get_by_name(const char *name)
     * }
     */
    public static MemorySegment avfilter_get_by_name(MemorySegment name) {
        var mh$ = avfilter_get_by_name.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_get_by_name", name);
            }
            return (MemorySegment)mh$.invokeExact(name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_init_str {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_init_str");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_init_str(AVFilterContext *ctx, const char *args)
     * }
     */
    public static FunctionDescriptor avfilter_init_str$descriptor() {
        return avfilter_init_str.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_init_str(AVFilterContext *ctx, const char *args)
     * }
     */
    public static MethodHandle avfilter_init_str$handle() {
        return avfilter_init_str.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_init_str(AVFilterContext *ctx, const char *args)
     * }
     */
    public static MemorySegment avfilter_init_str$address() {
        return avfilter_init_str.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_init_str(AVFilterContext *ctx, const char *args)
     * }
     */
    public static int avfilter_init_str(MemorySegment ctx, MemorySegment args) {
        var mh$ = avfilter_init_str.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_init_str", ctx, args);
            }
            return (int)mh$.invokeExact(ctx, args);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_init_dict {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_init_dict");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_init_dict(AVFilterContext *ctx, AVDictionary **options)
     * }
     */
    public static FunctionDescriptor avfilter_init_dict$descriptor() {
        return avfilter_init_dict.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_init_dict(AVFilterContext *ctx, AVDictionary **options)
     * }
     */
    public static MethodHandle avfilter_init_dict$handle() {
        return avfilter_init_dict.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_init_dict(AVFilterContext *ctx, AVDictionary **options)
     * }
     */
    public static MemorySegment avfilter_init_dict$address() {
        return avfilter_init_dict.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_init_dict(AVFilterContext *ctx, AVDictionary **options)
     * }
     */
    public static int avfilter_init_dict(MemorySegment ctx, MemorySegment options) {
        var mh$ = avfilter_init_dict.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_init_dict", ctx, options);
            }
            return (int)mh$.invokeExact(ctx, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avfilter_free(AVFilterContext *filter)
     * }
     */
    public static FunctionDescriptor avfilter_free$descriptor() {
        return avfilter_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avfilter_free(AVFilterContext *filter)
     * }
     */
    public static MethodHandle avfilter_free$handle() {
        return avfilter_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avfilter_free(AVFilterContext *filter)
     * }
     */
    public static MemorySegment avfilter_free$address() {
        return avfilter_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avfilter_free(AVFilterContext *filter)
     * }
     */
    public static void avfilter_free(MemorySegment filter) {
        var mh$ = avfilter_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_free", filter);
            }
            mh$.invokeExact(filter);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_insert_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_insert_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_insert_filter(AVFilterLink *link, AVFilterContext *filt, unsigned int filt_srcpad_idx, unsigned int filt_dstpad_idx)
     * }
     */
    public static FunctionDescriptor avfilter_insert_filter$descriptor() {
        return avfilter_insert_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_insert_filter(AVFilterLink *link, AVFilterContext *filt, unsigned int filt_srcpad_idx, unsigned int filt_dstpad_idx)
     * }
     */
    public static MethodHandle avfilter_insert_filter$handle() {
        return avfilter_insert_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_insert_filter(AVFilterLink *link, AVFilterContext *filt, unsigned int filt_srcpad_idx, unsigned int filt_dstpad_idx)
     * }
     */
    public static MemorySegment avfilter_insert_filter$address() {
        return avfilter_insert_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_insert_filter(AVFilterLink *link, AVFilterContext *filt, unsigned int filt_srcpad_idx, unsigned int filt_dstpad_idx)
     * }
     */
    public static int avfilter_insert_filter(MemorySegment link, MemorySegment filt, int filt_srcpad_idx, int filt_dstpad_idx) {
        var mh$ = avfilter_insert_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_insert_filter", link, filt, filt_srcpad_idx, filt_dstpad_idx);
            }
            return (int)mh$.invokeExact(link, filt, filt_srcpad_idx, filt_dstpad_idx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_get_class {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_get_class");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVClass *avfilter_get_class()
     * }
     */
    public static FunctionDescriptor avfilter_get_class$descriptor() {
        return avfilter_get_class.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVClass *avfilter_get_class()
     * }
     */
    public static MethodHandle avfilter_get_class$handle() {
        return avfilter_get_class.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVClass *avfilter_get_class()
     * }
     */
    public static MemorySegment avfilter_get_class$address() {
        return avfilter_get_class.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVClass *avfilter_get_class()
     * }
     */
    public static MemorySegment avfilter_get_class() {
        var mh$ = avfilter_get_class.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_get_class");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFilterGraph *avfilter_graph_alloc()
     * }
     */
    public static FunctionDescriptor avfilter_graph_alloc$descriptor() {
        return avfilter_graph_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFilterGraph *avfilter_graph_alloc()
     * }
     */
    public static MethodHandle avfilter_graph_alloc$handle() {
        return avfilter_graph_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFilterGraph *avfilter_graph_alloc()
     * }
     */
    public static MemorySegment avfilter_graph_alloc$address() {
        return avfilter_graph_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFilterGraph *avfilter_graph_alloc()
     * }
     */
    public static MemorySegment avfilter_graph_alloc() {
        var mh$ = avfilter_graph_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_alloc_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_alloc_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_alloc_filter(AVFilterGraph *graph, const AVFilter *filter, const char *name)
     * }
     */
    public static FunctionDescriptor avfilter_graph_alloc_filter$descriptor() {
        return avfilter_graph_alloc_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_alloc_filter(AVFilterGraph *graph, const AVFilter *filter, const char *name)
     * }
     */
    public static MethodHandle avfilter_graph_alloc_filter$handle() {
        return avfilter_graph_alloc_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_alloc_filter(AVFilterGraph *graph, const AVFilter *filter, const char *name)
     * }
     */
    public static MemorySegment avfilter_graph_alloc_filter$address() {
        return avfilter_graph_alloc_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_alloc_filter(AVFilterGraph *graph, const AVFilter *filter, const char *name)
     * }
     */
    public static MemorySegment avfilter_graph_alloc_filter(MemorySegment graph, MemorySegment filter, MemorySegment name) {
        var mh$ = avfilter_graph_alloc_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_alloc_filter", graph, filter, name);
            }
            return (MemorySegment)mh$.invokeExact(graph, filter, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_get_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_get_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, const char *name)
     * }
     */
    public static FunctionDescriptor avfilter_graph_get_filter$descriptor() {
        return avfilter_graph_get_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, const char *name)
     * }
     */
    public static MethodHandle avfilter_graph_get_filter$handle() {
        return avfilter_graph_get_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, const char *name)
     * }
     */
    public static MemorySegment avfilter_graph_get_filter$address() {
        return avfilter_graph_get_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFilterContext *avfilter_graph_get_filter(AVFilterGraph *graph, const char *name)
     * }
     */
    public static MemorySegment avfilter_graph_get_filter(MemorySegment graph, MemorySegment name) {
        var mh$ = avfilter_graph_get_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_get_filter", graph, name);
            }
            return (MemorySegment)mh$.invokeExact(graph, name);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_create_filter {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_create_filter");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_create_filter(AVFilterContext **filt_ctx, const AVFilter *filt, const char *name, const char *args, void *opaque, AVFilterGraph *graph_ctx)
     * }
     */
    public static FunctionDescriptor avfilter_graph_create_filter$descriptor() {
        return avfilter_graph_create_filter.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_create_filter(AVFilterContext **filt_ctx, const AVFilter *filt, const char *name, const char *args, void *opaque, AVFilterGraph *graph_ctx)
     * }
     */
    public static MethodHandle avfilter_graph_create_filter$handle() {
        return avfilter_graph_create_filter.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_create_filter(AVFilterContext **filt_ctx, const AVFilter *filt, const char *name, const char *args, void *opaque, AVFilterGraph *graph_ctx)
     * }
     */
    public static MemorySegment avfilter_graph_create_filter$address() {
        return avfilter_graph_create_filter.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_create_filter(AVFilterContext **filt_ctx, const AVFilter *filt, const char *name, const char *args, void *opaque, AVFilterGraph *graph_ctx)
     * }
     */
    public static int avfilter_graph_create_filter(MemorySegment filt_ctx, MemorySegment filt, MemorySegment name, MemorySegment args, MemorySegment opaque, MemorySegment graph_ctx) {
        var mh$ = avfilter_graph_create_filter.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_create_filter", filt_ctx, filt, name, args, opaque, graph_ctx);
            }
            return (int)mh$.invokeExact(filt_ctx, filt, name, args, opaque, graph_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_set_auto_convert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_set_auto_convert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avfilter_graph_set_auto_convert(AVFilterGraph *graph, unsigned int flags)
     * }
     */
    public static FunctionDescriptor avfilter_graph_set_auto_convert$descriptor() {
        return avfilter_graph_set_auto_convert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avfilter_graph_set_auto_convert(AVFilterGraph *graph, unsigned int flags)
     * }
     */
    public static MethodHandle avfilter_graph_set_auto_convert$handle() {
        return avfilter_graph_set_auto_convert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avfilter_graph_set_auto_convert(AVFilterGraph *graph, unsigned int flags)
     * }
     */
    public static MemorySegment avfilter_graph_set_auto_convert$address() {
        return avfilter_graph_set_auto_convert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avfilter_graph_set_auto_convert(AVFilterGraph *graph, unsigned int flags)
     * }
     */
    public static void avfilter_graph_set_auto_convert(MemorySegment graph, int flags) {
        var mh$ = avfilter_graph_set_auto_convert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_set_auto_convert", graph, flags);
            }
            mh$.invokeExact(graph, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AVFILTER_AUTO_CONVERT_ALL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AVFILTER_AUTO_CONVERT_ALL = 0
     * }
     */
    public static int AVFILTER_AUTO_CONVERT_ALL() {
        return AVFILTER_AUTO_CONVERT_ALL;
    }
    private static final int AVFILTER_AUTO_CONVERT_NONE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AVFILTER_AUTO_CONVERT_NONE = -1
     * }
     */
    public static int AVFILTER_AUTO_CONVERT_NONE() {
        return AVFILTER_AUTO_CONVERT_NONE;
    }

    private static class avfilter_graph_config {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_config");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
     * }
     */
    public static FunctionDescriptor avfilter_graph_config$descriptor() {
        return avfilter_graph_config.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
     * }
     */
    public static MethodHandle avfilter_graph_config$handle() {
        return avfilter_graph_config.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
     * }
     */
    public static MemorySegment avfilter_graph_config$address() {
        return avfilter_graph_config.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_config(AVFilterGraph *graphctx, void *log_ctx)
     * }
     */
    public static int avfilter_graph_config(MemorySegment graphctx, MemorySegment log_ctx) {
        var mh$ = avfilter_graph_config.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_config", graphctx, log_ctx);
            }
            return (int)mh$.invokeExact(graphctx, log_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avfilter_graph_free(AVFilterGraph **graph)
     * }
     */
    public static FunctionDescriptor avfilter_graph_free$descriptor() {
        return avfilter_graph_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avfilter_graph_free(AVFilterGraph **graph)
     * }
     */
    public static MethodHandle avfilter_graph_free$handle() {
        return avfilter_graph_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avfilter_graph_free(AVFilterGraph **graph)
     * }
     */
    public static MemorySegment avfilter_graph_free$address() {
        return avfilter_graph_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avfilter_graph_free(AVFilterGraph **graph)
     * }
     */
    public static void avfilter_graph_free(MemorySegment graph) {
        var mh$ = avfilter_graph_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_free", graph);
            }
            mh$.invokeExact(graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_inout_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_inout_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVFilterInOut *avfilter_inout_alloc()
     * }
     */
    public static FunctionDescriptor avfilter_inout_alloc$descriptor() {
        return avfilter_inout_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVFilterInOut *avfilter_inout_alloc()
     * }
     */
    public static MethodHandle avfilter_inout_alloc$handle() {
        return avfilter_inout_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVFilterInOut *avfilter_inout_alloc()
     * }
     */
    public static MemorySegment avfilter_inout_alloc$address() {
        return avfilter_inout_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVFilterInOut *avfilter_inout_alloc()
     * }
     */
    public static MemorySegment avfilter_inout_alloc() {
        var mh$ = avfilter_inout_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_inout_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_inout_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_inout_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avfilter_inout_free(AVFilterInOut **inout)
     * }
     */
    public static FunctionDescriptor avfilter_inout_free$descriptor() {
        return avfilter_inout_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avfilter_inout_free(AVFilterInOut **inout)
     * }
     */
    public static MethodHandle avfilter_inout_free$handle() {
        return avfilter_inout_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avfilter_inout_free(AVFilterInOut **inout)
     * }
     */
    public static MemorySegment avfilter_inout_free$address() {
        return avfilter_inout_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avfilter_inout_free(AVFilterInOut **inout)
     * }
     */
    public static void avfilter_inout_free(MemorySegment inout) {
        var mh$ = avfilter_inout_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_inout_free", inout);
            }
            mh$.invokeExact(inout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *inputs, AVFilterInOut *outputs, void *log_ctx)
     * }
     */
    public static FunctionDescriptor avfilter_graph_parse$descriptor() {
        return avfilter_graph_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *inputs, AVFilterInOut *outputs, void *log_ctx)
     * }
     */
    public static MethodHandle avfilter_graph_parse$handle() {
        return avfilter_graph_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *inputs, AVFilterInOut *outputs, void *log_ctx)
     * }
     */
    public static MemorySegment avfilter_graph_parse$address() {
        return avfilter_graph_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *inputs, AVFilterInOut *outputs, void *log_ctx)
     * }
     */
    public static int avfilter_graph_parse(MemorySegment graph, MemorySegment filters, MemorySegment inputs, MemorySegment outputs, MemorySegment log_ctx) {
        var mh$ = avfilter_graph_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_parse", graph, filters, inputs, outputs, log_ctx);
            }
            return (int)mh$.invokeExact(graph, filters, inputs, outputs, log_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_parse_ptr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_parse_ptr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
     * }
     */
    public static FunctionDescriptor avfilter_graph_parse_ptr$descriptor() {
        return avfilter_graph_parse_ptr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
     * }
     */
    public static MethodHandle avfilter_graph_parse_ptr$handle() {
        return avfilter_graph_parse_ptr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
     * }
     */
    public static MemorySegment avfilter_graph_parse_ptr$address() {
        return avfilter_graph_parse_ptr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_parse_ptr(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs, void *log_ctx)
     * }
     */
    public static int avfilter_graph_parse_ptr(MemorySegment graph, MemorySegment filters, MemorySegment inputs, MemorySegment outputs, MemorySegment log_ctx) {
        var mh$ = avfilter_graph_parse_ptr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_parse_ptr", graph, filters, inputs, outputs, log_ctx);
            }
            return (int)mh$.invokeExact(graph, filters, inputs, outputs, log_ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_parse2 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_parse2");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_parse2(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static FunctionDescriptor avfilter_graph_parse2$descriptor() {
        return avfilter_graph_parse2.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_parse2(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static MethodHandle avfilter_graph_parse2$handle() {
        return avfilter_graph_parse2.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_parse2(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static MemorySegment avfilter_graph_parse2$address() {
        return avfilter_graph_parse2.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_parse2(AVFilterGraph *graph, const char *filters, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static int avfilter_graph_parse2(MemorySegment graph, MemorySegment filters, MemorySegment inputs, MemorySegment outputs) {
        var mh$ = avfilter_graph_parse2.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_parse2", graph, filters, inputs, outputs);
            }
            return (int)mh$.invokeExact(graph, filters, inputs, outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_segment_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_segment_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_parse(AVFilterGraph *graph, const char *graph_str, int flags, AVFilterGraphSegment **seg)
     * }
     */
    public static FunctionDescriptor avfilter_graph_segment_parse$descriptor() {
        return avfilter_graph_segment_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_parse(AVFilterGraph *graph, const char *graph_str, int flags, AVFilterGraphSegment **seg)
     * }
     */
    public static MethodHandle avfilter_graph_segment_parse$handle() {
        return avfilter_graph_segment_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_parse(AVFilterGraph *graph, const char *graph_str, int flags, AVFilterGraphSegment **seg)
     * }
     */
    public static MemorySegment avfilter_graph_segment_parse$address() {
        return avfilter_graph_segment_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_segment_parse(AVFilterGraph *graph, const char *graph_str, int flags, AVFilterGraphSegment **seg)
     * }
     */
    public static int avfilter_graph_segment_parse(MemorySegment graph, MemorySegment graph_str, int flags, MemorySegment seg) {
        var mh$ = avfilter_graph_segment_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_segment_parse", graph, graph_str, flags, seg);
            }
            return (int)mh$.invokeExact(graph, graph_str, flags, seg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_segment_create_filters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_segment_create_filters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_create_filters(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static FunctionDescriptor avfilter_graph_segment_create_filters$descriptor() {
        return avfilter_graph_segment_create_filters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_create_filters(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static MethodHandle avfilter_graph_segment_create_filters$handle() {
        return avfilter_graph_segment_create_filters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_create_filters(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static MemorySegment avfilter_graph_segment_create_filters$address() {
        return avfilter_graph_segment_create_filters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_segment_create_filters(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static int avfilter_graph_segment_create_filters(MemorySegment seg, int flags) {
        var mh$ = avfilter_graph_segment_create_filters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_segment_create_filters", seg, flags);
            }
            return (int)mh$.invokeExact(seg, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_segment_apply_opts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_segment_apply_opts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply_opts(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static FunctionDescriptor avfilter_graph_segment_apply_opts$descriptor() {
        return avfilter_graph_segment_apply_opts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply_opts(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static MethodHandle avfilter_graph_segment_apply_opts$handle() {
        return avfilter_graph_segment_apply_opts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply_opts(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static MemorySegment avfilter_graph_segment_apply_opts$address() {
        return avfilter_graph_segment_apply_opts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply_opts(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static int avfilter_graph_segment_apply_opts(MemorySegment seg, int flags) {
        var mh$ = avfilter_graph_segment_apply_opts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_segment_apply_opts", seg, flags);
            }
            return (int)mh$.invokeExact(seg, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_segment_init {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_segment_init");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_init(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static FunctionDescriptor avfilter_graph_segment_init$descriptor() {
        return avfilter_graph_segment_init.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_init(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static MethodHandle avfilter_graph_segment_init$handle() {
        return avfilter_graph_segment_init.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_init(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static MemorySegment avfilter_graph_segment_init$address() {
        return avfilter_graph_segment_init.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_segment_init(AVFilterGraphSegment *seg, int flags)
     * }
     */
    public static int avfilter_graph_segment_init(MemorySegment seg, int flags) {
        var mh$ = avfilter_graph_segment_init.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_segment_init", seg, flags);
            }
            return (int)mh$.invokeExact(seg, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_segment_link {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_segment_link");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_link(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static FunctionDescriptor avfilter_graph_segment_link$descriptor() {
        return avfilter_graph_segment_link.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_link(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static MethodHandle avfilter_graph_segment_link$handle() {
        return avfilter_graph_segment_link.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_link(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static MemorySegment avfilter_graph_segment_link$address() {
        return avfilter_graph_segment_link.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_segment_link(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static int avfilter_graph_segment_link(MemorySegment seg, int flags, MemorySegment inputs, MemorySegment outputs) {
        var mh$ = avfilter_graph_segment_link.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_segment_link", seg, flags, inputs, outputs);
            }
            return (int)mh$.invokeExact(seg, flags, inputs, outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_segment_apply {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_segment_apply");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static FunctionDescriptor avfilter_graph_segment_apply$descriptor() {
        return avfilter_graph_segment_apply.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static MethodHandle avfilter_graph_segment_apply$handle() {
        return avfilter_graph_segment_apply.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static MemorySegment avfilter_graph_segment_apply$address() {
        return avfilter_graph_segment_apply.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_segment_apply(AVFilterGraphSegment *seg, int flags, AVFilterInOut **inputs, AVFilterInOut **outputs)
     * }
     */
    public static int avfilter_graph_segment_apply(MemorySegment seg, int flags, MemorySegment inputs, MemorySegment outputs) {
        var mh$ = avfilter_graph_segment_apply.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_segment_apply", seg, flags, inputs, outputs);
            }
            return (int)mh$.invokeExact(seg, flags, inputs, outputs);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_segment_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_segment_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void avfilter_graph_segment_free(AVFilterGraphSegment **seg)
     * }
     */
    public static FunctionDescriptor avfilter_graph_segment_free$descriptor() {
        return avfilter_graph_segment_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void avfilter_graph_segment_free(AVFilterGraphSegment **seg)
     * }
     */
    public static MethodHandle avfilter_graph_segment_free$handle() {
        return avfilter_graph_segment_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void avfilter_graph_segment_free(AVFilterGraphSegment **seg)
     * }
     */
    public static MemorySegment avfilter_graph_segment_free$address() {
        return avfilter_graph_segment_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void avfilter_graph_segment_free(AVFilterGraphSegment **seg)
     * }
     */
    public static void avfilter_graph_segment_free(MemorySegment seg) {
        var mh$ = avfilter_graph_segment_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_segment_free", seg);
            }
            mh$.invokeExact(seg);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_send_command {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_send_command");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static FunctionDescriptor avfilter_graph_send_command$descriptor() {
        return avfilter_graph_send_command.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static MethodHandle avfilter_graph_send_command$handle() {
        return avfilter_graph_send_command.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static MemorySegment avfilter_graph_send_command$address() {
        return avfilter_graph_send_command.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_send_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, char *res, int res_len, int flags)
     * }
     */
    public static int avfilter_graph_send_command(MemorySegment graph, MemorySegment target, MemorySegment cmd, MemorySegment arg, MemorySegment res, int res_len, int flags) {
        var mh$ = avfilter_graph_send_command.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_send_command", graph, target, cmd, arg, res, res_len, flags);
            }
            return (int)mh$.invokeExact(graph, target, cmd, arg, res, res_len, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_queue_command {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT,
            FFmpeg.C_DOUBLE
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_queue_command");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, int flags, double ts)
     * }
     */
    public static FunctionDescriptor avfilter_graph_queue_command$descriptor() {
        return avfilter_graph_queue_command.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, int flags, double ts)
     * }
     */
    public static MethodHandle avfilter_graph_queue_command$handle() {
        return avfilter_graph_queue_command.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, int flags, double ts)
     * }
     */
    public static MemorySegment avfilter_graph_queue_command$address() {
        return avfilter_graph_queue_command.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_queue_command(AVFilterGraph *graph, const char *target, const char *cmd, const char *arg, int flags, double ts)
     * }
     */
    public static int avfilter_graph_queue_command(MemorySegment graph, MemorySegment target, MemorySegment cmd, MemorySegment arg, int flags, double ts) {
        var mh$ = avfilter_graph_queue_command.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_queue_command", graph, target, cmd, arg, flags, ts);
            }
            return (int)mh$.invokeExact(graph, target, cmd, arg, flags, ts);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *avfilter_graph_dump(AVFilterGraph *graph, const char *options)
     * }
     */
    public static FunctionDescriptor avfilter_graph_dump$descriptor() {
        return avfilter_graph_dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *avfilter_graph_dump(AVFilterGraph *graph, const char *options)
     * }
     */
    public static MethodHandle avfilter_graph_dump$handle() {
        return avfilter_graph_dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *avfilter_graph_dump(AVFilterGraph *graph, const char *options)
     * }
     */
    public static MemorySegment avfilter_graph_dump$address() {
        return avfilter_graph_dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *avfilter_graph_dump(AVFilterGraph *graph, const char *options)
     * }
     */
    public static MemorySegment avfilter_graph_dump(MemorySegment graph, MemorySegment options) {
        var mh$ = avfilter_graph_dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_dump", graph, options);
            }
            return (MemorySegment)mh$.invokeExact(graph, options);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class avfilter_graph_request_oldest {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("avfilter_graph_request_oldest");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int avfilter_graph_request_oldest(AVFilterGraph *graph)
     * }
     */
    public static FunctionDescriptor avfilter_graph_request_oldest$descriptor() {
        return avfilter_graph_request_oldest.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int avfilter_graph_request_oldest(AVFilterGraph *graph)
     * }
     */
    public static MethodHandle avfilter_graph_request_oldest$handle() {
        return avfilter_graph_request_oldest.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int avfilter_graph_request_oldest(AVFilterGraph *graph)
     * }
     */
    public static MemorySegment avfilter_graph_request_oldest$address() {
        return avfilter_graph_request_oldest.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int avfilter_graph_request_oldest(AVFilterGraph *graph)
     * }
     */
    public static int avfilter_graph_request_oldest(MemorySegment graph) {
        var mh$ = avfilter_graph_request_oldest.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("avfilter_graph_request_oldest", graph);
            }
            return (int)mh$.invokeExact(graph);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT = 1
     * }
     */
    public static int AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT() {
        return AV_BUFFERSRC_FLAG_NO_CHECK_FORMAT;
    }
    private static final int AV_BUFFERSRC_FLAG_PUSH = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_BUFFERSRC_FLAG_PUSH = 4
     * }
     */
    public static int AV_BUFFERSRC_FLAG_PUSH() {
        return AV_BUFFERSRC_FLAG_PUSH;
    }
    private static final int AV_BUFFERSRC_FLAG_KEEP_REF = (int)8L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.AV_BUFFERSRC_FLAG_KEEP_REF = 8
     * }
     */
    public static int AV_BUFFERSRC_FLAG_KEEP_REF() {
        return AV_BUFFERSRC_FLAG_KEEP_REF;
    }

    private static class av_buffersrc_get_nb_failed_requests {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersrc_get_nb_failed_requests");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * unsigned int av_buffersrc_get_nb_failed_requests(AVFilterContext *buffer_src)
     * }
     */
    public static FunctionDescriptor av_buffersrc_get_nb_failed_requests$descriptor() {
        return av_buffersrc_get_nb_failed_requests.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * unsigned int av_buffersrc_get_nb_failed_requests(AVFilterContext *buffer_src)
     * }
     */
    public static MethodHandle av_buffersrc_get_nb_failed_requests$handle() {
        return av_buffersrc_get_nb_failed_requests.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * unsigned int av_buffersrc_get_nb_failed_requests(AVFilterContext *buffer_src)
     * }
     */
    public static MemorySegment av_buffersrc_get_nb_failed_requests$address() {
        return av_buffersrc_get_nb_failed_requests.ADDR;
    }

    /**
     * {@snippet lang=c :
     * unsigned int av_buffersrc_get_nb_failed_requests(AVFilterContext *buffer_src)
     * }
     */
    public static int av_buffersrc_get_nb_failed_requests(MemorySegment buffer_src) {
        var mh$ = av_buffersrc_get_nb_failed_requests.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersrc_get_nb_failed_requests", buffer_src);
            }
            return (int)mh$.invokeExact(buffer_src);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersrc_parameters_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER    );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersrc_parameters_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferSrcParameters *av_buffersrc_parameters_alloc()
     * }
     */
    public static FunctionDescriptor av_buffersrc_parameters_alloc$descriptor() {
        return av_buffersrc_parameters_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferSrcParameters *av_buffersrc_parameters_alloc()
     * }
     */
    public static MethodHandle av_buffersrc_parameters_alloc$handle() {
        return av_buffersrc_parameters_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferSrcParameters *av_buffersrc_parameters_alloc()
     * }
     */
    public static MemorySegment av_buffersrc_parameters_alloc$address() {
        return av_buffersrc_parameters_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferSrcParameters *av_buffersrc_parameters_alloc()
     * }
     */
    public static MemorySegment av_buffersrc_parameters_alloc() {
        var mh$ = av_buffersrc_parameters_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersrc_parameters_alloc");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersrc_parameters_set {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersrc_parameters_set");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersrc_parameters_set(AVFilterContext *ctx, AVBufferSrcParameters *param)
     * }
     */
    public static FunctionDescriptor av_buffersrc_parameters_set$descriptor() {
        return av_buffersrc_parameters_set.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersrc_parameters_set(AVFilterContext *ctx, AVBufferSrcParameters *param)
     * }
     */
    public static MethodHandle av_buffersrc_parameters_set$handle() {
        return av_buffersrc_parameters_set.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersrc_parameters_set(AVFilterContext *ctx, AVBufferSrcParameters *param)
     * }
     */
    public static MemorySegment av_buffersrc_parameters_set$address() {
        return av_buffersrc_parameters_set.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersrc_parameters_set(AVFilterContext *ctx, AVBufferSrcParameters *param)
     * }
     */
    public static int av_buffersrc_parameters_set(MemorySegment ctx, MemorySegment param) {
        var mh$ = av_buffersrc_parameters_set.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersrc_parameters_set", ctx, param);
            }
            return (int)mh$.invokeExact(ctx, param);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersrc_write_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersrc_write_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersrc_write_frame(AVFilterContext *ctx, const AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_buffersrc_write_frame$descriptor() {
        return av_buffersrc_write_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersrc_write_frame(AVFilterContext *ctx, const AVFrame *frame)
     * }
     */
    public static MethodHandle av_buffersrc_write_frame$handle() {
        return av_buffersrc_write_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersrc_write_frame(AVFilterContext *ctx, const AVFrame *frame)
     * }
     */
    public static MemorySegment av_buffersrc_write_frame$address() {
        return av_buffersrc_write_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersrc_write_frame(AVFilterContext *ctx, const AVFrame *frame)
     * }
     */
    public static int av_buffersrc_write_frame(MemorySegment ctx, MemorySegment frame) {
        var mh$ = av_buffersrc_write_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersrc_write_frame", ctx, frame);
            }
            return (int)mh$.invokeExact(ctx, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersrc_add_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersrc_add_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersrc_add_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_buffersrc_add_frame$descriptor() {
        return av_buffersrc_add_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersrc_add_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static MethodHandle av_buffersrc_add_frame$handle() {
        return av_buffersrc_add_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersrc_add_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static MemorySegment av_buffersrc_add_frame$address() {
        return av_buffersrc_add_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersrc_add_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static int av_buffersrc_add_frame(MemorySegment ctx, MemorySegment frame) {
        var mh$ = av_buffersrc_add_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersrc_add_frame", ctx, frame);
            }
            return (int)mh$.invokeExact(ctx, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersrc_add_frame_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersrc_add_frame_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersrc_add_frame_flags(AVFilterContext *buffer_src, AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_buffersrc_add_frame_flags$descriptor() {
        return av_buffersrc_add_frame_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersrc_add_frame_flags(AVFilterContext *buffer_src, AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_buffersrc_add_frame_flags$handle() {
        return av_buffersrc_add_frame_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersrc_add_frame_flags(AVFilterContext *buffer_src, AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment av_buffersrc_add_frame_flags$address() {
        return av_buffersrc_add_frame_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersrc_add_frame_flags(AVFilterContext *buffer_src, AVFrame *frame, int flags)
     * }
     */
    public static int av_buffersrc_add_frame_flags(MemorySegment buffer_src, MemorySegment frame, int flags) {
        var mh$ = av_buffersrc_add_frame_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersrc_add_frame_flags", buffer_src, frame, flags);
            }
            return (int)mh$.invokeExact(buffer_src, frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersrc_close {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_LONG_LONG,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersrc_close");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersrc_close(AVFilterContext *ctx, int64_t pts, unsigned int flags)
     * }
     */
    public static FunctionDescriptor av_buffersrc_close$descriptor() {
        return av_buffersrc_close.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersrc_close(AVFilterContext *ctx, int64_t pts, unsigned int flags)
     * }
     */
    public static MethodHandle av_buffersrc_close$handle() {
        return av_buffersrc_close.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersrc_close(AVFilterContext *ctx, int64_t pts, unsigned int flags)
     * }
     */
    public static MemorySegment av_buffersrc_close$address() {
        return av_buffersrc_close.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersrc_close(AVFilterContext *ctx, int64_t pts, unsigned int flags)
     * }
     */
    public static int av_buffersrc_close(MemorySegment ctx, long pts, int flags) {
        var mh$ = av_buffersrc_close.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersrc_close", ctx, pts, flags);
            }
            return (int)mh$.invokeExact(ctx, pts, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_frame_flags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_frame_flags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_frame_flags(AVFilterContext *ctx, AVFrame *frame, int flags)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_frame_flags$descriptor() {
        return av_buffersink_get_frame_flags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_frame_flags(AVFilterContext *ctx, AVFrame *frame, int flags)
     * }
     */
    public static MethodHandle av_buffersink_get_frame_flags$handle() {
        return av_buffersink_get_frame_flags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_frame_flags(AVFilterContext *ctx, AVFrame *frame, int flags)
     * }
     */
    public static MemorySegment av_buffersink_get_frame_flags$address() {
        return av_buffersink_get_frame_flags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_frame_flags(AVFilterContext *ctx, AVFrame *frame, int flags)
     * }
     */
    public static int av_buffersink_get_frame_flags(MemorySegment ctx, MemorySegment frame, int flags) {
        var mh$ = av_buffersink_get_frame_flags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_frame_flags", ctx, frame, flags);
            }
            return (int)mh$.invokeExact(ctx, frame, flags);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_set_frame_size {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_set_frame_size");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void av_buffersink_set_frame_size(AVFilterContext *ctx, unsigned int frame_size)
     * }
     */
    public static FunctionDescriptor av_buffersink_set_frame_size$descriptor() {
        return av_buffersink_set_frame_size.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void av_buffersink_set_frame_size(AVFilterContext *ctx, unsigned int frame_size)
     * }
     */
    public static MethodHandle av_buffersink_set_frame_size$handle() {
        return av_buffersink_set_frame_size.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void av_buffersink_set_frame_size(AVFilterContext *ctx, unsigned int frame_size)
     * }
     */
    public static MemorySegment av_buffersink_set_frame_size$address() {
        return av_buffersink_set_frame_size.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void av_buffersink_set_frame_size(AVFilterContext *ctx, unsigned int frame_size)
     * }
     */
    public static void av_buffersink_set_frame_size(MemorySegment ctx, int frame_size) {
        var mh$ = av_buffersink_set_frame_size.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_set_frame_size", ctx, frame_size);
            }
            mh$.invokeExact(ctx, frame_size);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVMediaType av_buffersink_get_type(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_type$descriptor() {
        return av_buffersink_get_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVMediaType av_buffersink_get_type(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_type$handle() {
        return av_buffersink_get_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVMediaType av_buffersink_get_type(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_type$address() {
        return av_buffersink_get_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVMediaType av_buffersink_get_type(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_type(MemorySegment ctx) {
        var mh$ = av_buffersink_get_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_type", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_time_base {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_time_base");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_time_base(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_time_base$descriptor() {
        return av_buffersink_get_time_base.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_time_base(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_time_base$handle() {
        return av_buffersink_get_time_base.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_time_base(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_time_base$address() {
        return av_buffersink_get_time_base.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_buffersink_get_time_base(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_time_base(SegmentAllocator allocator, MemorySegment ctx) {
        var mh$ = av_buffersink_get_time_base.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_time_base", allocator, ctx);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_format {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_format");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_format(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_format$descriptor() {
        return av_buffersink_get_format.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_format(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_format$handle() {
        return av_buffersink_get_format.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_format(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_format$address() {
        return av_buffersink_get_format.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_format(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_format(MemorySegment ctx) {
        var mh$ = av_buffersink_get_format.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_format", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_frame_rate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_frame_rate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_frame_rate(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_frame_rate$descriptor() {
        return av_buffersink_get_frame_rate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_frame_rate(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_frame_rate$handle() {
        return av_buffersink_get_frame_rate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_frame_rate(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_frame_rate$address() {
        return av_buffersink_get_frame_rate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_buffersink_get_frame_rate(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_frame_rate(SegmentAllocator allocator, MemorySegment ctx) {
        var mh$ = av_buffersink_get_frame_rate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_frame_rate", allocator, ctx);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_w {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_w");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_w(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_w$descriptor() {
        return av_buffersink_get_w.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_w(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_w$handle() {
        return av_buffersink_get_w.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_w(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_w$address() {
        return av_buffersink_get_w.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_w(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_w(MemorySegment ctx) {
        var mh$ = av_buffersink_get_w.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_w", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_h {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_h");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_h(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_h$descriptor() {
        return av_buffersink_get_h.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_h(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_h$handle() {
        return av_buffersink_get_h.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_h(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_h$address() {
        return av_buffersink_get_h.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_h(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_h(MemorySegment ctx) {
        var mh$ = av_buffersink_get_h.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_h", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_sample_aspect_ratio {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            AVRational.layout(),
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_sample_aspect_ratio");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_sample_aspect_ratio(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_sample_aspect_ratio$descriptor() {
        return av_buffersink_get_sample_aspect_ratio.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_sample_aspect_ratio(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_sample_aspect_ratio$handle() {
        return av_buffersink_get_sample_aspect_ratio.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVRational av_buffersink_get_sample_aspect_ratio(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_sample_aspect_ratio$address() {
        return av_buffersink_get_sample_aspect_ratio.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVRational av_buffersink_get_sample_aspect_ratio(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_sample_aspect_ratio(SegmentAllocator allocator, MemorySegment ctx) {
        var mh$ = av_buffersink_get_sample_aspect_ratio.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_sample_aspect_ratio", allocator, ctx);
            }
            return (MemorySegment)mh$.invokeExact(allocator, ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_colorspace {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_colorspace");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVColorSpace av_buffersink_get_colorspace(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_colorspace$descriptor() {
        return av_buffersink_get_colorspace.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVColorSpace av_buffersink_get_colorspace(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_colorspace$handle() {
        return av_buffersink_get_colorspace.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVColorSpace av_buffersink_get_colorspace(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_colorspace$address() {
        return av_buffersink_get_colorspace.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVColorSpace av_buffersink_get_colorspace(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_colorspace(MemorySegment ctx) {
        var mh$ = av_buffersink_get_colorspace.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_colorspace", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_color_range {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_color_range");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum AVColorRange av_buffersink_get_color_range(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_color_range$descriptor() {
        return av_buffersink_get_color_range.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum AVColorRange av_buffersink_get_color_range(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_color_range$handle() {
        return av_buffersink_get_color_range.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum AVColorRange av_buffersink_get_color_range(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_color_range$address() {
        return av_buffersink_get_color_range.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum AVColorRange av_buffersink_get_color_range(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_color_range(MemorySegment ctx) {
        var mh$ = av_buffersink_get_color_range.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_color_range", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_channels {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_channels");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_channels(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_channels$descriptor() {
        return av_buffersink_get_channels.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_channels(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_channels$handle() {
        return av_buffersink_get_channels.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_channels(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_channels$address() {
        return av_buffersink_get_channels.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_channels(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_channels(MemorySegment ctx) {
        var mh$ = av_buffersink_get_channels.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_channels", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_ch_layout {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_ch_layout");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_ch_layout(const AVFilterContext *ctx, AVChannelLayout *ch_layout)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_ch_layout$descriptor() {
        return av_buffersink_get_ch_layout.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_ch_layout(const AVFilterContext *ctx, AVChannelLayout *ch_layout)
     * }
     */
    public static MethodHandle av_buffersink_get_ch_layout$handle() {
        return av_buffersink_get_ch_layout.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_ch_layout(const AVFilterContext *ctx, AVChannelLayout *ch_layout)
     * }
     */
    public static MemorySegment av_buffersink_get_ch_layout$address() {
        return av_buffersink_get_ch_layout.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_ch_layout(const AVFilterContext *ctx, AVChannelLayout *ch_layout)
     * }
     */
    public static int av_buffersink_get_ch_layout(MemorySegment ctx, MemorySegment ch_layout) {
        var mh$ = av_buffersink_get_ch_layout.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_ch_layout", ctx, ch_layout);
            }
            return (int)mh$.invokeExact(ctx, ch_layout);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_sample_rate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_sample_rate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_sample_rate(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_sample_rate$descriptor() {
        return av_buffersink_get_sample_rate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_sample_rate(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_sample_rate$handle() {
        return av_buffersink_get_sample_rate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_sample_rate(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_sample_rate$address() {
        return av_buffersink_get_sample_rate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_sample_rate(const AVFilterContext *ctx)
     * }
     */
    public static int av_buffersink_get_sample_rate(MemorySegment ctx) {
        var mh$ = av_buffersink_get_sample_rate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_sample_rate", ctx);
            }
            return (int)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_hw_frames_ctx {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_hw_frames_ctx");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffersink_get_hw_frames_ctx(const AVFilterContext *ctx)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_hw_frames_ctx$descriptor() {
        return av_buffersink_get_hw_frames_ctx.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffersink_get_hw_frames_ctx(const AVFilterContext *ctx)
     * }
     */
    public static MethodHandle av_buffersink_get_hw_frames_ctx$handle() {
        return av_buffersink_get_hw_frames_ctx.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * AVBufferRef *av_buffersink_get_hw_frames_ctx(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_hw_frames_ctx$address() {
        return av_buffersink_get_hw_frames_ctx.ADDR;
    }

    /**
     * {@snippet lang=c :
     * AVBufferRef *av_buffersink_get_hw_frames_ctx(const AVFilterContext *ctx)
     * }
     */
    public static MemorySegment av_buffersink_get_hw_frames_ctx(MemorySegment ctx) {
        var mh$ = av_buffersink_get_hw_frames_ctx.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_hw_frames_ctx", ctx);
            }
            return (MemorySegment)mh$.invokeExact(ctx);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_side_data {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_side_data");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const AVFrameSideData *const *av_buffersink_get_side_data(const AVFilterContext *ctx, int *nb_side_data)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_side_data$descriptor() {
        return av_buffersink_get_side_data.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const AVFrameSideData *const *av_buffersink_get_side_data(const AVFilterContext *ctx, int *nb_side_data)
     * }
     */
    public static MethodHandle av_buffersink_get_side_data$handle() {
        return av_buffersink_get_side_data.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const AVFrameSideData *const *av_buffersink_get_side_data(const AVFilterContext *ctx, int *nb_side_data)
     * }
     */
    public static MemorySegment av_buffersink_get_side_data$address() {
        return av_buffersink_get_side_data.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const AVFrameSideData *const *av_buffersink_get_side_data(const AVFilterContext *ctx, int *nb_side_data)
     * }
     */
    public static MemorySegment av_buffersink_get_side_data(MemorySegment ctx, MemorySegment nb_side_data) {
        var mh$ = av_buffersink_get_side_data.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_side_data", ctx, nb_side_data);
            }
            return (MemorySegment)mh$.invokeExact(ctx, nb_side_data);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_frame {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_frame");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_frame$descriptor() {
        return av_buffersink_get_frame.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static MethodHandle av_buffersink_get_frame$handle() {
        return av_buffersink_get_frame.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static MemorySegment av_buffersink_get_frame$address() {
        return av_buffersink_get_frame.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_frame(AVFilterContext *ctx, AVFrame *frame)
     * }
     */
    public static int av_buffersink_get_frame(MemorySegment ctx, MemorySegment frame) {
        var mh$ = av_buffersink_get_frame.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_frame", ctx, frame);
            }
            return (int)mh$.invokeExact(ctx, frame);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class av_buffersink_get_samples {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            FFmpeg.C_INT,
            FFmpeg.C_POINTER,
            FFmpeg.C_POINTER,
            FFmpeg.C_INT
        );

        public static final MemorySegment ADDR = SYMBOL_LOOKUP.findOrThrow("av_buffersink_get_samples");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int av_buffersink_get_samples(AVFilterContext *ctx, AVFrame *frame, int nb_samples)
     * }
     */
    public static FunctionDescriptor av_buffersink_get_samples$descriptor() {
        return av_buffersink_get_samples.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int av_buffersink_get_samples(AVFilterContext *ctx, AVFrame *frame, int nb_samples)
     * }
     */
    public static MethodHandle av_buffersink_get_samples$handle() {
        return av_buffersink_get_samples.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int av_buffersink_get_samples(AVFilterContext *ctx, AVFrame *frame, int nb_samples)
     * }
     */
    public static MemorySegment av_buffersink_get_samples$address() {
        return av_buffersink_get_samples.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int av_buffersink_get_samples(AVFilterContext *ctx, AVFrame *frame, int nb_samples)
     * }
     */
    public static int av_buffersink_get_samples(MemorySegment ctx, MemorySegment frame, int nb_samples) {
        var mh$ = av_buffersink_get_samples.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("av_buffersink_get_samples", ctx, frame, nb_samples);
            }
            return (int)mh$.invokeExact(ctx, frame, nb_samples);
        } catch (Error | RuntimeException ex) {
           throw ex;
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * #define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"
     * }
     */
    public static MemorySegment __DARWIN_SUF_EXTSN() {
        class Holder {
            static final MemorySegment __DARWIN_SUF_EXTSN
                = FFmpeg.LIBRARY_ARENA.allocateFrom("$DARWIN_EXTSN");
        }
        return Holder.__DARWIN_SUF_EXTSN;
    }
    private static final long __DARWIN_C_ANSI = 4096L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_ANSI 4096
     * }
     */
    public static long __DARWIN_C_ANSI() {
        return __DARWIN_C_ANSI;
    }
    private static final long __DARWIN_C_FULL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_FULL 900000
     * }
     */
    public static long __DARWIN_C_FULL() {
        return __DARWIN_C_FULL;
    }
    private static final long __DARWIN_C_LEVEL = 900000L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_C_LEVEL 900000
     * }
     */
    public static long __DARWIN_C_LEVEL() {
        return __DARWIN_C_LEVEL;
    }
    private static final int MAC_OS_X_VERSION_10_0 = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_0 1000
     * }
     */
    public static int MAC_OS_X_VERSION_10_0() {
        return MAC_OS_X_VERSION_10_0;
    }
    private static final int MAC_OS_X_VERSION_10_1 = (int)1010L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_1 1010
     * }
     */
    public static int MAC_OS_X_VERSION_10_1() {
        return MAC_OS_X_VERSION_10_1;
    }
    private static final int MAC_OS_X_VERSION_10_2 = (int)1020L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_2 1020
     * }
     */
    public static int MAC_OS_X_VERSION_10_2() {
        return MAC_OS_X_VERSION_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_3 = (int)1030L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_3 1030
     * }
     */
    public static int MAC_OS_X_VERSION_10_3() {
        return MAC_OS_X_VERSION_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_4 = (int)1040L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_4 1040
     * }
     */
    public static int MAC_OS_X_VERSION_10_4() {
        return MAC_OS_X_VERSION_10_4;
    }
    private static final int MAC_OS_X_VERSION_10_5 = (int)1050L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_5 1050
     * }
     */
    public static int MAC_OS_X_VERSION_10_5() {
        return MAC_OS_X_VERSION_10_5;
    }
    private static final int MAC_OS_X_VERSION_10_6 = (int)1060L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_6 1060
     * }
     */
    public static int MAC_OS_X_VERSION_10_6() {
        return MAC_OS_X_VERSION_10_6;
    }
    private static final int MAC_OS_X_VERSION_10_7 = (int)1070L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_7 1070
     * }
     */
    public static int MAC_OS_X_VERSION_10_7() {
        return MAC_OS_X_VERSION_10_7;
    }
    private static final int MAC_OS_X_VERSION_10_8 = (int)1080L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_8 1080
     * }
     */
    public static int MAC_OS_X_VERSION_10_8() {
        return MAC_OS_X_VERSION_10_8;
    }
    private static final int MAC_OS_X_VERSION_10_9 = (int)1090L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_9 1090
     * }
     */
    public static int MAC_OS_X_VERSION_10_9() {
        return MAC_OS_X_VERSION_10_9;
    }
    private static final int MAC_OS_X_VERSION_10_10 = (int)101000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10 101000
     * }
     */
    public static int MAC_OS_X_VERSION_10_10() {
        return MAC_OS_X_VERSION_10_10;
    }
    private static final int MAC_OS_X_VERSION_10_10_2 = (int)101002L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_2 101002
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_2() {
        return MAC_OS_X_VERSION_10_10_2;
    }
    private static final int MAC_OS_X_VERSION_10_10_3 = (int)101003L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_10_3 101003
     * }
     */
    public static int MAC_OS_X_VERSION_10_10_3() {
        return MAC_OS_X_VERSION_10_10_3;
    }
    private static final int MAC_OS_X_VERSION_10_11 = (int)101100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11 101100
     * }
     */
    public static int MAC_OS_X_VERSION_10_11() {
        return MAC_OS_X_VERSION_10_11;
    }
    private static final int MAC_OS_X_VERSION_10_11_2 = (int)101102L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_2 101102
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_2() {
        return MAC_OS_X_VERSION_10_11_2;
    }
    private static final int MAC_OS_X_VERSION_10_11_3 = (int)101103L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_3 101103
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_3() {
        return MAC_OS_X_VERSION_10_11_3;
    }
    private static final int MAC_OS_X_VERSION_10_11_4 = (int)101104L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_11_4 101104
     * }
     */
    public static int MAC_OS_X_VERSION_10_11_4() {
        return MAC_OS_X_VERSION_10_11_4;
    }
    private static final int MAC_OS_X_VERSION_10_12 = (int)101200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12 101200
     * }
     */
    public static int MAC_OS_X_VERSION_10_12() {
        return MAC_OS_X_VERSION_10_12;
    }
    private static final int MAC_OS_X_VERSION_10_12_1 = (int)101201L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_1 101201
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_1() {
        return MAC_OS_X_VERSION_10_12_1;
    }
    private static final int MAC_OS_X_VERSION_10_12_2 = (int)101202L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_2 101202
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_2() {
        return MAC_OS_X_VERSION_10_12_2;
    }
    private static final int MAC_OS_X_VERSION_10_12_4 = (int)101204L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_12_4 101204
     * }
     */
    public static int MAC_OS_X_VERSION_10_12_4() {
        return MAC_OS_X_VERSION_10_12_4;
    }
    private static final int MAC_OS_X_VERSION_10_13 = (int)101300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13 101300
     * }
     */
    public static int MAC_OS_X_VERSION_10_13() {
        return MAC_OS_X_VERSION_10_13;
    }
    private static final int MAC_OS_X_VERSION_10_13_1 = (int)101301L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_1 101301
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_1() {
        return MAC_OS_X_VERSION_10_13_1;
    }
    private static final int MAC_OS_X_VERSION_10_13_2 = (int)101302L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_2 101302
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_2() {
        return MAC_OS_X_VERSION_10_13_2;
    }
    private static final int MAC_OS_X_VERSION_10_13_4 = (int)101304L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_13_4 101304
     * }
     */
    public static int MAC_OS_X_VERSION_10_13_4() {
        return MAC_OS_X_VERSION_10_13_4;
    }
    private static final int MAC_OS_X_VERSION_10_14 = (int)101400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14 101400
     * }
     */
    public static int MAC_OS_X_VERSION_10_14() {
        return MAC_OS_X_VERSION_10_14;
    }
    private static final int MAC_OS_X_VERSION_10_14_1 = (int)101401L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_1 101401
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_1() {
        return MAC_OS_X_VERSION_10_14_1;
    }
    private static final int MAC_OS_X_VERSION_10_14_4 = (int)101404L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_4 101404
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_4() {
        return MAC_OS_X_VERSION_10_14_4;
    }
    private static final int MAC_OS_X_VERSION_10_14_5 = (int)101405L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_5 101405
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_5() {
        return MAC_OS_X_VERSION_10_14_5;
    }
    private static final int MAC_OS_X_VERSION_10_14_6 = (int)101406L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_14_6 101406
     * }
     */
    public static int MAC_OS_X_VERSION_10_14_6() {
        return MAC_OS_X_VERSION_10_14_6;
    }
    private static final int MAC_OS_X_VERSION_10_15 = (int)101500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15 101500
     * }
     */
    public static int MAC_OS_X_VERSION_10_15() {
        return MAC_OS_X_VERSION_10_15;
    }
    private static final int MAC_OS_X_VERSION_10_15_1 = (int)101501L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_1 101501
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_1() {
        return MAC_OS_X_VERSION_10_15_1;
    }
    private static final int MAC_OS_X_VERSION_10_15_4 = (int)101504L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_15_4 101504
     * }
     */
    public static int MAC_OS_X_VERSION_10_15_4() {
        return MAC_OS_X_VERSION_10_15_4;
    }
    private static final int MAC_OS_X_VERSION_10_16 = (int)101600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_X_VERSION_10_16 101600
     * }
     */
    public static int MAC_OS_X_VERSION_10_16() {
        return MAC_OS_X_VERSION_10_16;
    }
    private static final int MAC_OS_VERSION_11_0 = (int)110000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_0 110000
     * }
     */
    public static int MAC_OS_VERSION_11_0() {
        return MAC_OS_VERSION_11_0;
    }
    private static final int MAC_OS_VERSION_11_1 = (int)110100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_1 110100
     * }
     */
    public static int MAC_OS_VERSION_11_1() {
        return MAC_OS_VERSION_11_1;
    }
    private static final int MAC_OS_VERSION_11_3 = (int)110300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_3 110300
     * }
     */
    public static int MAC_OS_VERSION_11_3() {
        return MAC_OS_VERSION_11_3;
    }
    private static final int MAC_OS_VERSION_11_4 = (int)110400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_4 110400
     * }
     */
    public static int MAC_OS_VERSION_11_4() {
        return MAC_OS_VERSION_11_4;
    }
    private static final int MAC_OS_VERSION_11_5 = (int)110500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_5 110500
     * }
     */
    public static int MAC_OS_VERSION_11_5() {
        return MAC_OS_VERSION_11_5;
    }
    private static final int MAC_OS_VERSION_11_6 = (int)110600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_11_6 110600
     * }
     */
    public static int MAC_OS_VERSION_11_6() {
        return MAC_OS_VERSION_11_6;
    }
    private static final int MAC_OS_VERSION_12_0 = (int)120000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_0 120000
     * }
     */
    public static int MAC_OS_VERSION_12_0() {
        return MAC_OS_VERSION_12_0;
    }
    private static final int MAC_OS_VERSION_12_1 = (int)120100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_1 120100
     * }
     */
    public static int MAC_OS_VERSION_12_1() {
        return MAC_OS_VERSION_12_1;
    }
    private static final int MAC_OS_VERSION_12_2 = (int)120200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_2 120200
     * }
     */
    public static int MAC_OS_VERSION_12_2() {
        return MAC_OS_VERSION_12_2;
    }
    private static final int MAC_OS_VERSION_12_3 = (int)120300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_3 120300
     * }
     */
    public static int MAC_OS_VERSION_12_3() {
        return MAC_OS_VERSION_12_3;
    }
    private static final int MAC_OS_VERSION_12_4 = (int)120400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_4 120400
     * }
     */
    public static int MAC_OS_VERSION_12_4() {
        return MAC_OS_VERSION_12_4;
    }
    private static final int MAC_OS_VERSION_12_5 = (int)120500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_5 120500
     * }
     */
    public static int MAC_OS_VERSION_12_5() {
        return MAC_OS_VERSION_12_5;
    }
    private static final int MAC_OS_VERSION_12_6 = (int)120600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_6 120600
     * }
     */
    public static int MAC_OS_VERSION_12_6() {
        return MAC_OS_VERSION_12_6;
    }
    private static final int MAC_OS_VERSION_12_7 = (int)120700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_12_7 120700
     * }
     */
    public static int MAC_OS_VERSION_12_7() {
        return MAC_OS_VERSION_12_7;
    }
    private static final int MAC_OS_VERSION_13_0 = (int)130000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_0 130000
     * }
     */
    public static int MAC_OS_VERSION_13_0() {
        return MAC_OS_VERSION_13_0;
    }
    private static final int MAC_OS_VERSION_13_1 = (int)130100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_1 130100
     * }
     */
    public static int MAC_OS_VERSION_13_1() {
        return MAC_OS_VERSION_13_1;
    }
    private static final int MAC_OS_VERSION_13_2 = (int)130200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_2 130200
     * }
     */
    public static int MAC_OS_VERSION_13_2() {
        return MAC_OS_VERSION_13_2;
    }
    private static final int MAC_OS_VERSION_13_3 = (int)130300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_3 130300
     * }
     */
    public static int MAC_OS_VERSION_13_3() {
        return MAC_OS_VERSION_13_3;
    }
    private static final int MAC_OS_VERSION_13_4 = (int)130400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_4 130400
     * }
     */
    public static int MAC_OS_VERSION_13_4() {
        return MAC_OS_VERSION_13_4;
    }
    private static final int MAC_OS_VERSION_13_5 = (int)130500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_5 130500
     * }
     */
    public static int MAC_OS_VERSION_13_5() {
        return MAC_OS_VERSION_13_5;
    }
    private static final int MAC_OS_VERSION_13_6 = (int)130600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_6 130600
     * }
     */
    public static int MAC_OS_VERSION_13_6() {
        return MAC_OS_VERSION_13_6;
    }
    private static final int MAC_OS_VERSION_13_7 = (int)130700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_13_7 130700
     * }
     */
    public static int MAC_OS_VERSION_13_7() {
        return MAC_OS_VERSION_13_7;
    }
    private static final int MAC_OS_VERSION_14_0 = (int)140000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_0 140000
     * }
     */
    public static int MAC_OS_VERSION_14_0() {
        return MAC_OS_VERSION_14_0;
    }
    private static final int MAC_OS_VERSION_14_1 = (int)140100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_1 140100
     * }
     */
    public static int MAC_OS_VERSION_14_1() {
        return MAC_OS_VERSION_14_1;
    }
    private static final int MAC_OS_VERSION_14_2 = (int)140200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_2 140200
     * }
     */
    public static int MAC_OS_VERSION_14_2() {
        return MAC_OS_VERSION_14_2;
    }
    private static final int MAC_OS_VERSION_14_3 = (int)140300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_3 140300
     * }
     */
    public static int MAC_OS_VERSION_14_3() {
        return MAC_OS_VERSION_14_3;
    }
    private static final int MAC_OS_VERSION_14_4 = (int)140400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_4 140400
     * }
     */
    public static int MAC_OS_VERSION_14_4() {
        return MAC_OS_VERSION_14_4;
    }
    private static final int MAC_OS_VERSION_14_5 = (int)140500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_5 140500
     * }
     */
    public static int MAC_OS_VERSION_14_5() {
        return MAC_OS_VERSION_14_5;
    }
    private static final int MAC_OS_VERSION_14_6 = (int)140600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_6 140600
     * }
     */
    public static int MAC_OS_VERSION_14_6() {
        return MAC_OS_VERSION_14_6;
    }
    private static final int MAC_OS_VERSION_14_7 = (int)140700L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_14_7 140700
     * }
     */
    public static int MAC_OS_VERSION_14_7() {
        return MAC_OS_VERSION_14_7;
    }
    private static final int MAC_OS_VERSION_15_0 = (int)150000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_0 150000
     * }
     */
    public static int MAC_OS_VERSION_15_0() {
        return MAC_OS_VERSION_15_0;
    }
    private static final int MAC_OS_VERSION_15_1 = (int)150100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_1 150100
     * }
     */
    public static int MAC_OS_VERSION_15_1() {
        return MAC_OS_VERSION_15_1;
    }
    private static final int MAC_OS_VERSION_15_2 = (int)150200L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_2 150200
     * }
     */
    public static int MAC_OS_VERSION_15_2() {
        return MAC_OS_VERSION_15_2;
    }
    private static final int MAC_OS_VERSION_15_3 = (int)150300L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_3 150300
     * }
     */
    public static int MAC_OS_VERSION_15_3() {
        return MAC_OS_VERSION_15_3;
    }
    private static final int MAC_OS_VERSION_15_4 = (int)150400L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_4 150400
     * }
     */
    public static int MAC_OS_VERSION_15_4() {
        return MAC_OS_VERSION_15_4;
    }
    private static final int MAC_OS_VERSION_15_5 = (int)150500L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_5 150500
     * }
     */
    public static int MAC_OS_VERSION_15_5() {
        return MAC_OS_VERSION_15_5;
    }
    private static final int MAC_OS_VERSION_15_6 = (int)150600L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_15_6 150600
     * }
     */
    public static int MAC_OS_VERSION_15_6() {
        return MAC_OS_VERSION_15_6;
    }
    private static final int MAC_OS_VERSION_16_0 = (int)160000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_16_0 160000
     * }
     */
    public static int MAC_OS_VERSION_16_0() {
        return MAC_OS_VERSION_16_0;
    }
    private static final int MAC_OS_VERSION_26_0 = (int)260000L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_26_0 260000
     * }
     */
    public static int MAC_OS_VERSION_26_0() {
        return MAC_OS_VERSION_26_0;
    }
    private static final int MAC_OS_VERSION_26_1 = (int)260100L;
    /**
     * {@snippet lang=c :
     * #define MAC_OS_VERSION_26_1 260100
     * }
     */
    public static int MAC_OS_VERSION_26_1() {
        return MAC_OS_VERSION_26_1;
    }
    private static final int __AVAILABILITY_VERSIONS_VERSION_HASH = (int)93585900L;
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_HASH 93585900
     * }
     */
    public static int __AVAILABILITY_VERSIONS_VERSION_HASH() {
        return __AVAILABILITY_VERSIONS_VERSION_HASH;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_VERSIONS_VERSION_STRING "Local"
     * }
     */
    public static MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING() {
        class Holder {
            static final MemorySegment __AVAILABILITY_VERSIONS_VERSION_STRING
                = FFmpeg.LIBRARY_ARENA.allocateFrom("Local");
        }
        return Holder.__AVAILABILITY_VERSIONS_VERSION_STRING;
    }
    /**
     * {@snippet lang=c :
     * #define __AVAILABILITY_FILE "AvailabilityVersions.h"
     * }
     */
    public static MemorySegment __AVAILABILITY_FILE() {
        class Holder {
            static final MemorySegment __AVAILABILITY_FILE
                = FFmpeg.LIBRARY_ARENA.allocateFrom("AvailabilityVersions.h");
        }
        return Holder.__AVAILABILITY_FILE;
    }
    private static final int __MAC_OS_X_VERSION_MAX_ALLOWED = (int)260100L;
    /**
     * {@snippet lang=c :
     * #define __MAC_OS_X_VERSION_MAX_ALLOWED 260100
     * }
     */
    public static int __MAC_OS_X_VERSION_MAX_ALLOWED() {
        return __MAC_OS_X_VERSION_MAX_ALLOWED;
    }
    private static final MemorySegment __DARWIN_NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define __DARWIN_NULL (void*) 0
     * }
     */
    public static MemorySegment __DARWIN_NULL() {
        return __DARWIN_NULL;
    }
    private static final int __DARWIN_WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MAX 2147483647
     * }
     */
    public static int __DARWIN_WCHAR_MAX() {
        return __DARWIN_WCHAR_MAX;
    }
    private static final int __DARWIN_WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WCHAR_MIN -2147483648
     * }
     */
    public static int __DARWIN_WCHAR_MIN() {
        return __DARWIN_WCHAR_MIN;
    }
    private static final int __DARWIN_WEOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_WEOF -1
     * }
     */
    public static int __DARWIN_WEOF() {
        return __DARWIN_WEOF;
    }
    private static final long USER_ADDR_NULL = 0L;
    /**
     * {@snippet lang=c :
     * #define USER_ADDR_NULL 0
     * }
     */
    public static long USER_ADDR_NULL() {
        return USER_ADDR_NULL;
    }
    private static final MemorySegment NULL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define NULL (void*) 0
     * }
     */
    public static MemorySegment NULL() {
        return NULL;
    }
    private static final int EOF = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define EOF -1
     * }
     */
    public static int EOF() {
        return EOF;
    }
    /**
     * {@snippet lang=c :
     * #define P_tmpdir "/var/tmp/"
     * }
     */
    public static MemorySegment P_tmpdir() {
        class Holder {
            static final MemorySegment P_tmpdir
                = FFmpeg.LIBRARY_ARENA.allocateFrom("/var/tmp/");
        }
        return Holder.P_tmpdir;
    }
    private static final long INT64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT64_MAX 9223372036854775807
     * }
     */
    public static long INT64_MAX() {
        return INT64_MAX;
    }
    private static final int INT8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT8_MIN -128
     * }
     */
    public static int INT8_MIN() {
        return INT8_MIN;
    }
    private static final int INT16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT16_MIN -32768
     * }
     */
    public static int INT16_MIN() {
        return INT16_MIN;
    }
    private static final int INT32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT32_MIN -2147483648
     * }
     */
    public static int INT32_MIN() {
        return INT32_MIN;
    }
    private static final long INT64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT64_MIN -9223372036854775808
     * }
     */
    public static long INT64_MIN() {
        return INT64_MIN;
    }
    private static final int UINT32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT32_MAX 4294967295
     * }
     */
    public static int UINT32_MAX() {
        return UINT32_MAX;
    }
    private static final long UINT64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT64_MAX -1
     * }
     */
    public static long UINT64_MAX() {
        return UINT64_MAX;
    }
    private static final int INT_LEAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MIN -128
     * }
     */
    public static int INT_LEAST8_MIN() {
        return INT_LEAST8_MIN;
    }
    private static final int INT_LEAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MIN -32768
     * }
     */
    public static int INT_LEAST16_MIN() {
        return INT_LEAST16_MIN;
    }
    private static final int INT_LEAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MIN -2147483648
     * }
     */
    public static int INT_LEAST32_MIN() {
        return INT_LEAST32_MIN;
    }
    private static final long INT_LEAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_LEAST64_MIN() {
        return INT_LEAST64_MIN;
    }
    private static final int INT_LEAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST8_MAX 127
     * }
     */
    public static int INT_LEAST8_MAX() {
        return INT_LEAST8_MAX;
    }
    private static final int INT_LEAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST16_MAX 32767
     * }
     */
    public static int INT_LEAST16_MAX() {
        return INT_LEAST16_MAX;
    }
    private static final int INT_LEAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST32_MAX 2147483647
     * }
     */
    public static int INT_LEAST32_MAX() {
        return INT_LEAST32_MAX;
    }
    private static final long INT_LEAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_LEAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_LEAST64_MAX() {
        return INT_LEAST64_MAX;
    }
    private static final int UINT_LEAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST8_MAX 255
     * }
     */
    public static int UINT_LEAST8_MAX() {
        return UINT_LEAST8_MAX;
    }
    private static final int UINT_LEAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST16_MAX 65535
     * }
     */
    public static int UINT_LEAST16_MAX() {
        return UINT_LEAST16_MAX;
    }
    private static final int UINT_LEAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST32_MAX 4294967295
     * }
     */
    public static int UINT_LEAST32_MAX() {
        return UINT_LEAST32_MAX;
    }
    private static final long UINT_LEAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_LEAST64_MAX -1
     * }
     */
    public static long UINT_LEAST64_MAX() {
        return UINT_LEAST64_MAX;
    }
    private static final int INT_FAST8_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MIN -128
     * }
     */
    public static int INT_FAST8_MIN() {
        return INT_FAST8_MIN;
    }
    private static final int INT_FAST16_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MIN -32768
     * }
     */
    public static int INT_FAST16_MIN() {
        return INT_FAST16_MIN;
    }
    private static final int INT_FAST32_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MIN -2147483648
     * }
     */
    public static int INT_FAST32_MIN() {
        return INT_FAST32_MIN;
    }
    private static final long INT_FAST64_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MIN -9223372036854775808
     * }
     */
    public static long INT_FAST64_MIN() {
        return INT_FAST64_MIN;
    }
    private static final int INT_FAST8_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST8_MAX 127
     * }
     */
    public static int INT_FAST8_MAX() {
        return INT_FAST8_MAX;
    }
    private static final int INT_FAST16_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST16_MAX 32767
     * }
     */
    public static int INT_FAST16_MAX() {
        return INT_FAST16_MAX;
    }
    private static final int INT_FAST32_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST32_MAX 2147483647
     * }
     */
    public static int INT_FAST32_MAX() {
        return INT_FAST32_MAX;
    }
    private static final long INT_FAST64_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INT_FAST64_MAX 9223372036854775807
     * }
     */
    public static long INT_FAST64_MAX() {
        return INT_FAST64_MAX;
    }
    private static final int UINT_FAST8_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST8_MAX 255
     * }
     */
    public static int UINT_FAST8_MAX() {
        return UINT_FAST8_MAX;
    }
    private static final int UINT_FAST16_MAX = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST16_MAX 65535
     * }
     */
    public static int UINT_FAST16_MAX() {
        return UINT_FAST16_MAX;
    }
    private static final int UINT_FAST32_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST32_MAX 4294967295
     * }
     */
    public static int UINT_FAST32_MAX() {
        return UINT_FAST32_MAX;
    }
    private static final long UINT_FAST64_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINT_FAST64_MAX -1
     * }
     */
    public static long UINT_FAST64_MAX() {
        return UINT_FAST64_MAX;
    }
    private static final long INTPTR_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MAX 9223372036854775807
     * }
     */
    public static long INTPTR_MAX() {
        return INTPTR_MAX;
    }
    private static final long INTPTR_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTPTR_MIN -9223372036854775808
     * }
     */
    public static long INTPTR_MIN() {
        return INTPTR_MIN;
    }
    private static final long UINTPTR_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTPTR_MAX -1
     * }
     */
    public static long UINTPTR_MAX() {
        return UINTPTR_MAX;
    }
    private static final long INTMAX_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MAX 9223372036854775807
     * }
     */
    public static long INTMAX_MAX() {
        return INTMAX_MAX;
    }
    private static final long UINTMAX_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UINTMAX_MAX -1
     * }
     */
    public static long UINTMAX_MAX() {
        return UINTMAX_MAX;
    }
    private static final long INTMAX_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define INTMAX_MIN -9223372036854775808
     * }
     */
    public static long INTMAX_MIN() {
        return INTMAX_MIN;
    }
    private static final long PTRDIFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MIN -9223372036854775808
     * }
     */
    public static long PTRDIFF_MIN() {
        return PTRDIFF_MIN;
    }
    private static final long PTRDIFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define PTRDIFF_MAX 9223372036854775807
     * }
     */
    public static long PTRDIFF_MAX() {
        return PTRDIFF_MAX;
    }
    private static final long SIZE_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_MAX -1
     * }
     */
    public static long SIZE_MAX() {
        return SIZE_MAX;
    }
    private static final long RSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RSIZE_MAX 9223372036854775807
     * }
     */
    public static long RSIZE_MAX() {
        return RSIZE_MAX;
    }
    private static final int WCHAR_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MAX 2147483647
     * }
     */
    public static int WCHAR_MAX() {
        return WCHAR_MAX;
    }
    private static final int WCHAR_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WCHAR_MIN -2147483648
     * }
     */
    public static int WCHAR_MIN() {
        return WCHAR_MIN;
    }
    private static final int WINT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define WINT_MIN -2147483648
     * }
     */
    public static int WINT_MIN() {
        return WINT_MIN;
    }
    private static final int WINT_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define WINT_MAX 2147483647
     * }
     */
    public static int WINT_MAX() {
        return WINT_MAX;
    }
    private static final int SIG_ATOMIC_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MIN -2147483648
     * }
     */
    public static int SIG_ATOMIC_MIN() {
        return SIG_ATOMIC_MIN;
    }
    private static final int SIG_ATOMIC_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define SIG_ATOMIC_MAX 2147483647
     * }
     */
    public static int SIG_ATOMIC_MAX() {
        return SIG_ATOMIC_MAX;
    }
    private static final int FF_LAMBDA_SCALE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_LAMBDA_SCALE 128
     * }
     */
    public static int FF_LAMBDA_SCALE() {
        return FF_LAMBDA_SCALE;
    }
    private static final int FF_LAMBDA_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define FF_LAMBDA_MAX 32767
     * }
     */
    public static int FF_LAMBDA_MAX() {
        return FF_LAMBDA_MAX;
    }
    private static final int FF_QUALITY_SCALE = (int)128L;
    /**
     * {@snippet lang=c :
     * #define FF_QUALITY_SCALE 128
     * }
     */
    public static int FF_QUALITY_SCALE() {
        return FF_QUALITY_SCALE;
    }
    private static final long AV_NOPTS_VALUE = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define AV_NOPTS_VALUE -9223372036854775808
     * }
     */
    public static long AV_NOPTS_VALUE() {
        return AV_NOPTS_VALUE;
    }
    private static final int EWOULDBLOCK = (int)35L;
    /**
     * {@snippet lang=c :
     * #define EWOULDBLOCK 35
     * }
     */
    public static int EWOULDBLOCK() {
        return EWOULDBLOCK;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI_8_LENGTH_MODIFIER__ "hh"
     * }
     */
    public static MemorySegment __PRI_8_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __PRI_8_LENGTH_MODIFIER__
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hh");
        }
        return Holder.__PRI_8_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI_64_LENGTH_MODIFIER__ "ll"
     * }
     */
    public static MemorySegment __PRI_64_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __PRI_64_LENGTH_MODIFIER__
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ll");
        }
        return Holder.__PRI_64_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __SCN_64_LENGTH_MODIFIER__ "ll"
     * }
     */
    public static MemorySegment __SCN_64_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __SCN_64_LENGTH_MODIFIER__
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ll");
        }
        return Holder.__SCN_64_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __PRI_MAX_LENGTH_MODIFIER__ "j"
     * }
     */
    public static MemorySegment __PRI_MAX_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __PRI_MAX_LENGTH_MODIFIER__
                = FFmpeg.LIBRARY_ARENA.allocateFrom("j");
        }
        return Holder.__PRI_MAX_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define __SCN_MAX_LENGTH_MODIFIER__ "j"
     * }
     */
    public static MemorySegment __SCN_MAX_LENGTH_MODIFIER__() {
        class Holder {
            static final MemorySegment __SCN_MAX_LENGTH_MODIFIER__
                = FFmpeg.LIBRARY_ARENA.allocateFrom("j");
        }
        return Holder.__SCN_MAX_LENGTH_MODIFIER__;
    }
    /**
     * {@snippet lang=c :
     * #define PRId8 "hhd"
     * }
     */
    public static MemorySegment PRId8() {
        class Holder {
            static final MemorySegment PRId8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRId8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi8 "hhi"
     * }
     */
    public static MemorySegment PRIi8() {
        class Holder {
            static final MemorySegment PRIi8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIi8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo8 "hho"
     * }
     */
    public static MemorySegment PRIo8() {
        class Holder {
            static final MemorySegment PRIo8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIo8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu8 "hhu"
     * }
     */
    public static MemorySegment PRIu8() {
        class Holder {
            static final MemorySegment PRIu8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIu8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx8 "hhx"
     * }
     */
    public static MemorySegment PRIx8() {
        class Holder {
            static final MemorySegment PRIx8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIx8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX8 "hhX"
     * }
     */
    public static MemorySegment PRIX8() {
        class Holder {
            static final MemorySegment PRIX8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIX8;
    }
    /**
     * {@snippet lang=c :
     * #define PRId16 "hd"
     * }
     */
    public static MemorySegment PRId16() {
        class Holder {
            static final MemorySegment PRId16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRId16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi16 "hi"
     * }
     */
    public static MemorySegment PRIi16() {
        class Holder {
            static final MemorySegment PRIi16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIi16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo16 "ho"
     * }
     */
    public static MemorySegment PRIo16() {
        class Holder {
            static final MemorySegment PRIo16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIo16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu16 "hu"
     * }
     */
    public static MemorySegment PRIu16() {
        class Holder {
            static final MemorySegment PRIu16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIu16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx16 "hx"
     * }
     */
    public static MemorySegment PRIx16() {
        class Holder {
            static final MemorySegment PRIx16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIx16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX16 "hX"
     * }
     */
    public static MemorySegment PRIX16() {
        class Holder {
            static final MemorySegment PRIX16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIX16;
    }
    /**
     * {@snippet lang=c :
     * #define PRId32 "d"
     * }
     */
    public static MemorySegment PRId32() {
        class Holder {
            static final MemorySegment PRId32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRId32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi32 "i"
     * }
     */
    public static MemorySegment PRIi32() {
        class Holder {
            static final MemorySegment PRIi32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIi32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo32 "o"
     * }
     */
    public static MemorySegment PRIo32() {
        class Holder {
            static final MemorySegment PRIo32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIo32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu32 "u"
     * }
     */
    public static MemorySegment PRIu32() {
        class Holder {
            static final MemorySegment PRIu32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIu32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx32 "x"
     * }
     */
    public static MemorySegment PRIx32() {
        class Holder {
            static final MemorySegment PRIx32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIx32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX32 "X"
     * }
     */
    public static MemorySegment PRIX32() {
        class Holder {
            static final MemorySegment PRIX32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIX32;
    }
    /**
     * {@snippet lang=c :
     * #define PRId64 "lld"
     * }
     */
    public static MemorySegment PRId64() {
        class Holder {
            static final MemorySegment PRId64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRId64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIi64 "lli"
     * }
     */
    public static MemorySegment PRIi64() {
        class Holder {
            static final MemorySegment PRIi64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIi64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIo64 "llo"
     * }
     */
    public static MemorySegment PRIo64() {
        class Holder {
            static final MemorySegment PRIo64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIo64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIu64 "llu"
     * }
     */
    public static MemorySegment PRIu64() {
        class Holder {
            static final MemorySegment PRIu64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIu64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIx64 "llx"
     * }
     */
    public static MemorySegment PRIx64() {
        class Holder {
            static final MemorySegment PRIx64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIx64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIX64 "llX"
     * }
     */
    public static MemorySegment PRIX64() {
        class Holder {
            static final MemorySegment PRIX64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIX64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdLEAST8() {
        class Holder {
            static final MemorySegment PRIdLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiLEAST8() {
        class Holder {
            static final MemorySegment PRIiLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST8 "hho"
     * }
     */
    public static MemorySegment PRIoLEAST8() {
        class Holder {
            static final MemorySegment PRIoLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuLEAST8() {
        class Holder {
            static final MemorySegment PRIuLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxLEAST8() {
        class Holder {
            static final MemorySegment PRIxLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXLEAST8() {
        class Holder {
            static final MemorySegment PRIXLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST16 "hd"
     * }
     */
    public static MemorySegment PRIdLEAST16() {
        class Holder {
            static final MemorySegment PRIdLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRIdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST16 "hi"
     * }
     */
    public static MemorySegment PRIiLEAST16() {
        class Holder {
            static final MemorySegment PRIiLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST16 "ho"
     * }
     */
    public static MemorySegment PRIoLEAST16() {
        class Holder {
            static final MemorySegment PRIoLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST16 "hu"
     * }
     */
    public static MemorySegment PRIuLEAST16() {
        class Holder {
            static final MemorySegment PRIuLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST16 "hx"
     * }
     */
    public static MemorySegment PRIxLEAST16() {
        class Holder {
            static final MemorySegment PRIxLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST16 "hX"
     * }
     */
    public static MemorySegment PRIXLEAST16() {
        class Holder {
            static final MemorySegment PRIXLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIXLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST32 "d"
     * }
     */
    public static MemorySegment PRIdLEAST32() {
        class Holder {
            static final MemorySegment PRIdLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST32 "i"
     * }
     */
    public static MemorySegment PRIiLEAST32() {
        class Holder {
            static final MemorySegment PRIiLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST32 "o"
     * }
     */
    public static MemorySegment PRIoLEAST32() {
        class Holder {
            static final MemorySegment PRIoLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST32 "u"
     * }
     */
    public static MemorySegment PRIuLEAST32() {
        class Holder {
            static final MemorySegment PRIuLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST32 "x"
     * }
     */
    public static MemorySegment PRIxLEAST32() {
        class Holder {
            static final MemorySegment PRIxLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST32 "X"
     * }
     */
    public static MemorySegment PRIXLEAST32() {
        class Holder {
            static final MemorySegment PRIXLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdLEAST64 "lld"
     * }
     */
    public static MemorySegment PRIdLEAST64() {
        class Holder {
            static final MemorySegment PRIdLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiLEAST64 "lli"
     * }
     */
    public static MemorySegment PRIiLEAST64() {
        class Holder {
            static final MemorySegment PRIiLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoLEAST64 "llo"
     * }
     */
    public static MemorySegment PRIoLEAST64() {
        class Holder {
            static final MemorySegment PRIoLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuLEAST64 "llu"
     * }
     */
    public static MemorySegment PRIuLEAST64() {
        class Holder {
            static final MemorySegment PRIuLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxLEAST64 "llx"
     * }
     */
    public static MemorySegment PRIxLEAST64() {
        class Holder {
            static final MemorySegment PRIxLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXLEAST64 "llX"
     * }
     */
    public static MemorySegment PRIXLEAST64() {
        class Holder {
            static final MemorySegment PRIXLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST8 "hhd"
     * }
     */
    public static MemorySegment PRIdFAST8() {
        class Holder {
            static final MemorySegment PRIdFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.PRIdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST8 "hhi"
     * }
     */
    public static MemorySegment PRIiFAST8() {
        class Holder {
            static final MemorySegment PRIiFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.PRIiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST8 "hho"
     * }
     */
    public static MemorySegment PRIoFAST8() {
        class Holder {
            static final MemorySegment PRIoFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.PRIoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST8 "hhu"
     * }
     */
    public static MemorySegment PRIuFAST8() {
        class Holder {
            static final MemorySegment PRIuFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.PRIuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST8 "hhx"
     * }
     */
    public static MemorySegment PRIxFAST8() {
        class Holder {
            static final MemorySegment PRIxFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.PRIxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST8 "hhX"
     * }
     */
    public static MemorySegment PRIXFAST8() {
        class Holder {
            static final MemorySegment PRIXFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhX");
        }
        return Holder.PRIXFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST16 "hd"
     * }
     */
    public static MemorySegment PRIdFAST16() {
        class Holder {
            static final MemorySegment PRIdFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.PRIdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST16 "hi"
     * }
     */
    public static MemorySegment PRIiFAST16() {
        class Holder {
            static final MemorySegment PRIiFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.PRIiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST16 "ho"
     * }
     */
    public static MemorySegment PRIoFAST16() {
        class Holder {
            static final MemorySegment PRIoFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.PRIoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST16 "hu"
     * }
     */
    public static MemorySegment PRIuFAST16() {
        class Holder {
            static final MemorySegment PRIuFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.PRIuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST16 "hx"
     * }
     */
    public static MemorySegment PRIxFAST16() {
        class Holder {
            static final MemorySegment PRIxFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.PRIxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST16 "hX"
     * }
     */
    public static MemorySegment PRIXFAST16() {
        class Holder {
            static final MemorySegment PRIXFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hX");
        }
        return Holder.PRIXFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST32 "d"
     * }
     */
    public static MemorySegment PRIdFAST32() {
        class Holder {
            static final MemorySegment PRIdFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.PRIdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST32 "i"
     * }
     */
    public static MemorySegment PRIiFAST32() {
        class Holder {
            static final MemorySegment PRIiFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.PRIiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST32 "o"
     * }
     */
    public static MemorySegment PRIoFAST32() {
        class Holder {
            static final MemorySegment PRIoFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.PRIoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST32 "u"
     * }
     */
    public static MemorySegment PRIuFAST32() {
        class Holder {
            static final MemorySegment PRIuFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.PRIuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST32 "x"
     * }
     */
    public static MemorySegment PRIxFAST32() {
        class Holder {
            static final MemorySegment PRIxFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.PRIxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST32 "X"
     * }
     */
    public static MemorySegment PRIXFAST32() {
        class Holder {
            static final MemorySegment PRIXFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("X");
        }
        return Holder.PRIXFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdFAST64 "lld"
     * }
     */
    public static MemorySegment PRIdFAST64() {
        class Holder {
            static final MemorySegment PRIdFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.PRIdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiFAST64 "lli"
     * }
     */
    public static MemorySegment PRIiFAST64() {
        class Holder {
            static final MemorySegment PRIiFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.PRIiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoFAST64 "llo"
     * }
     */
    public static MemorySegment PRIoFAST64() {
        class Holder {
            static final MemorySegment PRIoFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.PRIoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuFAST64 "llu"
     * }
     */
    public static MemorySegment PRIuFAST64() {
        class Holder {
            static final MemorySegment PRIuFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.PRIuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxFAST64 "llx"
     * }
     */
    public static MemorySegment PRIxFAST64() {
        class Holder {
            static final MemorySegment PRIxFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.PRIxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXFAST64 "llX"
     * }
     */
    public static MemorySegment PRIXFAST64() {
        class Holder {
            static final MemorySegment PRIXFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llX");
        }
        return Holder.PRIXFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdPTR "ld"
     * }
     */
    public static MemorySegment PRIdPTR() {
        class Holder {
            static final MemorySegment PRIdPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.PRIdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiPTR "li"
     * }
     */
    public static MemorySegment PRIiPTR() {
        class Holder {
            static final MemorySegment PRIiPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.PRIiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoPTR "lo"
     * }
     */
    public static MemorySegment PRIoPTR() {
        class Holder {
            static final MemorySegment PRIoPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.PRIoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuPTR "lu"
     * }
     */
    public static MemorySegment PRIuPTR() {
        class Holder {
            static final MemorySegment PRIuPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.PRIuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxPTR "lx"
     * }
     */
    public static MemorySegment PRIxPTR() {
        class Holder {
            static final MemorySegment PRIxPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.PRIxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXPTR "lX"
     * }
     */
    public static MemorySegment PRIXPTR() {
        class Holder {
            static final MemorySegment PRIXPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lX");
        }
        return Holder.PRIXPTR;
    }
    /**
     * {@snippet lang=c :
     * #define PRIdMAX "jd"
     * }
     */
    public static MemorySegment PRIdMAX() {
        class Holder {
            static final MemorySegment PRIdMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("jd");
        }
        return Holder.PRIdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIiMAX "ji"
     * }
     */
    public static MemorySegment PRIiMAX() {
        class Holder {
            static final MemorySegment PRIiMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ji");
        }
        return Holder.PRIiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIoMAX "jo"
     * }
     */
    public static MemorySegment PRIoMAX() {
        class Holder {
            static final MemorySegment PRIoMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("jo");
        }
        return Holder.PRIoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIuMAX "ju"
     * }
     */
    public static MemorySegment PRIuMAX() {
        class Holder {
            static final MemorySegment PRIuMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ju");
        }
        return Holder.PRIuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIxMAX "jx"
     * }
     */
    public static MemorySegment PRIxMAX() {
        class Holder {
            static final MemorySegment PRIxMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("jx");
        }
        return Holder.PRIxMAX;
    }
    /**
     * {@snippet lang=c :
     * #define PRIXMAX "jX"
     * }
     */
    public static MemorySegment PRIXMAX() {
        class Holder {
            static final MemorySegment PRIXMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("jX");
        }
        return Holder.PRIXMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd8 "hhd"
     * }
     */
    public static MemorySegment SCNd8() {
        class Holder {
            static final MemorySegment SCNd8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNd8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi8 "hhi"
     * }
     */
    public static MemorySegment SCNi8() {
        class Holder {
            static final MemorySegment SCNi8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNi8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo8 "hho"
     * }
     */
    public static MemorySegment SCNo8() {
        class Holder {
            static final MemorySegment SCNo8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNo8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu8 "hhu"
     * }
     */
    public static MemorySegment SCNu8() {
        class Holder {
            static final MemorySegment SCNu8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNu8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx8 "hhx"
     * }
     */
    public static MemorySegment SCNx8() {
        class Holder {
            static final MemorySegment SCNx8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNx8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd16 "hd"
     * }
     */
    public static MemorySegment SCNd16() {
        class Holder {
            static final MemorySegment SCNd16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNd16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi16 "hi"
     * }
     */
    public static MemorySegment SCNi16() {
        class Holder {
            static final MemorySegment SCNi16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNi16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo16 "ho"
     * }
     */
    public static MemorySegment SCNo16() {
        class Holder {
            static final MemorySegment SCNo16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNo16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu16 "hu"
     * }
     */
    public static MemorySegment SCNu16() {
        class Holder {
            static final MemorySegment SCNu16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNu16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx16 "hx"
     * }
     */
    public static MemorySegment SCNx16() {
        class Holder {
            static final MemorySegment SCNx16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNx16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd32 "d"
     * }
     */
    public static MemorySegment SCNd32() {
        class Holder {
            static final MemorySegment SCNd32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNd32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi32 "i"
     * }
     */
    public static MemorySegment SCNi32() {
        class Holder {
            static final MemorySegment SCNi32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNi32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo32 "o"
     * }
     */
    public static MemorySegment SCNo32() {
        class Holder {
            static final MemorySegment SCNo32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNo32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu32 "u"
     * }
     */
    public static MemorySegment SCNu32() {
        class Holder {
            static final MemorySegment SCNu32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNu32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx32 "x"
     * }
     */
    public static MemorySegment SCNx32() {
        class Holder {
            static final MemorySegment SCNx32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNx32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNd64 "lld"
     * }
     */
    public static MemorySegment SCNd64() {
        class Holder {
            static final MemorySegment SCNd64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNd64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNi64 "lli"
     * }
     */
    public static MemorySegment SCNi64() {
        class Holder {
            static final MemorySegment SCNi64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNi64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNo64 "llo"
     * }
     */
    public static MemorySegment SCNo64() {
        class Holder {
            static final MemorySegment SCNo64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNo64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNu64 "llu"
     * }
     */
    public static MemorySegment SCNu64() {
        class Holder {
            static final MemorySegment SCNu64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNu64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNx64 "llx"
     * }
     */
    public static MemorySegment SCNx64() {
        class Holder {
            static final MemorySegment SCNx64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNx64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdLEAST8() {
        class Holder {
            static final MemorySegment SCNdLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiLEAST8() {
        class Holder {
            static final MemorySegment SCNiLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST8 "hho"
     * }
     */
    public static MemorySegment SCNoLEAST8() {
        class Holder {
            static final MemorySegment SCNoLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuLEAST8() {
        class Holder {
            static final MemorySegment SCNuLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxLEAST8() {
        class Holder {
            static final MemorySegment SCNxLEAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxLEAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST16 "hd"
     * }
     */
    public static MemorySegment SCNdLEAST16() {
        class Holder {
            static final MemorySegment SCNdLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST16 "hi"
     * }
     */
    public static MemorySegment SCNiLEAST16() {
        class Holder {
            static final MemorySegment SCNiLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST16 "ho"
     * }
     */
    public static MemorySegment SCNoLEAST16() {
        class Holder {
            static final MemorySegment SCNoLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST16 "hu"
     * }
     */
    public static MemorySegment SCNuLEAST16() {
        class Holder {
            static final MemorySegment SCNuLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST16 "hx"
     * }
     */
    public static MemorySegment SCNxLEAST16() {
        class Holder {
            static final MemorySegment SCNxLEAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxLEAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST32 "d"
     * }
     */
    public static MemorySegment SCNdLEAST32() {
        class Holder {
            static final MemorySegment SCNdLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST32 "i"
     * }
     */
    public static MemorySegment SCNiLEAST32() {
        class Holder {
            static final MemorySegment SCNiLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST32 "o"
     * }
     */
    public static MemorySegment SCNoLEAST32() {
        class Holder {
            static final MemorySegment SCNoLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST32 "u"
     * }
     */
    public static MemorySegment SCNuLEAST32() {
        class Holder {
            static final MemorySegment SCNuLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST32 "x"
     * }
     */
    public static MemorySegment SCNxLEAST32() {
        class Holder {
            static final MemorySegment SCNxLEAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxLEAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdLEAST64 "lld"
     * }
     */
    public static MemorySegment SCNdLEAST64() {
        class Holder {
            static final MemorySegment SCNdLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiLEAST64 "lli"
     * }
     */
    public static MemorySegment SCNiLEAST64() {
        class Holder {
            static final MemorySegment SCNiLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoLEAST64 "llo"
     * }
     */
    public static MemorySegment SCNoLEAST64() {
        class Holder {
            static final MemorySegment SCNoLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuLEAST64 "llu"
     * }
     */
    public static MemorySegment SCNuLEAST64() {
        class Holder {
            static final MemorySegment SCNuLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxLEAST64 "llx"
     * }
     */
    public static MemorySegment SCNxLEAST64() {
        class Holder {
            static final MemorySegment SCNxLEAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxLEAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST8 "hhd"
     * }
     */
    public static MemorySegment SCNdFAST8() {
        class Holder {
            static final MemorySegment SCNdFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhd");
        }
        return Holder.SCNdFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST8 "hhi"
     * }
     */
    public static MemorySegment SCNiFAST8() {
        class Holder {
            static final MemorySegment SCNiFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhi");
        }
        return Holder.SCNiFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST8 "hho"
     * }
     */
    public static MemorySegment SCNoFAST8() {
        class Holder {
            static final MemorySegment SCNoFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hho");
        }
        return Holder.SCNoFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST8 "hhu"
     * }
     */
    public static MemorySegment SCNuFAST8() {
        class Holder {
            static final MemorySegment SCNuFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhu");
        }
        return Holder.SCNuFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST8 "hhx"
     * }
     */
    public static MemorySegment SCNxFAST8() {
        class Holder {
            static final MemorySegment SCNxFAST8
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hhx");
        }
        return Holder.SCNxFAST8;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST16 "hd"
     * }
     */
    public static MemorySegment SCNdFAST16() {
        class Holder {
            static final MemorySegment SCNdFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hd");
        }
        return Holder.SCNdFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST16 "hi"
     * }
     */
    public static MemorySegment SCNiFAST16() {
        class Holder {
            static final MemorySegment SCNiFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hi");
        }
        return Holder.SCNiFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST16 "ho"
     * }
     */
    public static MemorySegment SCNoFAST16() {
        class Holder {
            static final MemorySegment SCNoFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ho");
        }
        return Holder.SCNoFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST16 "hu"
     * }
     */
    public static MemorySegment SCNuFAST16() {
        class Holder {
            static final MemorySegment SCNuFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hu");
        }
        return Holder.SCNuFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST16 "hx"
     * }
     */
    public static MemorySegment SCNxFAST16() {
        class Holder {
            static final MemorySegment SCNxFAST16
                = FFmpeg.LIBRARY_ARENA.allocateFrom("hx");
        }
        return Holder.SCNxFAST16;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST32 "d"
     * }
     */
    public static MemorySegment SCNdFAST32() {
        class Holder {
            static final MemorySegment SCNdFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("d");
        }
        return Holder.SCNdFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST32 "i"
     * }
     */
    public static MemorySegment SCNiFAST32() {
        class Holder {
            static final MemorySegment SCNiFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("i");
        }
        return Holder.SCNiFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST32 "o"
     * }
     */
    public static MemorySegment SCNoFAST32() {
        class Holder {
            static final MemorySegment SCNoFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("o");
        }
        return Holder.SCNoFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST32 "u"
     * }
     */
    public static MemorySegment SCNuFAST32() {
        class Holder {
            static final MemorySegment SCNuFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("u");
        }
        return Holder.SCNuFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST32 "x"
     * }
     */
    public static MemorySegment SCNxFAST32() {
        class Holder {
            static final MemorySegment SCNxFAST32
                = FFmpeg.LIBRARY_ARENA.allocateFrom("x");
        }
        return Holder.SCNxFAST32;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdFAST64 "lld"
     * }
     */
    public static MemorySegment SCNdFAST64() {
        class Holder {
            static final MemorySegment SCNdFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lld");
        }
        return Holder.SCNdFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiFAST64 "lli"
     * }
     */
    public static MemorySegment SCNiFAST64() {
        class Holder {
            static final MemorySegment SCNiFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lli");
        }
        return Holder.SCNiFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoFAST64 "llo"
     * }
     */
    public static MemorySegment SCNoFAST64() {
        class Holder {
            static final MemorySegment SCNoFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llo");
        }
        return Holder.SCNoFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuFAST64 "llu"
     * }
     */
    public static MemorySegment SCNuFAST64() {
        class Holder {
            static final MemorySegment SCNuFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llu");
        }
        return Holder.SCNuFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxFAST64 "llx"
     * }
     */
    public static MemorySegment SCNxFAST64() {
        class Holder {
            static final MemorySegment SCNxFAST64
                = FFmpeg.LIBRARY_ARENA.allocateFrom("llx");
        }
        return Holder.SCNxFAST64;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdPTR "ld"
     * }
     */
    public static MemorySegment SCNdPTR() {
        class Holder {
            static final MemorySegment SCNdPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ld");
        }
        return Holder.SCNdPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiPTR "li"
     * }
     */
    public static MemorySegment SCNiPTR() {
        class Holder {
            static final MemorySegment SCNiPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("li");
        }
        return Holder.SCNiPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoPTR "lo"
     * }
     */
    public static MemorySegment SCNoPTR() {
        class Holder {
            static final MemorySegment SCNoPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lo");
        }
        return Holder.SCNoPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuPTR "lu"
     * }
     */
    public static MemorySegment SCNuPTR() {
        class Holder {
            static final MemorySegment SCNuPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lu");
        }
        return Holder.SCNuPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxPTR "lx"
     * }
     */
    public static MemorySegment SCNxPTR() {
        class Holder {
            static final MemorySegment SCNxPTR
                = FFmpeg.LIBRARY_ARENA.allocateFrom("lx");
        }
        return Holder.SCNxPTR;
    }
    /**
     * {@snippet lang=c :
     * #define SCNdMAX "jd"
     * }
     */
    public static MemorySegment SCNdMAX() {
        class Holder {
            static final MemorySegment SCNdMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("jd");
        }
        return Holder.SCNdMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNiMAX "ji"
     * }
     */
    public static MemorySegment SCNiMAX() {
        class Holder {
            static final MemorySegment SCNiMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ji");
        }
        return Holder.SCNiMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNoMAX "jo"
     * }
     */
    public static MemorySegment SCNoMAX() {
        class Holder {
            static final MemorySegment SCNoMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("jo");
        }
        return Holder.SCNoMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNuMAX "ju"
     * }
     */
    public static MemorySegment SCNuMAX() {
        class Holder {
            static final MemorySegment SCNuMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("ju");
        }
        return Holder.SCNuMAX;
    }
    /**
     * {@snippet lang=c :
     * #define SCNxMAX "jx"
     * }
     */
    public static MemorySegment SCNxMAX() {
        class Holder {
            static final MemorySegment SCNxMAX
                = FFmpeg.LIBRARY_ARENA.allocateFrom("jx");
        }
        return Holder.SCNxMAX;
    }
    private static final int CLK_TCK = (int)100L;
    /**
     * {@snippet lang=c :
     * #define CLK_TCK 100
     * }
     */
    public static int CLK_TCK() {
        return CLK_TCK;
    }
    private static final int SCHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define SCHAR_MIN -128
     * }
     */
    public static int SCHAR_MIN() {
        return SCHAR_MIN;
    }
    private static final int CHAR_MIN = (int)-128L;
    /**
     * {@snippet lang=c :
     * #define CHAR_MIN -128
     * }
     */
    public static int CHAR_MIN() {
        return CHAR_MIN;
    }
    private static final int SHRT_MIN = (int)-32768L;
    /**
     * {@snippet lang=c :
     * #define SHRT_MIN -32768
     * }
     */
    public static int SHRT_MIN() {
        return SHRT_MIN;
    }
    private static final int UINT_MAX = (int)4294967295L;
    /**
     * {@snippet lang=c :
     * #define UINT_MAX 4294967295
     * }
     */
    public static int UINT_MAX() {
        return UINT_MAX;
    }
    private static final int INT_MIN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define INT_MIN -2147483648
     * }
     */
    public static int INT_MIN() {
        return INT_MIN;
    }
    private static final long ULONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_MAX -1
     * }
     */
    public static long ULONG_MAX() {
        return ULONG_MAX;
    }
    private static final long LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_MAX() {
        return LONG_MAX;
    }
    private static final long LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_MIN() {
        return LONG_MIN;
    }
    private static final long ULLONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULLONG_MAX -1
     * }
     */
    public static long ULLONG_MAX() {
        return ULLONG_MAX;
    }
    private static final long LLONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MAX 9223372036854775807
     * }
     */
    public static long LLONG_MAX() {
        return LLONG_MAX;
    }
    private static final long LLONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LLONG_MIN -9223372036854775808
     * }
     */
    public static long LLONG_MIN() {
        return LLONG_MIN;
    }
    private static final long SSIZE_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define SSIZE_MAX 9223372036854775807
     * }
     */
    public static long SSIZE_MAX() {
        return SSIZE_MAX;
    }
    private static final long SIZE_T_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define SIZE_T_MAX -1
     * }
     */
    public static long SIZE_T_MAX() {
        return SIZE_T_MAX;
    }
    private static final long UQUAD_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define UQUAD_MAX -1
     * }
     */
    public static long UQUAD_MAX() {
        return UQUAD_MAX;
    }
    private static final long QUAD_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MAX 9223372036854775807
     * }
     */
    public static long QUAD_MAX() {
        return QUAD_MAX;
    }
    private static final long QUAD_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define QUAD_MIN -9223372036854775808
     * }
     */
    public static long QUAD_MIN() {
        return QUAD_MIN;
    }
    private static final int ARG_MAX = (int)1048576L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 1048576
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }
    private static final int GID_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define GID_MAX 2147483647
     * }
     */
    public static int GID_MAX() {
        return GID_MAX;
    }
    private static final int UID_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define UID_MAX 2147483647
     * }
     */
    public static int UID_MAX() {
        return UID_MAX;
    }
    private static final int _POSIX_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }
    private static final long OFF_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define OFF_MIN -9223372036854775808
     * }
     */
    public static long OFF_MIN() {
        return OFF_MIN;
    }
    private static final long OFF_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define OFF_MAX 9223372036854775807
     * }
     */
    public static long OFF_MAX() {
        return OFF_MAX;
    }
    private static final long LONG_LONG_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MAX 9223372036854775807
     * }
     */
    public static long LONG_LONG_MAX() {
        return LONG_LONG_MAX;
    }
    private static final long LONG_LONG_MIN = -9223372036854775808L;
    /**
     * {@snippet lang=c :
     * #define LONG_LONG_MIN -9223372036854775808
     * }
     */
    public static long LONG_LONG_MIN() {
        return LONG_LONG_MIN;
    }
    private static final long ULONG_LONG_MAX = -1L;
    /**
     * {@snippet lang=c :
     * #define ULONG_LONG_MAX -1
     * }
     */
    public static long ULONG_LONG_MAX() {
        return ULONG_LONG_MAX;
    }
    private static final double HUGE_VAL = Double.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VAL Infinity
     * }
     */
    public static double HUGE_VAL() {
        return HUGE_VAL;
    }
    private static final float HUGE_VALF = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define HUGE_VALF Infinity
     * }
     */
    public static float HUGE_VALF() {
        return HUGE_VALF;
    }
    private static final float NAN = Float.valueOf("NaN");
    /**
     * {@snippet lang=c :
     * #define NAN NaN
     * }
     */
    public static float NAN() {
        return NAN;
    }
    private static final float INFINITY = Float.valueOf("Infinity");
    /**
     * {@snippet lang=c :
     * #define INFINITY Infinity
     * }
     */
    public static float INFINITY() {
        return INFINITY;
    }
    private static final int FP_ILOGB0 = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGB0 -2147483648
     * }
     */
    public static int FP_ILOGB0() {
        return FP_ILOGB0;
    }
    private static final int FP_ILOGBNAN = (int)-2147483648L;
    /**
     * {@snippet lang=c :
     * #define FP_ILOGBNAN -2147483648
     * }
     */
    public static int FP_ILOGBNAN() {
        return FP_ILOGBNAN;
    }
    private static final double M_E = 2.718281828459045d;
    /**
     * {@snippet lang=c :
     * #define M_E 2.718281828459045
     * }
     */
    public static double M_E() {
        return M_E;
    }
    private static final double M_LOG2E = 1.4426950408889634d;
    /**
     * {@snippet lang=c :
     * #define M_LOG2E 1.4426950408889634
     * }
     */
    public static double M_LOG2E() {
        return M_LOG2E;
    }
    private static final double M_LOG10E = 0.4342944819032518d;
    /**
     * {@snippet lang=c :
     * #define M_LOG10E 0.4342944819032518
     * }
     */
    public static double M_LOG10E() {
        return M_LOG10E;
    }
    private static final double M_LN2 = 0.6931471805599453d;
    /**
     * {@snippet lang=c :
     * #define M_LN2 0.6931471805599453
     * }
     */
    public static double M_LN2() {
        return M_LN2;
    }
    private static final double M_LN10 = 2.302585092994046d;
    /**
     * {@snippet lang=c :
     * #define M_LN10 2.302585092994046
     * }
     */
    public static double M_LN10() {
        return M_LN10;
    }
    private static final double M_PI = 3.141592653589793d;
    /**
     * {@snippet lang=c :
     * #define M_PI 3.141592653589793
     * }
     */
    public static double M_PI() {
        return M_PI;
    }
    private static final double M_PI_2 = 1.5707963267948966d;
    /**
     * {@snippet lang=c :
     * #define M_PI_2 1.5707963267948966
     * }
     */
    public static double M_PI_2() {
        return M_PI_2;
    }
    private static final double M_PI_4 = 0.7853981633974483d;
    /**
     * {@snippet lang=c :
     * #define M_PI_4 0.7853981633974483
     * }
     */
    public static double M_PI_4() {
        return M_PI_4;
    }
    private static final double M_1_PI = 0.3183098861837907d;
    /**
     * {@snippet lang=c :
     * #define M_1_PI 0.3183098861837907
     * }
     */
    public static double M_1_PI() {
        return M_1_PI;
    }
    private static final double M_2_PI = 0.6366197723675814d;
    /**
     * {@snippet lang=c :
     * #define M_2_PI 0.6366197723675814
     * }
     */
    public static double M_2_PI() {
        return M_2_PI;
    }
    private static final double M_2_SQRTPI = 1.1283791670955126d;
    /**
     * {@snippet lang=c :
     * #define M_2_SQRTPI 1.1283791670955126
     * }
     */
    public static double M_2_SQRTPI() {
        return M_2_SQRTPI;
    }
    private static final double M_SQRT2 = 1.4142135623730951d;
    /**
     * {@snippet lang=c :
     * #define M_SQRT2 1.4142135623730951
     * }
     */
    public static double M_SQRT2() {
        return M_SQRT2;
    }
    private static final double M_SQRT1_2 = 0.7071067811865476d;
    /**
     * {@snippet lang=c :
     * #define M_SQRT1_2 0.7071067811865476
     * }
     */
    public static double M_SQRT1_2() {
        return M_SQRT1_2;
    }
    private static final float MAXFLOAT = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define MAXFLOAT 3.4028234663852886E38
     * }
     */
    public static float MAXFLOAT() {
        return MAXFLOAT;
    }
    private static final int FP_SNAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_SNAN 1
     * }
     */
    public static int FP_SNAN() {
        return FP_SNAN;
    }
    private static final int FP_QNAN = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FP_QNAN 1
     * }
     */
    public static int FP_QNAN() {
        return FP_QNAN;
    }
    private static final float HUGE = 3.4028234663852886E38f;
    /**
     * {@snippet lang=c :
     * #define HUGE 3.4028234663852886E38
     * }
     */
    public static float HUGE() {
        return HUGE;
    }
    private static final double X_TLOSS = 1.414847550405688E16d;
    /**
     * {@snippet lang=c :
     * #define X_TLOSS 1.414847550405688E16
     * }
     */
    public static double X_TLOSS() {
        return X_TLOSS;
    }
    private static final int NSIG = (int)32L;
    /**
     * {@snippet lang=c :
     * #define NSIG 32
     * }
     */
    public static int NSIG() {
        return NSIG;
    }
    private static final int SIGIOT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define SIGIOT 6
     * }
     */
    public static int SIGIOT() {
        return SIGIOT;
    }
    private static final MemorySegment SIG_DFL = MemorySegment.ofAddress(0L);
    /**
     * {@snippet lang=c :
     * #define SIG_DFL (void*) 0
     * }
     */
    public static MemorySegment SIG_DFL() {
        return SIG_DFL;
    }
    private static final MemorySegment SIG_IGN = MemorySegment.ofAddress(1L);
    /**
     * {@snippet lang=c :
     * #define SIG_IGN (void*) 1
     * }
     */
    public static MemorySegment SIG_IGN() {
        return SIG_IGN;
    }
    private static final MemorySegment SIG_HOLD = MemorySegment.ofAddress(5L);
    /**
     * {@snippet lang=c :
     * #define SIG_HOLD (void*) 5
     * }
     */
    public static MemorySegment SIG_HOLD() {
        return SIG_HOLD;
    }
    private static final MemorySegment SIG_ERR = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define SIG_ERR (void*) -1
     * }
     */
    public static MemorySegment SIG_ERR() {
        return SIG_ERR;
    }
    private static final int SA_USERSPACE_MASK = (int)127L;
    /**
     * {@snippet lang=c :
     * #define SA_USERSPACE_MASK 127
     * }
     */
    public static int SA_USERSPACE_MASK() {
        return SA_USERSPACE_MASK;
    }
    private static final int SV_ONSTACK = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SV_ONSTACK 1
     * }
     */
    public static int SV_ONSTACK() {
        return SV_ONSTACK;
    }
    private static final int SV_INTERRUPT = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SV_INTERRUPT 2
     * }
     */
    public static int SV_INTERRUPT() {
        return SV_INTERRUPT;
    }
    private static final int SV_RESETHAND = (int)4L;
    /**
     * {@snippet lang=c :
     * #define SV_RESETHAND 4
     * }
     */
    public static int SV_RESETHAND() {
        return SV_RESETHAND;
    }
    private static final int SV_NODEFER = (int)16L;
    /**
     * {@snippet lang=c :
     * #define SV_NODEFER 16
     * }
     */
    public static int SV_NODEFER() {
        return SV_NODEFER;
    }
    private static final int SV_NOCLDSTOP = (int)8L;
    /**
     * {@snippet lang=c :
     * #define SV_NOCLDSTOP 8
     * }
     */
    public static int SV_NOCLDSTOP() {
        return SV_NOCLDSTOP;
    }
    private static final int SV_SIGINFO = (int)64L;
    /**
     * {@snippet lang=c :
     * #define SV_SIGINFO 64
     * }
     */
    public static int SV_SIGINFO() {
        return SV_SIGINFO;
    }
    private static final MemorySegment BADSIG = MemorySegment.ofAddress(-1L);
    /**
     * {@snippet lang=c :
     * #define BADSIG (void*) -1
     * }
     */
    public static MemorySegment BADSIG() {
        return BADSIG;
    }
    private static final int PRIO_MIN = (int)-20L;
    /**
     * {@snippet lang=c :
     * #define PRIO_MIN -20
     * }
     */
    public static int PRIO_MIN() {
        return PRIO_MIN;
    }
    private static final int RUSAGE_CHILDREN = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_CHILDREN -1
     * }
     */
    public static int RUSAGE_CHILDREN() {
        return RUSAGE_CHILDREN;
    }
    private static final int RUSAGE_INFO_CURRENT = (int)6L;
    /**
     * {@snippet lang=c :
     * #define RUSAGE_INFO_CURRENT 6
     * }
     */
    public static int RUSAGE_INFO_CURRENT() {
        return RUSAGE_INFO_CURRENT;
    }
    private static final long RLIM_INFINITY = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_INFINITY 9223372036854775807
     * }
     */
    public static long RLIM_INFINITY() {
        return RLIM_INFINITY;
    }
    private static final long RLIM_SAVED_MAX = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_MAX 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_MAX() {
        return RLIM_SAVED_MAX;
    }
    private static final long RLIM_SAVED_CUR = 9223372036854775807L;
    /**
     * {@snippet lang=c :
     * #define RLIM_SAVED_CUR 9223372036854775807
     * }
     */
    public static long RLIM_SAVED_CUR() {
        return RLIM_SAVED_CUR;
    }
    private static final int RLIMIT_RSS = (int)5L;
    /**
     * {@snippet lang=c :
     * #define RLIMIT_RSS 5
     * }
     */
    public static int RLIMIT_RSS() {
        return RLIMIT_RSS;
    }
    private static final int IOPOL_APPLICATION = (int)5L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_APPLICATION 5
     * }
     */
    public static int IOPOL_APPLICATION() {
        return IOPOL_APPLICATION;
    }
    private static final int IOPOL_NORMAL = (int)1L;
    /**
     * {@snippet lang=c :
     * #define IOPOL_NORMAL 1
     * }
     */
    public static int IOPOL_NORMAL() {
        return IOPOL_NORMAL;
    }
    private static final int WAIT_ANY = (int)-1L;
    /**
     * {@snippet lang=c :
     * #define WAIT_ANY -1
     * }
     */
    public static int WAIT_ANY() {
        return WAIT_ANY;
    }
    private static final int LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define LITTLE_ENDIAN 1234
     * }
     */
    public static int LITTLE_ENDIAN() {
        return LITTLE_ENDIAN;
    }
    private static final int BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define BIG_ENDIAN 4321
     * }
     */
    public static int BIG_ENDIAN() {
        return BIG_ENDIAN;
    }
    private static final int PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define PDP_ENDIAN 3412
     * }
     */
    public static int PDP_ENDIAN() {
        return PDP_ENDIAN;
    }
    private static final int __DARWIN_BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __DARWIN_BYTE_ORDER 1234
     * }
     */
    public static int __DARWIN_BYTE_ORDER() {
        return __DARWIN_BYTE_ORDER;
    }
    private static final int BYTE_ORDER = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define BYTE_ORDER 1234
     * }
     */
    public static int BYTE_ORDER() {
        return BYTE_ORDER;
    }
    private static final int AVERROR_BSF_NOT_FOUND = (int)-1179861752L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BSF_NOT_FOUND -1179861752
     * }
     */
    public static int AVERROR_BSF_NOT_FOUND() {
        return AVERROR_BSF_NOT_FOUND;
    }
    private static final int AVERROR_BUG = (int)-558323010L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BUG -558323010
     * }
     */
    public static int AVERROR_BUG() {
        return AVERROR_BUG;
    }
    private static final int AVERROR_BUFFER_TOO_SMALL = (int)-1397118274L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BUFFER_TOO_SMALL -1397118274
     * }
     */
    public static int AVERROR_BUFFER_TOO_SMALL() {
        return AVERROR_BUFFER_TOO_SMALL;
    }
    private static final int AVERROR_DECODER_NOT_FOUND = (int)-1128613112L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_DECODER_NOT_FOUND -1128613112
     * }
     */
    public static int AVERROR_DECODER_NOT_FOUND() {
        return AVERROR_DECODER_NOT_FOUND;
    }
    private static final int AVERROR_DEMUXER_NOT_FOUND = (int)-1296385272L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_DEMUXER_NOT_FOUND -1296385272
     * }
     */
    public static int AVERROR_DEMUXER_NOT_FOUND() {
        return AVERROR_DEMUXER_NOT_FOUND;
    }
    private static final int AVERROR_ENCODER_NOT_FOUND = (int)-1129203192L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_ENCODER_NOT_FOUND -1129203192
     * }
     */
    public static int AVERROR_ENCODER_NOT_FOUND() {
        return AVERROR_ENCODER_NOT_FOUND;
    }
    private static final int AVERROR_EOF = (int)-541478725L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EOF -541478725
     * }
     */
    public static int AVERROR_EOF() {
        return AVERROR_EOF;
    }
    private static final int AVERROR_EXIT = (int)-1414092869L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EXIT -1414092869
     * }
     */
    public static int AVERROR_EXIT() {
        return AVERROR_EXIT;
    }
    private static final int AVERROR_EXTERNAL = (int)-542398533L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EXTERNAL -542398533
     * }
     */
    public static int AVERROR_EXTERNAL() {
        return AVERROR_EXTERNAL;
    }
    private static final int AVERROR_FILTER_NOT_FOUND = (int)-1279870712L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_FILTER_NOT_FOUND -1279870712
     * }
     */
    public static int AVERROR_FILTER_NOT_FOUND() {
        return AVERROR_FILTER_NOT_FOUND;
    }
    private static final int AVERROR_INVALIDDATA = (int)-1094995529L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_INVALIDDATA -1094995529
     * }
     */
    public static int AVERROR_INVALIDDATA() {
        return AVERROR_INVALIDDATA;
    }
    private static final int AVERROR_MUXER_NOT_FOUND = (int)-1481985528L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_MUXER_NOT_FOUND -1481985528
     * }
     */
    public static int AVERROR_MUXER_NOT_FOUND() {
        return AVERROR_MUXER_NOT_FOUND;
    }
    private static final int AVERROR_OPTION_NOT_FOUND = (int)-1414549496L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_OPTION_NOT_FOUND -1414549496
     * }
     */
    public static int AVERROR_OPTION_NOT_FOUND() {
        return AVERROR_OPTION_NOT_FOUND;
    }
    private static final int AVERROR_PATCHWELCOME = (int)-1163346256L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_PATCHWELCOME -1163346256
     * }
     */
    public static int AVERROR_PATCHWELCOME() {
        return AVERROR_PATCHWELCOME;
    }
    private static final int AVERROR_PROTOCOL_NOT_FOUND = (int)-1330794744L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_PROTOCOL_NOT_FOUND -1330794744
     * }
     */
    public static int AVERROR_PROTOCOL_NOT_FOUND() {
        return AVERROR_PROTOCOL_NOT_FOUND;
    }
    private static final int AVERROR_STREAM_NOT_FOUND = (int)-1381258232L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_STREAM_NOT_FOUND -1381258232
     * }
     */
    public static int AVERROR_STREAM_NOT_FOUND() {
        return AVERROR_STREAM_NOT_FOUND;
    }
    private static final int AVERROR_BUG2 = (int)-541545794L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_BUG2 -541545794
     * }
     */
    public static int AVERROR_BUG2() {
        return AVERROR_BUG2;
    }
    private static final int AVERROR_UNKNOWN = (int)-1313558101L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_UNKNOWN -1313558101
     * }
     */
    public static int AVERROR_UNKNOWN() {
        return AVERROR_UNKNOWN;
    }
    private static final int AVERROR_EXPERIMENTAL = (int)-733130664L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_EXPERIMENTAL -733130664
     * }
     */
    public static int AVERROR_EXPERIMENTAL() {
        return AVERROR_EXPERIMENTAL;
    }
    private static final int AVERROR_INPUT_CHANGED = (int)-1668179713L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_INPUT_CHANGED -1668179713
     * }
     */
    public static int AVERROR_INPUT_CHANGED() {
        return AVERROR_INPUT_CHANGED;
    }
    private static final int AVERROR_OUTPUT_CHANGED = (int)-1668179714L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_OUTPUT_CHANGED -1668179714
     * }
     */
    public static int AVERROR_OUTPUT_CHANGED() {
        return AVERROR_OUTPUT_CHANGED;
    }
    private static final int AVERROR_HTTP_BAD_REQUEST = (int)-808465656L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_BAD_REQUEST -808465656
     * }
     */
    public static int AVERROR_HTTP_BAD_REQUEST() {
        return AVERROR_HTTP_BAD_REQUEST;
    }
    private static final int AVERROR_HTTP_UNAUTHORIZED = (int)-825242872L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_UNAUTHORIZED -825242872
     * }
     */
    public static int AVERROR_HTTP_UNAUTHORIZED() {
        return AVERROR_HTTP_UNAUTHORIZED;
    }
    private static final int AVERROR_HTTP_FORBIDDEN = (int)-858797304L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_FORBIDDEN -858797304
     * }
     */
    public static int AVERROR_HTTP_FORBIDDEN() {
        return AVERROR_HTTP_FORBIDDEN;
    }
    private static final int AVERROR_HTTP_NOT_FOUND = (int)-875574520L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_NOT_FOUND -875574520
     * }
     */
    public static int AVERROR_HTTP_NOT_FOUND() {
        return AVERROR_HTTP_NOT_FOUND;
    }
    private static final int AVERROR_HTTP_TOO_MANY_REQUESTS = (int)-959591672L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_TOO_MANY_REQUESTS -959591672
     * }
     */
    public static int AVERROR_HTTP_TOO_MANY_REQUESTS() {
        return AVERROR_HTTP_TOO_MANY_REQUESTS;
    }
    private static final int AVERROR_HTTP_OTHER_4XX = (int)-1482175736L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_OTHER_4XX -1482175736
     * }
     */
    public static int AVERROR_HTTP_OTHER_4XX() {
        return AVERROR_HTTP_OTHER_4XX;
    }
    private static final int AVERROR_HTTP_SERVER_ERROR = (int)-1482175992L;
    /**
     * {@snippet lang=c :
     * #define AVERROR_HTTP_SERVER_ERROR -1482175992
     * }
     */
    public static int AVERROR_HTTP_SERVER_ERROR() {
        return AVERROR_HTTP_SERVER_ERROR;
    }
    private static final int LIBAVUTIL_VERSION_INT = (int)3934308L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_VERSION_INT 3934308
     * }
     */
    public static int LIBAVUTIL_VERSION_INT() {
        return LIBAVUTIL_VERSION_INT;
    }
    private static final int LIBAVUTIL_BUILD = (int)3934308L;
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_BUILD 3934308
     * }
     */
    public static int LIBAVUTIL_BUILD() {
        return LIBAVUTIL_BUILD;
    }
    /**
     * {@snippet lang=c :
     * #define LIBAVUTIL_IDENT "Lavu60.8.100"
     * }
     */
    public static MemorySegment LIBAVUTIL_IDENT() {
        class Holder {
            static final MemorySegment LIBAVUTIL_IDENT
                = FFmpeg.LIBRARY_ARENA.allocateFrom("Lavu60.8.100");
        }
        return Holder.LIBAVUTIL_IDENT;
    }
    private static final int FF_API_MOD_UINTP2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_MOD_UINTP2 1
     * }
     */
    public static int FF_API_MOD_UINTP2() {
        return FF_API_MOD_UINTP2;
    }
    private static final int FF_API_RISCV_FD_ZBA = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_RISCV_FD_ZBA 1
     * }
     */
    public static int FF_API_RISCV_FD_ZBA() {
        return FF_API_RISCV_FD_ZBA;
    }
    private static final int FF_API_VULKAN_FIXED_QUEUES = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_VULKAN_FIXED_QUEUES 1
     * }
     */
    public static int FF_API_VULKAN_FIXED_QUEUES() {
        return FF_API_VULKAN_FIXED_QUEUES;
    }
    private static final int FF_API_OPT_INT_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_OPT_INT_LIST 1
     * }
     */
    public static int FF_API_OPT_INT_LIST() {
        return FF_API_OPT_INT_LIST;
    }
    private static final int FF_API_OPT_PTR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define FF_API_OPT_PTR 1
     * }
     */
    public static int FF_API_OPT_PTR() {
        return FF_API_OPT_PTR;
    }
    private static final float M_Ef = 2.7182817459106445f;
    /**
     * {@snippet lang=c :
     * #define M_Ef 2.7182817459106445
     * }
     */
    public static float M_Ef() {
        return M_Ef;
    }
    private static final float M_LN2f = 0.6931471824645996f;
    /**
     * {@snippet lang=c :
     * #define M_LN2f 0.6931471824645996
     * }
     */
    public static float M_LN2f() {
        return M_LN2f;
    }
    private static final float M_LN10f = 2.3025851249694824f;
    /**
     * {@snippet lang=c :
     * #define M_LN10f 2.3025851249694824
     * }
     */
    public static float M_LN10f() {
        return M_LN10f;
    }
    private static final double M_LOG2_10 = 3.321928094887362d;
    /**
     * {@snippet lang=c :
     * #define M_LOG2_10 3.321928094887362
     * }
     */
    public static double M_LOG2_10() {
        return M_LOG2_10;
    }
    private static final float M_LOG2_10f = 3.321928024291992f;
    /**
     * {@snippet lang=c :
     * #define M_LOG2_10f 3.321928024291992
     * }
     */
    public static float M_LOG2_10f() {
        return M_LOG2_10f;
    }
    private static final double M_PHI = 1.618033988749895d;
    /**
     * {@snippet lang=c :
     * #define M_PHI 1.618033988749895
     * }
     */
    public static double M_PHI() {
        return M_PHI;
    }
    private static final float M_PHIf = 1.6180340051651f;
    /**
     * {@snippet lang=c :
     * #define M_PHIf 1.6180340051651
     * }
     */
    public static float M_PHIf() {
        return M_PHIf;
    }
    private static final float M_PIf = 3.1415927410125732f;
    /**
     * {@snippet lang=c :
     * #define M_PIf 3.1415927410125732
     * }
     */
    public static float M_PIf() {
        return M_PIf;
    }
    private static final float M_PI_2f = 1.5707963705062866f;
    /**
     * {@snippet lang=c :
     * #define M_PI_2f 1.5707963705062866
     * }
     */
    public static float M_PI_2f() {
        return M_PI_2f;
    }
    private static final float M_PI_4f = 0.7853981852531433f;
    /**
     * {@snippet lang=c :
     * #define M_PI_4f 0.7853981852531433
     * }
     */
    public static float M_PI_4f() {
        return M_PI_4f;
    }
    private static final float M_1_PIf = 0.31830987334251404f;
    /**
     * {@snippet lang=c :
     * #define M_1_PIf 0.31830987334251404
     * }
     */
    public static float M_1_PIf() {
        return M_1_PIf;
    }
    private static final float M_2_PIf = 0.6366197466850281f;
    /**
     * {@snippet lang=c :
     * #define M_2_PIf 0.6366197466850281
     * }
     */
    public static float M_2_PIf() {
        return M_2_PIf;
    }
    private static final float M_2_SQRTPIf = 1.128379225730896f;
    /**
     * {@snippet lang=c :
     * #define M_2_SQRTPIf 1.128379225730896
     * }
     */
    public static float M_2_SQRTPIf() {
        return M_2_SQRTPIf;
    }
    private static final float M_SQRT1_2f = 0.7071067690849304f;
    /**
     * {@snippet lang=c :
     * #define M_SQRT1_2f 0.7071067690849304
     * }
     */
    public static float M_SQRT1_2f() {
        return M_SQRT1_2f;
    }
    private static final float M_SQRT2f = 1.4142135381698608f;
    /**
     * {@snippet lang=c :
     * #define M_SQRT2f 1.4142135381698608
     * }
     */
    public static float M_SQRT2f() {
        return M_SQRT2f;
    }
    private static final int AV_LOG_QUIET = (int)-8L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_QUIET -8
     * }
     */
    public static int AV_LOG_QUIET() {
        return AV_LOG_QUIET;
    }
    private static final int AV_LOG_MAX_OFFSET = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_LOG_MAX_OFFSET 64
     * }
     */
    public static int AV_LOG_MAX_OFFSET() {
        return AV_LOG_MAX_OFFSET;
    }
    private static final int AV_PIX_FMT_RGB32 = (int)28L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB32 28
     * }
     */
    public static int AV_PIX_FMT_RGB32() {
        return AV_PIX_FMT_RGB32;
    }
    private static final int AV_PIX_FMT_RGB32_1 = (int)27L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB32_1 27
     * }
     */
    public static int AV_PIX_FMT_RGB32_1() {
        return AV_PIX_FMT_RGB32_1;
    }
    private static final int AV_PIX_FMT_BGR32 = (int)26L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR32 26
     * }
     */
    public static int AV_PIX_FMT_BGR32() {
        return AV_PIX_FMT_BGR32;
    }
    private static final int AV_PIX_FMT_BGR32_1 = (int)25L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR32_1 25
     * }
     */
    public static int AV_PIX_FMT_BGR32_1() {
        return AV_PIX_FMT_BGR32_1;
    }
    private static final int AV_PIX_FMT_0RGB32 = (int)121L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_0RGB32 121
     * }
     */
    public static int AV_PIX_FMT_0RGB32() {
        return AV_PIX_FMT_0RGB32;
    }
    private static final int AV_PIX_FMT_0BGR32 = (int)119L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_0BGR32 119
     * }
     */
    public static int AV_PIX_FMT_0BGR32() {
        return AV_PIX_FMT_0BGR32;
    }
    private static final int AV_PIX_FMT_GRAY9 = (int)173L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY9 173
     * }
     */
    public static int AV_PIX_FMT_GRAY9() {
        return AV_PIX_FMT_GRAY9;
    }
    private static final int AV_PIX_FMT_GRAY10 = (int)168L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY10 168
     * }
     */
    public static int AV_PIX_FMT_GRAY10() {
        return AV_PIX_FMT_GRAY10;
    }
    private static final int AV_PIX_FMT_GRAY12 = (int)166L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY12 166
     * }
     */
    public static int AV_PIX_FMT_GRAY12() {
        return AV_PIX_FMT_GRAY12;
    }
    private static final int AV_PIX_FMT_GRAY14 = (int)181L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY14 181
     * }
     */
    public static int AV_PIX_FMT_GRAY14() {
        return AV_PIX_FMT_GRAY14;
    }
    private static final int AV_PIX_FMT_GRAY16 = (int)30L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY16 30
     * }
     */
    public static int AV_PIX_FMT_GRAY16() {
        return AV_PIX_FMT_GRAY16;
    }
    private static final int AV_PIX_FMT_GRAY32 = (int)251L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_GRAY32 251
     * }
     */
    public static int AV_PIX_FMT_GRAY32() {
        return AV_PIX_FMT_GRAY32;
    }
    private static final int AV_PIX_FMT_YA16 = (int)110L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YA16 110
     * }
     */
    public static int AV_PIX_FMT_YA16() {
        return AV_PIX_FMT_YA16;
    }
    private static final int AV_PIX_FMT_RGB48 = (int)35L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB48 35
     * }
     */
    public static int AV_PIX_FMT_RGB48() {
        return AV_PIX_FMT_RGB48;
    }
    private static final int AV_PIX_FMT_RGB565 = (int)37L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB565 37
     * }
     */
    public static int AV_PIX_FMT_RGB565() {
        return AV_PIX_FMT_RGB565;
    }
    private static final int AV_PIX_FMT_RGB555 = (int)39L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB555 39
     * }
     */
    public static int AV_PIX_FMT_RGB555() {
        return AV_PIX_FMT_RGB555;
    }
    private static final int AV_PIX_FMT_RGB444 = (int)52L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGB444 52
     * }
     */
    public static int AV_PIX_FMT_RGB444() {
        return AV_PIX_FMT_RGB444;
    }
    private static final int AV_PIX_FMT_RGBA64 = (int)105L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_RGBA64 105
     * }
     */
    public static int AV_PIX_FMT_RGBA64() {
        return AV_PIX_FMT_RGBA64;
    }
    private static final int AV_PIX_FMT_BGR48 = (int)58L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR48 58
     * }
     */
    public static int AV_PIX_FMT_BGR48() {
        return AV_PIX_FMT_BGR48;
    }
    private static final int AV_PIX_FMT_BGR565 = (int)41L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR565 41
     * }
     */
    public static int AV_PIX_FMT_BGR565() {
        return AV_PIX_FMT_BGR565;
    }
    private static final int AV_PIX_FMT_BGR555 = (int)43L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR555 43
     * }
     */
    public static int AV_PIX_FMT_BGR555() {
        return AV_PIX_FMT_BGR555;
    }
    private static final int AV_PIX_FMT_BGR444 = (int)54L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGR444 54
     * }
     */
    public static int AV_PIX_FMT_BGR444() {
        return AV_PIX_FMT_BGR444;
    }
    private static final int AV_PIX_FMT_BGRA64 = (int)107L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_BGRA64 107
     * }
     */
    public static int AV_PIX_FMT_BGRA64() {
        return AV_PIX_FMT_BGRA64;
    }
    private static final int AV_PIX_FMT_YUV420P9 = (int)60L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P9 60
     * }
     */
    public static int AV_PIX_FMT_YUV420P9() {
        return AV_PIX_FMT_YUV420P9;
    }
    private static final int AV_PIX_FMT_YUV422P9 = (int)70L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P9 70
     * }
     */
    public static int AV_PIX_FMT_YUV422P9() {
        return AV_PIX_FMT_YUV422P9;
    }
    private static final int AV_PIX_FMT_YUV444P9 = (int)66L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P9 66
     * }
     */
    public static int AV_PIX_FMT_YUV444P9() {
        return AV_PIX_FMT_YUV444P9;
    }
    private static final int AV_PIX_FMT_YUV420P10 = (int)62L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P10 62
     * }
     */
    public static int AV_PIX_FMT_YUV420P10() {
        return AV_PIX_FMT_YUV420P10;
    }
    private static final int AV_PIX_FMT_YUV422P10 = (int)64L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P10 64
     * }
     */
    public static int AV_PIX_FMT_YUV422P10() {
        return AV_PIX_FMT_YUV422P10;
    }
    private static final int AV_PIX_FMT_YUV440P10 = (int)151L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV440P10 151
     * }
     */
    public static int AV_PIX_FMT_YUV440P10() {
        return AV_PIX_FMT_YUV440P10;
    }
    private static final int AV_PIX_FMT_YUV444P10 = (int)68L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P10 68
     * }
     */
    public static int AV_PIX_FMT_YUV444P10() {
        return AV_PIX_FMT_YUV444P10;
    }
    private static final int AV_PIX_FMT_YUV420P12 = (int)123L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P12 123
     * }
     */
    public static int AV_PIX_FMT_YUV420P12() {
        return AV_PIX_FMT_YUV420P12;
    }
    private static final int AV_PIX_FMT_YUV422P12 = (int)127L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P12 127
     * }
     */
    public static int AV_PIX_FMT_YUV422P12() {
        return AV_PIX_FMT_YUV422P12;
    }
    private static final int AV_PIX_FMT_YUV440P12 = (int)153L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV440P12 153
     * }
     */
    public static int AV_PIX_FMT_YUV440P12() {
        return AV_PIX_FMT_YUV440P12;
    }
    private static final int AV_PIX_FMT_YUV444P12 = (int)131L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV444P12 131
     * }
     */
    public static int AV_PIX_FMT_YUV444P12() {
        return AV_PIX_FMT_YUV444P12;
    }
    private static final int AV_PIX_FMT_YUV420P14 = (int)125L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV420P14 125
     * }
     */
    public static int AV_PIX_FMT_YUV420P14() {
        return AV_PIX_FMT_YUV420P14;
    }
    private static final int AV_PIX_FMT_YUV422P14 = (int)129L;
    /**
     * {@snippet lang=c :
     * #define AV_PIX_FMT_YUV422P14 129
     * }
     */
    public static int AV_PIX_FMT_YUV422P14() {
        return AV_PIX_FMT_YUV422P14;
    }
}

